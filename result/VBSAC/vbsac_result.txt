Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.157s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad48 to main}-> N71
Message  : the heap object @H(bad48::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good48, On N69 -> N39 (call good48)
> takes the true branch, At N48 of Function good48
> Leaving function: good48, On N38 -> N70 (Return edge from good48 to main)
> Entering function: bad48, On N70 -> N1 (call bad48)
> takes the false branch, At N10 of Function bad48
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad48)
<Defect> : N0 -> N71: [Return edge from bad48 to main]
N0 -> N71: [Return edge from bad48 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_48.c 103] bad48 		[N0 -{Return edge from bad48 to main}-> N71]	(the heap object @H(bad48::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad15 to main}-> N62
Message  : the heap object @H(bad15::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good15, On N60 -> N35 (call good15)
> takes the true branch, At N43 of Function good15
> Leaving function: good15, On N34 -> N61 (Return edge from good15 to main)
> Entering function: bad15, On N61 -> N1 (call bad15)
> takes the false branch, At N9 of Function bad15
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad15)
<Defect> : N0 -> N62: [Return edge from bad15 to main]
N0 -> N62: [Return edge from bad15 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_15.c 123] bad15 		[N0 -{Return edge from bad15 to main}-> N62]	(the heap object @H(bad15::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad13 to main}-> N62
Message  : the heap object @H(bad13::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good13, On N60 -> N35 (call good13)
> takes the true branch, At N43 of Function good13
> Leaving function: good13, On N34 -> N61 (Return edge from good13 to main)
> Entering function: bad13, On N61 -> N1 (call bad13)
> takes the false branch, At N9 of Function bad13
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad13)
<Defect> : N0 -> N62: [Return edge from bad13 to main]
N0 -> N62: [Return edge from bad13 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_13.c 104] bad13 		[N0 -{Return edge from bad13 to main}-> N62]	(the heap object @H(bad13::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad25 to main}-> N62
Message  : the heap object @H(bad25::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good25, On N60 -> N35 (call good25)
> takes the true branch, At N43 of Function good25
> Leaving function: good25, On N34 -> N61 (Return edge from good25 to main)
> Entering function: bad25, On N61 -> N1 (call bad25)
> takes the false branch, At N9 of Function bad25
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad25)
<Defect> : N0 -> N62: [Return edge from bad25 to main]
N0 -> N62: [Return edge from bad25 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_25.c 102] bad25 		[N0 -{Return edge from bad25 to main}-> N62]	(the heap object @H(bad25::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad42 to main}-> N88
Message  : the heap object @H(bad42::call1) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good42, On N86 -> N47 (call good42)
> Entering function: globalReturnsTrue, On N51 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N52 (Return edge from globalReturnsTrue to good42)
> takes the true branch, At N53 of Function good42
> takes the true branch, At N59 of Function good42
> Leaving function: good42, On N46 -> N87 (Return edge from good42 to main)
> Entering function: bad42, On N87 -> N1 (call bad42)
> Entering function: globalReturnsTrue, On N5 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N6 (Return edge from globalReturnsTrue to bad42)
> takes the true branch, At N7 of Function bad42
> takes the false branch, At N13 of Function bad42
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad42)
> Entering function: globalReturnsTrue, On N20 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N21 (Return edge from globalReturnsTrue to bad42)
> takes the true branch, At N22 of Function bad42
<Defect> : N0 -> N88: [Return edge from bad42 to main]
N0 -> N88: [Return edge from bad42 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_42.c 102] bad42 		[N0 -{Return edge from bad42 to main}-> N88]	(the heap object @H(bad42::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad23 to main}-> N86
Message  : the heap object @H(bad23::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good23, On N84 -> N46 (call good23)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good23)
> takes the true branch, At N52 of Function good23
> takes the true branch, At N57 of Function good23
> Leaving function: good23, On N45 -> N85 (Return edge from good23 to main)
> Entering function: bad23, On N85 -> N1 (call bad23)
> Entering function: staticReturnsTrue, On N5 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N6 (Return edge from staticReturnsTrue to bad23)
> takes the true branch, At N7 of Function bad23
> takes the false branch, At N12 of Function bad23
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad23)
> Entering function: staticReturnsTrue, On N19 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N20 (Return edge from staticReturnsTrue to bad23)
> takes the true branch, At N21 of Function bad23
<Defect> : N0 -> N86: [Return edge from bad23 to main]
N0 -> N86: [Return edge from bad23 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_23.c 112] bad23 		[N0 -{Return edge from bad23 to main}-> N86]	(the heap object @H(bad23::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad46 to main}-> N71
Message  : the heap object @H(bad46::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good46, On N69 -> N39 (call good46)
> takes the true branch, At N48 of Function good46
> Leaving function: good46, On N38 -> N70 (Return edge from good46 to main)
> Entering function: bad46, On N70 -> N1 (call bad46)
> takes the false branch, At N10 of Function bad46
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad46)
<Defect> : N0 -> N71: [Return edge from bad46 to main]
N0 -> N71: [Return edge from bad46 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_46.c 105] bad46 		[N0 -{Return edge from bad46 to main}-> N71]	(the heap object @H(bad46::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad30 to main}-> N86
Message  : the heap object @H(bad30::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good30, On N84 -> N46 (call good30)
> takes the true branch, At N52 of Function good30
> takes the true branch, At N57 of Function good30
> Leaving function: good30, On N45 -> N85 (Return edge from good30 to main)
> Entering function: bad30, On N85 -> N1 (call bad30)
> takes the true branch, At N7 of Function bad30
> takes the false branch, At N12 of Function bad30
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad30)
> takes the true branch, At N21 of Function bad30
<Defect> : N0 -> N86: [Return edge from bad30 to main]
N0 -> N86: [Return edge from bad30 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_30.c 102] bad30 		[N0 -{Return edge from bad30 to main}-> N86]	(the heap object @H(bad30::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad40 to main}-> N64
Message  : the heap object @H(bad40::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good40, On N62 -> N36 (call good40)
> takes the true branch, At N45 of Function good40
> Leaving function: good40, On N35 -> N63 (Return edge from good40 to main)
> Entering function: bad40, On N63 -> N1 (call bad40)
> takes the false branch, At N10 of Function bad40
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad40)
<Defect> : N0 -> N64: [Return edge from bad40 to main]
N0 -> N64: [Return edge from bad40 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_40.c 103] bad40 		[N0 -{Return edge from bad40 to main}-> N64]	(the heap object @H(bad40::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad44 to main}-> N71
Message  : the heap object @H(bad44::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good44, On N69 -> N39 (call good44)
> takes the true branch, At N48 of Function good44
> Leaving function: good44, On N38 -> N70 (Return edge from good44 to main)
> Entering function: bad44, On N70 -> N1 (call bad44)
> takes the false branch, At N10 of Function bad44
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad44)
<Defect> : N0 -> N71: [Return edge from bad44 to main]
N0 -> N71: [Return edge from bad44 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_44.c 102] bad44 		[N0 -{Return edge from bad44 to main}-> N71]	(the heap object @H(bad44::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad50 to main}-> N95
Message  : the heap object @H(bad50::call1) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: good50, On N93 -> N50 (call good50)
> Entering function: staticReturnsTrue, On N54 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N55 (Return edge from staticReturnsTrue to good50)
> takes the true branch, At N56 of Function good50
> takes the true branch, At N62 of Function good50
> Leaving function: good50, On N49 -> N94 (Return edge from good50 to main)
> Entering function: bad50, On N94 -> N1 (call bad50)
> Entering function: staticReturnsTrue, On N5 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N6 (Return edge from staticReturnsTrue to bad50)
> takes the true branch, At N7 of Function bad50
> takes the false branch, At N13 of Function bad50
> Entering function: printIntLine, On N21 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N23 (Return edge from printIntLine to bad50)
> Entering function: staticReturnsTrue, On N23 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N24 (Return edge from staticReturnsTrue to bad50)
> takes the true branch, At N25 of Function bad50
<Defect> : N0 -> N95: [Return edge from bad50 to main]
N0 -> N95: [Return edge from bad50 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_50.c 112] bad50 		[N0 -{Return edge from bad50 to main}-> N95]	(the heap object @H(bad50::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.144s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad10 to main}-> N86
Message  : the heap object @H(bad10::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good10, On N84 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the true branch, At N57 of Function good10
> Leaving function: good10, On N45 -> N85 (Return edge from good10 to main)
> Entering function: bad10, On N85 -> N1 (call bad10)
> takes the true branch, At N7 of Function bad10
> takes the false branch, At N12 of Function bad10
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad10)
> takes the true branch, At N21 of Function bad10
<Defect> : N0 -> N86: [Return edge from bad10 to main]
N0 -> N86: [Return edge from bad10 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_10.c 103] bad10 		[N0 -{Return edge from bad10 to main}-> N86]	(the heap object @H(bad10::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad35 to main}-> N64
Message  : the heap object @H(bad35::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good35, On N62 -> N36 (call good35)
> takes the true branch, At N45 of Function good35
> Leaving function: good35, On N35 -> N63 (Return edge from good35 to main)
> Entering function: bad35, On N63 -> N1 (call bad35)
> takes the false branch, At N10 of Function bad35
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad35)
<Defect> : N0 -> N64: [Return edge from bad35 to main]
N0 -> N64: [Return edge from bad35 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_35.c 105] bad35 		[N0 -{Return edge from bad35 to main}-> N64]	(the heap object @H(bad35::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.247s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad2 to main}-> N62
Message  : the heap object @H(bad2::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good2, On N60 -> N35 (call good2)
> takes the true branch, At N43 of Function good2
> Leaving function: good2, On N34 -> N61 (Return edge from good2 to main)
> Entering function: bad2, On N61 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad2)
<Defect> : N0 -> N62: [Return edge from bad2 to main]
N0 -> N62: [Return edge from bad2 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_2.c 102] bad2 		[N0 -{Return edge from bad2 to main}-> N62]	(the heap object @H(bad2::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad39 to main}-> N88
Message  : the heap object @H(bad39::call1) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good39, On N86 -> N47 (call good39)
> Entering function: staticReturnsTrue, On N51 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N52 (Return edge from staticReturnsTrue to good39)
> takes the true branch, At N53 of Function good39
> takes the true branch, At N59 of Function good39
> Leaving function: good39, On N46 -> N87 (Return edge from good39 to main)
> Entering function: bad39, On N87 -> N1 (call bad39)
> Entering function: staticReturnsTrue, On N5 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N6 (Return edge from staticReturnsTrue to bad39)
> takes the true branch, At N7 of Function bad39
> takes the false branch, At N13 of Function bad39
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad39)
> Entering function: staticReturnsTrue, On N20 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N21 (Return edge from staticReturnsTrue to bad39)
> takes the true branch, At N22 of Function bad39
<Defect> : N0 -> N88: [Return edge from bad39 to main]
N0 -> N88: [Return edge from bad39 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_39.c 112] bad39 		[N0 -{Return edge from bad39 to main}-> N88]	(the heap object @H(bad39::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad11 to main}-> N86
Message  : the heap object @H(bad11::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good11, On N84 -> N46 (call good11)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good11)
> takes the true branch, At N52 of Function good11
> takes the true branch, At N57 of Function good11
> Leaving function: good11, On N45 -> N85 (Return edge from good11 to main)
> Entering function: bad11, On N85 -> N1 (call bad11)
> Entering function: globalReturnsTrue, On N5 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N6 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N7 of Function bad11
> takes the false branch, At N12 of Function bad11
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad11)
> Entering function: globalReturnsTrue, On N19 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N20 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N21 of Function bad11
<Defect> : N0 -> N86: [Return edge from bad11 to main]
N0 -> N86: [Return edge from bad11 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_11.c 104] bad11 		[N0 -{Return edge from bad11 to main}-> N86]	(the heap object @H(bad11::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad37 to main}-> N64
Message  : the heap object @H(bad37::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good37, On N62 -> N36 (call good37)
> takes the true branch, At N45 of Function good37
> Leaving function: good37, On N35 -> N63 (Return edge from good37 to main)
> Entering function: bad37, On N63 -> N1 (call bad37)
> takes the false branch, At N10 of Function bad37
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad37)
<Defect> : N0 -> N64: [Return edge from bad37 to main]
N0 -> N64: [Return edge from bad37 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_37.c 104] bad37 		[N0 -{Return edge from bad37 to main}-> N64]	(the heap object @H(bad37::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad22 to main}-> N86
Message  : the heap object @H(bad22::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good22, On N84 -> N46 (call good22)
> takes the true branch, At N52 of Function good22
> takes the true branch, At N57 of Function good22
> Leaving function: good22, On N45 -> N85 (Return edge from good22 to main)
> Entering function: bad22, On N85 -> N1 (call bad22)
> takes the true branch, At N7 of Function bad22
> takes the false branch, At N12 of Function bad22
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad22)
> takes the true branch, At N21 of Function bad22
<Defect> : N0 -> N86: [Return edge from bad22 to main]
N0 -> N86: [Return edge from bad22 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_22.c 104] bad22 		[N0 -{Return edge from bad22 to main}-> N86]	(the heap object @H(bad22::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad21 to main}-> N62
Message  : the heap object @H(bad21::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good21, On N60 -> N35 (call good21)
> takes the true branch, At N43 of Function good21
> Leaving function: good21, On N34 -> N61 (Return edge from good21 to main)
> Entering function: bad21, On N61 -> N1 (call bad21)
> takes the false branch, At N9 of Function bad21
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad21)
<Defect> : N0 -> N62: [Return edge from bad21 to main]
N0 -> N62: [Return edge from bad21 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_21.c 104] bad21 		[N0 -{Return edge from bad21 to main}-> N62]	(the heap object @H(bad21::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{store i8* %0, i8** %data, align 8}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N55 of Function main
> Entering function: good1, On N58 -> N35 (call good1)
<Defect> : N40 -> N41: [store i8* %0, i8** %data, align 8]
N40 -> N41: [store i8* %0, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N74
On edge  : N74 -{store i8* %line, i8** %line.addr, align 8}-> N76
Message  : use of uninitialized variable
> Start from entry function: main, At N55 of Function main
> Entering function: good1, On N58 -> N35 (call good1)
> takes the false branch, At N43 of Function good1
> Entering function: printLine, On N48 -> N72 (call printLine)
<Defect> : N74 -> N76: [store i8* %line, i8** %line.addr, align 8]
N74 -> N76: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad1 to main}-> N60
Message  : the heap object @H(bad1::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good1, On N58 -> N35 (call good1)
> takes the false branch, At N43 of Function good1
> Entering function: printLine, On N48 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N50 (Return edge from printLine to good1)
> Leaving function: good1, On N34 -> N59 (Return edge from good1 to main)
> Entering function: bad1, On N59 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
> Entering function: printLine, On N14 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N16 (Return edge from printLine to bad1)
<Defect> : N0 -> N60: [Return edge from bad1 to main]
N0 -> N60: [Return edge from bad1 to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./401_1.c 72] good1 		[N40 -{store i8* %0, i8** %data, align 8}-> N41]	(use of uninitialized variable)
	[* 0] printLine 		[N74 -{store i8* %line, i8** %line.addr, align 8}-> N76]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_1.c 86] bad1 		[N0 -{Return edge from bad1 to main}-> N60]	(the heap object @H(bad1::call) is not referenced any more)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad8 to main}-> N86
Message  : the heap object @H(bad8::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good8, On N84 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the true branch, At N57 of Function good8
> Leaving function: good8, On N45 -> N85 (Return edge from good8 to main)
> Entering function: bad8, On N85 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N7 of Function bad8
> takes the false branch, At N12 of Function bad8
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad8)
> Entering function: staticReturnsTrue, On N19 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N20 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N21 of Function bad8
<Defect> : N0 -> N86: [Return edge from bad8 to main]
N0 -> N86: [Return edge from bad8 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_8.c 112] bad8 		[N0 -{Return edge from bad8 to main}-> N86]	(the heap object @H(bad8::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad41 to main}-> N88
Message  : the heap object @H(bad41::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good41, On N86 -> N47 (call good41)
> takes the true branch, At N53 of Function good41
> takes the true branch, At N59 of Function good41
> Leaving function: good41, On N46 -> N87 (Return edge from good41 to main)
> Entering function: bad41, On N87 -> N1 (call bad41)
> takes the true branch, At N7 of Function bad41
> takes the false branch, At N13 of Function bad41
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad41)
> takes the true branch, At N22 of Function bad41
<Defect> : N0 -> N88: [Return edge from bad41 to main]
N0 -> N88: [Return edge from bad41 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_41.c 101] bad41 		[N0 -{Return edge from bad41 to main}-> N88]	(the heap object @H(bad41::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad7 to main}-> N86
Message  : the heap object @H(bad7::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good7, On N84 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the true branch, At N57 of Function good7
> Leaving function: good7, On N45 -> N85 (Return edge from good7 to main)
> Entering function: bad7, On N85 -> N1 (call bad7)
> takes the true branch, At N7 of Function bad7
> takes the false branch, At N12 of Function bad7
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad7)
> takes the true branch, At N21 of Function bad7
<Defect> : N0 -> N86: [Return edge from bad7 to main]
N0 -> N86: [Return edge from bad7 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_7.c 105] bad7 		[N0 -{Return edge from bad7 to main}-> N86]	(the heap object @H(bad7::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N56): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N41
On edge  : N41 -{store i8* %0, i8** %data, align 8}-> N42
Message  : use of uninitialized variable
> Start from entry function: main, At N56 of Function main
> Entering function: good32, On N59 -> N36 (call good32)
<Defect> : N41 -> N42: [store i8* %0, i8** %data, align 8]
N41 -> N42: [store i8* %0, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N75
On edge  : N75 -{store i8* %line, i8** %line.addr, align 8}-> N77
Message  : use of uninitialized variable
> Start from entry function: main, At N56 of Function main
> Entering function: good32, On N59 -> N36 (call good32)
> takes the false branch, At N44 of Function good32
> Entering function: printLine, On N49 -> N73 (call printLine)
<Defect> : N75 -> N77: [store i8* %line, i8** %line.addr, align 8]
N75 -> N77: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad32 to main}-> N61
Message  : the heap object @H(bad32::call) is not referenced any more
> Start from entry function: main, At N56 of Function main
> Entering function: good32, On N59 -> N36 (call good32)
> takes the false branch, At N44 of Function good32
> Entering function: printLine, On N49 -> N73 (call printLine)
> takes the true branch, At N79 of Function printLine
> Leaving function: printLine, On N72 -> N51 (Return edge from printLine to good32)
> Leaving function: good32, On N35 -> N60 (Return edge from good32 to main)
> Entering function: bad32, On N60 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
> Entering function: printLine, On N15 -> N73 (call printLine)
> takes the true branch, At N79 of Function printLine
> Leaving function: printLine, On N72 -> N17 (Return edge from printLine to bad32)
<Defect> : N0 -> N61: [Return edge from bad32 to main]
N0 -> N61: [Return edge from bad32 to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./401_32.c 72] good32 		[N41 -{store i8* %0, i8** %data, align 8}-> N42]	(use of uninitialized variable)
	[* 0] printLine 		[N75 -{store i8* %line, i8** %line.addr, align 8}-> N77]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_32.c 85] bad32 		[N0 -{Return edge from bad32 to main}-> N61]	(the heap object @H(bad32::call) is not referenced any more)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad6 to main}-> N62
Message  : the heap object @H(bad6::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good6, On N60 -> N35 (call good6)
> takes the true branch, At N43 of Function good6
> Leaving function: good6, On N34 -> N61 (Return edge from good6 to main)
> Entering function: bad6, On N61 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad6)
<Defect> : N0 -> N62: [Return edge from bad6 to main]
N0 -> N62: [Return edge from bad6 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_6.c 105] bad6 		[N0 -{Return edge from bad6 to main}-> N62]	(the heap object @H(bad6::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad17 to main}-> N62
Message  : the heap object @H(bad17::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good17, On N60 -> N35 (call good17)
> takes the true branch, At N43 of Function good17
> Leaving function: good17, On N34 -> N61 (Return edge from good17 to main)
> Entering function: bad17, On N61 -> N1 (call bad17)
> takes the false branch, At N9 of Function bad17
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad17)
<Defect> : N0 -> N62: [Return edge from bad17 to main]
N0 -> N62: [Return edge from bad17 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_17.c 102] bad17 		[N0 -{Return edge from bad17 to main}-> N62]	(the heap object @H(bad17::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad31 to main}-> N62
Message  : the heap object @H(bad31::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good31, On N60 -> N35 (call good31)
> takes the true branch, At N43 of Function good31
> Leaving function: good31, On N34 -> N61 (Return edge from good31 to main)
> Entering function: bad31, On N61 -> N1 (call bad31)
> takes the false branch, At N9 of Function bad31
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad31)
<Defect> : N0 -> N62: [Return edge from bad31 to main]
N0 -> N62: [Return edge from bad31 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_31.c 120] bad31 		[N0 -{Return edge from bad31 to main}-> N62]	(the heap object @H(bad31::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad19 to main}-> N62
Message  : the heap object @H(bad19::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good19, On N60 -> N35 (call good19)
> takes the true branch, At N43 of Function good19
> Leaving function: good19, On N34 -> N61 (Return edge from good19 to main)
> Entering function: bad19, On N61 -> N1 (call bad19)
> takes the false branch, At N9 of Function bad19
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad19)
<Defect> : N0 -> N62: [Return edge from bad19 to main]
N0 -> N62: [Return edge from bad19 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_19.c 105] bad19 		[N0 -{Return edge from bad19 to main}-> N62]	(the heap object @H(bad19::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad49 to main}-> N95
Message  : the heap object @H(bad49::call) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: good49, On N93 -> N50 (call good49)
> takes the true branch, At N56 of Function good49
> takes the true branch, At N62 of Function good49
> Leaving function: good49, On N49 -> N94 (Return edge from good49 to main)
> Entering function: bad49, On N94 -> N1 (call bad49)
> takes the true branch, At N7 of Function bad49
> takes the false branch, At N13 of Function bad49
> Entering function: printIntLine, On N21 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N23 (Return edge from printIntLine to bad49)
> takes the true branch, At N25 of Function bad49
<Defect> : N0 -> N95: [Return edge from bad49 to main]
N0 -> N95: [Return edge from bad49 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_49.c 104] bad49 		[N0 -{Return edge from bad49 to main}-> N95]	(the heap object @H(bad49::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad16 to main}-> N60
Message  : the heap object @H(bad16::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good16, On N58 -> N35 (call good16)
> takes the false branch, At N43 of Function good16
> Entering function: printLine, On N48 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N50 (Return edge from printLine to good16)
> Leaving function: good16, On N34 -> N59 (Return edge from good16 to main)
> Entering function: bad16, On N59 -> N1 (call bad16)
> takes the false branch, At N9 of Function bad16
> Entering function: printLine, On N14 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N16 (Return edge from printLine to bad16)
<Defect> : N0 -> N60: [Return edge from bad16 to main]
N0 -> N60: [Return edge from bad16 to main] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{store i8* %0, i8** %data, align 8}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N55 of Function main
> Entering function: good16, On N58 -> N35 (call good16)
<Defect> : N40 -> N41: [store i8* %0, i8** %data, align 8]
N40 -> N41: [store i8* %0, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N74
On edge  : N74 -{store i8* %line, i8** %line.addr, align 8}-> N76
Message  : use of uninitialized variable
> Start from entry function: main, At N55 of Function main
> Entering function: good16, On N58 -> N35 (call good16)
> takes the false branch, At N43 of Function good16
> Entering function: printLine, On N48 -> N72 (call printLine)
<Defect> : N74 -> N76: [store i8* %line, i8** %line.addr, align 8]
N74 -> N76: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_16.c 87] bad16 		[N0 -{Return edge from bad16 to main}-> N60]	(the heap object @H(bad16::call) is not referenced any more)

CWE_457(Use of Uninitialized Variable): 2
	[./401_16.c 72] good16 		[N40 -{store i8* %0, i8** %data, align 8}-> N41]	(use of uninitialized variable)
	[* 0] printLine 		[N74 -{store i8* %line, i8** %line.addr, align 8}-> N76]	(use of uninitialized variable)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad20 to main}-> N86
Message  : the heap object @H(bad20::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good20, On N84 -> N46 (call good20)
> takes the true branch, At N52 of Function good20
> takes the true branch, At N57 of Function good20
> Leaving function: good20, On N45 -> N85 (Return edge from good20 to main)
> Entering function: bad20, On N85 -> N1 (call bad20)
> takes the true branch, At N7 of Function bad20
> takes the false branch, At N12 of Function bad20
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad20)
> takes the true branch, At N21 of Function bad20
<Defect> : N0 -> N86: [Return edge from bad20 to main]
N0 -> N86: [Return edge from bad20 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_20.c 104] bad20 		[N0 -{Return edge from bad20 to main}-> N86]	(the heap object @H(bad20::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.225s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad45 to main}-> N71
Message  : the heap object @H(bad45::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good45, On N69 -> N39 (call good45)
> takes the true branch, At N48 of Function good45
> Leaving function: good45, On N38 -> N70 (Return edge from good45 to main)
> Entering function: bad45, On N70 -> N1 (call bad45)
> takes the false branch, At N10 of Function bad45
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad45)
<Defect> : N0 -> N71: [Return edge from bad45 to main]
N0 -> N71: [Return edge from bad45 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_45.c 102] bad45 		[N0 -{Return edge from bad45 to main}-> N71]	(the heap object @H(bad45::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.123s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad27 to main}-> N86
Message  : the heap object @H(bad27::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good27, On N84 -> N46 (call good27)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good27)
> takes the true branch, At N52 of Function good27
> takes the true branch, At N57 of Function good27
> Leaving function: good27, On N45 -> N85 (Return edge from good27 to main)
> Entering function: bad27, On N85 -> N1 (call bad27)
> Entering function: globalReturnsTrue, On N5 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N6 (Return edge from globalReturnsTrue to bad27)
> takes the true branch, At N7 of Function bad27
> takes the false branch, At N12 of Function bad27
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad27)
> Entering function: globalReturnsTrue, On N19 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N20 (Return edge from globalReturnsTrue to bad27)
> takes the true branch, At N21 of Function bad27
<Defect> : N0 -> N86: [Return edge from bad27 to main]
N0 -> N86: [Return edge from bad27 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_27.c 102] bad27 		[N0 -{Return edge from bad27 to main}-> N86]	(the heap object @H(bad27::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.141s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad36 to main}-> N88
Message  : the heap object @H(bad36::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good36, On N86 -> N47 (call good36)
> takes the true branch, At N53 of Function good36
> takes the true branch, At N59 of Function good36
> Leaving function: good36, On N46 -> N87 (Return edge from good36 to main)
> Entering function: bad36, On N87 -> N1 (call bad36)
> takes the true branch, At N7 of Function bad36
> takes the false branch, At N13 of Function bad36
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad36)
> takes the true branch, At N22 of Function bad36
<Defect> : N0 -> N88: [Return edge from bad36 to main]
N0 -> N88: [Return edge from bad36 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_36.c 106] bad36 		[N0 -{Return edge from bad36 to main}-> N88]	(the heap object @H(bad36::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.141s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N111): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad28 to main}-> N116
Message  : the heap object @H(bad28::call1) is not referenced any more
> Start from entry function: main, At N111 of Function main
> Entering function: good28, On N114 -> N62 (call good28)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good28)
> takes the false branch, At N68 of Function good28
> takes the true branch, At N84 of Function good28
> Leaving function: good28, On N61 -> N115 (Return edge from good28 to main)
> Entering function: bad28, On N115 -> N1 (call bad28)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the true branch, At N7 of Function bad28
> takes the false branch, At N12 of Function bad28
> Entering function: printLine, On N17 -> N128 (call printLine)
> takes the true branch, At N134 of Function printLine
> Leaving function: printLine, On N127 -> N30 (Return edge from printLine to bad28)
> Entering function: globalReturnsTrueOrFalse, On N30 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N31 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the true branch, At N32 of Function bad28
<Defect> : N0 -> N116: [Return edge from bad28 to main]
N0 -> N116: [Return edge from bad28 to main] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N20
On edge  : N20 -{store i8* %3, i8** %data, align 8}-> N21
Message  : use of uninitialized variable
> Start from entry function: main, At N111 of Function main
> Entering function: good28, On N114 -> N62 (call good28)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good28)
> takes the false branch, At N68 of Function good28
> takes the true branch, At N84 of Function good28
> Leaving function: good28, On N61 -> N115 (Return edge from good28 to main)
> Entering function: bad28, On N115 -> N1 (call bad28)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the false branch, At N7 of Function bad28
<Defect> : N20 -> N21: [store i8* %3, i8** %data, align 8]
N20 -> N21: [store i8* %3, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N130
On edge  : N130 -{store i8* %line, i8** %line.addr, align 8}-> N132
Message  : use of uninitialized variable
> Start from entry function: main, At N111 of Function main
> Entering function: good28, On N114 -> N62 (call good28)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good28)
> takes the false branch, At N68 of Function good28
> takes the true branch, At N84 of Function good28
> Leaving function: good28, On N61 -> N115 (Return edge from good28 to main)
> Entering function: bad28, On N115 -> N1 (call bad28)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the false branch, At N7 of Function bad28
> takes the false branch, At N23 of Function bad28
> Entering function: printLine, On N28 -> N128 (call printLine)
<Defect> : N130 -> N132: [store i8* %line, i8** %line.addr, align 8]
N130 -> N132: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_28.c 123] bad28 		[N0 -{Return edge from bad28 to main}-> N116]	(the heap object @H(bad28::call1) is not referenced any more)

CWE_457(Use of Uninitialized Variable): 2
	[./401_28.c 65] bad28 		[N20 -{store i8* %3, i8** %data, align 8}-> N21]	(use of uninitialized variable)
	[* 0] printLine 		[N130 -{store i8* %line, i8** %line.addr, align 8}-> N132]	(use of uninitialized variable)

Found 3 defects in all (4 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad9 to main}-> N62
Message  : the heap object @H(bad9::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good9, On N60 -> N35 (call good9)
> takes the true branch, At N43 of Function good9
> Leaving function: good9, On N34 -> N61 (Return edge from good9 to main)
> Entering function: bad9, On N61 -> N1 (call bad9)
> takes the false branch, At N9 of Function bad9
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad9)
<Defect> : N0 -> N62: [Return edge from bad9 to main]
N0 -> N62: [Return edge from bad9 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_9.c 102] bad9 		[N0 -{Return edge from bad9 to main}-> N62]	(the heap object @H(bad9::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad43 to main}-> N68
Message  : the heap object @H(bad43::call) is not referenced any more
> Start from entry function: main, At N63 of Function main
> Entering function: good43, On N66 -> N39 (call good43)
> takes the false branch, At N48 of Function good43
> Entering function: printIntLine, On N56 -> N71 (call printIntLine)
> Leaving function: printIntLine, On N70 -> N58 (Return edge from printIntLine to good43)
> Leaving function: good43, On N38 -> N67 (Return edge from good43 to main)
> Entering function: bad43, On N67 -> N1 (call bad43)
> takes the false branch, At N10 of Function bad43
> Entering function: printIntLine, On N18 -> N71 (call printIntLine)
> Leaving function: printIntLine, On N70 -> N20 (Return edge from printIntLine to bad43)
<Defect> : N0 -> N68: [Return edge from bad43 to main]
N0 -> N68: [Return edge from bad43 to main] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N45
On edge  : N45 -{store i32* %1, i32** %data, align 8}-> N46
Message  : use of uninitialized variable
> Start from entry function: main, At N63 of Function main
> Entering function: good43, On N66 -> N39 (call good43)
<Defect> : N45 -> N46: [store i32* %1, i32** %data, align 8]
N45 -> N46: [store i32* %1, i32** %data, align 8] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_43.c 84] bad43 		[N0 -{Return edge from bad43 to main}-> N68]	(the heap object @H(bad43::call) is not referenced any more)

CWE_457(Use of Uninitialized Variable): 1
	[./401_43.c 71] good43 		[N45 -{store i32* %1, i32** %data, align 8}-> N46]	(use of uninitialized variable)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.088s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad4 to main}-> N62
Message  : the heap object @H(bad4::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good4, On N60 -> N35 (call good4)
> takes the true branch, At N43 of Function good4
> Leaving function: good4, On N34 -> N61 (Return edge from good4 to main)
> Entering function: bad4, On N61 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad4)
<Defect> : N0 -> N62: [Return edge from bad4 to main]
N0 -> N62: [Return edge from bad4 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_4.c 106] bad4 		[N0 -{Return edge from bad4 to main}-> N62]	(the heap object @H(bad4::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad48 to main}-> N71
Message  : the heap object @H(bad48::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good48, On N69 -> N39 (call good48)
> takes the true branch, At N48 of Function good48
> Leaving function: good48, On N38 -> N70 (Return edge from good48 to main)
> Entering function: bad48, On N70 -> N1 (call bad48)
> takes the false branch, At N10 of Function bad48
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad48)
<Defect> : N0 -> N71: [Return edge from bad48 to main]
N0 -> N71: [Return edge from bad48 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_48.c 103] bad48 		[N0 -{Return edge from bad48 to main}-> N71]	(the heap object @H(bad48::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.093s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad15 to main}-> N62
Message  : the heap object @H(bad15::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good15, On N60 -> N35 (call good15)
> takes the true branch, At N43 of Function good15
> Leaving function: good15, On N34 -> N61 (Return edge from good15 to main)
> Entering function: bad15, On N61 -> N1 (call bad15)
> takes the false branch, At N9 of Function bad15
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad15)
<Defect> : N0 -> N62: [Return edge from bad15 to main]
N0 -> N62: [Return edge from bad15 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_15.c 123] bad15 		[N0 -{Return edge from bad15 to main}-> N62]	(the heap object @H(bad15::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad13 to main}-> N62
Message  : the heap object @H(bad13::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good13, On N60 -> N35 (call good13)
> takes the true branch, At N43 of Function good13
> Leaving function: good13, On N34 -> N61 (Return edge from good13 to main)
> Entering function: bad13, On N61 -> N1 (call bad13)
> takes the false branch, At N9 of Function bad13
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad13)
<Defect> : N0 -> N62: [Return edge from bad13 to main]
N0 -> N62: [Return edge from bad13 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_13.c 104] bad13 		[N0 -{Return edge from bad13 to main}-> N62]	(the heap object @H(bad13::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad25 to main}-> N62
Message  : the heap object @H(bad25::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good25, On N60 -> N35 (call good25)
> takes the true branch, At N43 of Function good25
> Leaving function: good25, On N34 -> N61 (Return edge from good25 to main)
> Entering function: bad25, On N61 -> N1 (call bad25)
> takes the false branch, At N9 of Function bad25
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad25)
<Defect> : N0 -> N62: [Return edge from bad25 to main]
N0 -> N62: [Return edge from bad25 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_25.c 102] bad25 		[N0 -{Return edge from bad25 to main}-> N62]	(the heap object @H(bad25::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad42 to main}-> N88
Message  : the heap object @H(bad42::call1) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good42, On N86 -> N47 (call good42)
> Entering function: globalReturnsTrue, On N51 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N52 (Return edge from globalReturnsTrue to good42)
> takes the true branch, At N53 of Function good42
> takes the true branch, At N59 of Function good42
> Leaving function: good42, On N46 -> N87 (Return edge from good42 to main)
> Entering function: bad42, On N87 -> N1 (call bad42)
> Entering function: globalReturnsTrue, On N5 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N6 (Return edge from globalReturnsTrue to bad42)
> takes the true branch, At N7 of Function bad42
> takes the false branch, At N13 of Function bad42
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad42)
> Entering function: globalReturnsTrue, On N20 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N21 (Return edge from globalReturnsTrue to bad42)
> takes the true branch, At N22 of Function bad42
<Defect> : N0 -> N88: [Return edge from bad42 to main]
N0 -> N88: [Return edge from bad42 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_42.c 102] bad42 		[N0 -{Return edge from bad42 to main}-> N88]	(the heap object @H(bad42::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.14s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad23 to main}-> N86
Message  : the heap object @H(bad23::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good23, On N84 -> N46 (call good23)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good23)
> takes the true branch, At N52 of Function good23
> takes the true branch, At N57 of Function good23
> Leaving function: good23, On N45 -> N85 (Return edge from good23 to main)
> Entering function: bad23, On N85 -> N1 (call bad23)
> Entering function: staticReturnsTrue, On N5 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N6 (Return edge from staticReturnsTrue to bad23)
> takes the true branch, At N7 of Function bad23
> takes the false branch, At N12 of Function bad23
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad23)
> Entering function: staticReturnsTrue, On N19 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N20 (Return edge from staticReturnsTrue to bad23)
> takes the true branch, At N21 of Function bad23
<Defect> : N0 -> N86: [Return edge from bad23 to main]
N0 -> N86: [Return edge from bad23 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_23.c 112] bad23 		[N0 -{Return edge from bad23 to main}-> N86]	(the heap object @H(bad23::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad46 to main}-> N71
Message  : the heap object @H(bad46::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good46, On N69 -> N39 (call good46)
> takes the true branch, At N48 of Function good46
> Leaving function: good46, On N38 -> N70 (Return edge from good46 to main)
> Entering function: bad46, On N70 -> N1 (call bad46)
> takes the false branch, At N10 of Function bad46
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad46)
<Defect> : N0 -> N71: [Return edge from bad46 to main]
N0 -> N71: [Return edge from bad46 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_46.c 105] bad46 		[N0 -{Return edge from bad46 to main}-> N71]	(the heap object @H(bad46::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad30 to main}-> N86
Message  : the heap object @H(bad30::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good30, On N84 -> N46 (call good30)
> takes the true branch, At N52 of Function good30
> takes the true branch, At N57 of Function good30
> Leaving function: good30, On N45 -> N85 (Return edge from good30 to main)
> Entering function: bad30, On N85 -> N1 (call bad30)
> takes the true branch, At N7 of Function bad30
> takes the false branch, At N12 of Function bad30
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad30)
> takes the true branch, At N21 of Function bad30
<Defect> : N0 -> N86: [Return edge from bad30 to main]
N0 -> N86: [Return edge from bad30 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_30.c 102] bad30 		[N0 -{Return edge from bad30 to main}-> N86]	(the heap object @H(bad30::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad40 to main}-> N64
Message  : the heap object @H(bad40::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good40, On N62 -> N36 (call good40)
> takes the true branch, At N45 of Function good40
> Leaving function: good40, On N35 -> N63 (Return edge from good40 to main)
> Entering function: bad40, On N63 -> N1 (call bad40)
> takes the false branch, At N10 of Function bad40
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad40)
<Defect> : N0 -> N64: [Return edge from bad40 to main]
N0 -> N64: [Return edge from bad40 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_40.c 103] bad40 		[N0 -{Return edge from bad40 to main}-> N64]	(the heap object @H(bad40::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad44 to main}-> N71
Message  : the heap object @H(bad44::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good44, On N69 -> N39 (call good44)
> takes the true branch, At N48 of Function good44
> Leaving function: good44, On N38 -> N70 (Return edge from good44 to main)
> Entering function: bad44, On N70 -> N1 (call bad44)
> takes the false branch, At N10 of Function bad44
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad44)
<Defect> : N0 -> N71: [Return edge from bad44 to main]
N0 -> N71: [Return edge from bad44 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_44.c 102] bad44 		[N0 -{Return edge from bad44 to main}-> N71]	(the heap object @H(bad44::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad50 to main}-> N95
Message  : the heap object @H(bad50::call1) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: good50, On N93 -> N50 (call good50)
> Entering function: staticReturnsTrue, On N54 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N55 (Return edge from staticReturnsTrue to good50)
> takes the true branch, At N56 of Function good50
> takes the true branch, At N62 of Function good50
> Leaving function: good50, On N49 -> N94 (Return edge from good50 to main)
> Entering function: bad50, On N94 -> N1 (call bad50)
> Entering function: staticReturnsTrue, On N5 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N6 (Return edge from staticReturnsTrue to bad50)
> takes the true branch, At N7 of Function bad50
> takes the false branch, At N13 of Function bad50
> Entering function: printIntLine, On N21 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N23 (Return edge from printIntLine to bad50)
> Entering function: staticReturnsTrue, On N23 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N24 (Return edge from staticReturnsTrue to bad50)
> takes the true branch, At N25 of Function bad50
<Defect> : N0 -> N95: [Return edge from bad50 to main]
N0 -> N95: [Return edge from bad50 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_50.c 112] bad50 		[N0 -{Return edge from bad50 to main}-> N95]	(the heap object @H(bad50::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad10 to main}-> N86
Message  : the heap object @H(bad10::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good10, On N84 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the true branch, At N57 of Function good10
> Leaving function: good10, On N45 -> N85 (Return edge from good10 to main)
> Entering function: bad10, On N85 -> N1 (call bad10)
> takes the true branch, At N7 of Function bad10
> takes the false branch, At N12 of Function bad10
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad10)
> takes the true branch, At N21 of Function bad10
<Defect> : N0 -> N86: [Return edge from bad10 to main]
N0 -> N86: [Return edge from bad10 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_10.c 103] bad10 		[N0 -{Return edge from bad10 to main}-> N86]	(the heap object @H(bad10::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad35 to main}-> N64
Message  : the heap object @H(bad35::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good35, On N62 -> N36 (call good35)
> takes the true branch, At N45 of Function good35
> Leaving function: good35, On N35 -> N63 (Return edge from good35 to main)
> Entering function: bad35, On N63 -> N1 (call bad35)
> takes the false branch, At N10 of Function bad35
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad35)
<Defect> : N0 -> N64: [Return edge from bad35 to main]
N0 -> N64: [Return edge from bad35 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_35.c 105] bad35 		[N0 -{Return edge from bad35 to main}-> N64]	(the heap object @H(bad35::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad2 to main}-> N62
Message  : the heap object @H(bad2::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good2, On N60 -> N35 (call good2)
> takes the true branch, At N43 of Function good2
> Leaving function: good2, On N34 -> N61 (Return edge from good2 to main)
> Entering function: bad2, On N61 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad2)
<Defect> : N0 -> N62: [Return edge from bad2 to main]
N0 -> N62: [Return edge from bad2 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_2.c 102] bad2 		[N0 -{Return edge from bad2 to main}-> N62]	(the heap object @H(bad2::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad39 to main}-> N88
Message  : the heap object @H(bad39::call1) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good39, On N86 -> N47 (call good39)
> Entering function: staticReturnsTrue, On N51 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N52 (Return edge from staticReturnsTrue to good39)
> takes the true branch, At N53 of Function good39
> takes the true branch, At N59 of Function good39
> Leaving function: good39, On N46 -> N87 (Return edge from good39 to main)
> Entering function: bad39, On N87 -> N1 (call bad39)
> Entering function: staticReturnsTrue, On N5 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N6 (Return edge from staticReturnsTrue to bad39)
> takes the true branch, At N7 of Function bad39
> takes the false branch, At N13 of Function bad39
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad39)
> Entering function: staticReturnsTrue, On N20 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N21 (Return edge from staticReturnsTrue to bad39)
> takes the true branch, At N22 of Function bad39
<Defect> : N0 -> N88: [Return edge from bad39 to main]
N0 -> N88: [Return edge from bad39 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_39.c 112] bad39 		[N0 -{Return edge from bad39 to main}-> N88]	(the heap object @H(bad39::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad11 to main}-> N86
Message  : the heap object @H(bad11::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good11, On N84 -> N46 (call good11)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good11)
> takes the true branch, At N52 of Function good11
> takes the true branch, At N57 of Function good11
> Leaving function: good11, On N45 -> N85 (Return edge from good11 to main)
> Entering function: bad11, On N85 -> N1 (call bad11)
> Entering function: globalReturnsTrue, On N5 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N6 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N7 of Function bad11
> takes the false branch, At N12 of Function bad11
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad11)
> Entering function: globalReturnsTrue, On N19 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N20 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N21 of Function bad11
<Defect> : N0 -> N86: [Return edge from bad11 to main]
N0 -> N86: [Return edge from bad11 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_11.c 104] bad11 		[N0 -{Return edge from bad11 to main}-> N86]	(the heap object @H(bad11::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad37 to main}-> N64
Message  : the heap object @H(bad37::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good37, On N62 -> N36 (call good37)
> takes the true branch, At N45 of Function good37
> Leaving function: good37, On N35 -> N63 (Return edge from good37 to main)
> Entering function: bad37, On N63 -> N1 (call bad37)
> takes the false branch, At N10 of Function bad37
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad37)
<Defect> : N0 -> N64: [Return edge from bad37 to main]
N0 -> N64: [Return edge from bad37 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_37.c 104] bad37 		[N0 -{Return edge from bad37 to main}-> N64]	(the heap object @H(bad37::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad22 to main}-> N86
Message  : the heap object @H(bad22::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good22, On N84 -> N46 (call good22)
> takes the true branch, At N52 of Function good22
> takes the true branch, At N57 of Function good22
> Leaving function: good22, On N45 -> N85 (Return edge from good22 to main)
> Entering function: bad22, On N85 -> N1 (call bad22)
> takes the true branch, At N7 of Function bad22
> takes the false branch, At N12 of Function bad22
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad22)
> takes the true branch, At N21 of Function bad22
<Defect> : N0 -> N86: [Return edge from bad22 to main]
N0 -> N86: [Return edge from bad22 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_22.c 104] bad22 		[N0 -{Return edge from bad22 to main}-> N86]	(the heap object @H(bad22::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad21 to main}-> N62
Message  : the heap object @H(bad21::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good21, On N60 -> N35 (call good21)
> takes the true branch, At N43 of Function good21
> Leaving function: good21, On N34 -> N61 (Return edge from good21 to main)
> Entering function: bad21, On N61 -> N1 (call bad21)
> takes the false branch, At N9 of Function bad21
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad21)
<Defect> : N0 -> N62: [Return edge from bad21 to main]
N0 -> N62: [Return edge from bad21 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_21.c 104] bad21 		[N0 -{Return edge from bad21 to main}-> N62]	(the heap object @H(bad21::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.093s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{store i8* %0, i8** %data, align 8}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N55 of Function main
> Entering function: good1, On N58 -> N35 (call good1)
<Defect> : N40 -> N41: [store i8* %0, i8** %data, align 8]
N40 -> N41: [store i8* %0, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N74
On edge  : N74 -{store i8* %line, i8** %line.addr, align 8}-> N76
Message  : use of uninitialized variable
> Start from entry function: main, At N55 of Function main
> Entering function: good1, On N58 -> N35 (call good1)
> takes the false branch, At N43 of Function good1
> Entering function: printLine, On N48 -> N72 (call printLine)
<Defect> : N74 -> N76: [store i8* %line, i8** %line.addr, align 8]
N74 -> N76: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad1 to main}-> N60
Message  : the heap object @H(bad1::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good1, On N58 -> N35 (call good1)
> takes the false branch, At N43 of Function good1
> Entering function: printLine, On N48 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N50 (Return edge from printLine to good1)
> Leaving function: good1, On N34 -> N59 (Return edge from good1 to main)
> Entering function: bad1, On N59 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
> Entering function: printLine, On N14 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N16 (Return edge from printLine to bad1)
<Defect> : N0 -> N60: [Return edge from bad1 to main]
N0 -> N60: [Return edge from bad1 to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./401_1.c 72] good1 		[N40 -{store i8* %0, i8** %data, align 8}-> N41]	(use of uninitialized variable)
	[* 0] printLine 		[N74 -{store i8* %line, i8** %line.addr, align 8}-> N76]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_1.c 86] bad1 		[N0 -{Return edge from bad1 to main}-> N60]	(the heap object @H(bad1::call) is not referenced any more)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad8 to main}-> N86
Message  : the heap object @H(bad8::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good8, On N84 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the true branch, At N57 of Function good8
> Leaving function: good8, On N45 -> N85 (Return edge from good8 to main)
> Entering function: bad8, On N85 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N7 of Function bad8
> takes the false branch, At N12 of Function bad8
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad8)
> Entering function: staticReturnsTrue, On N19 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N20 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N21 of Function bad8
<Defect> : N0 -> N86: [Return edge from bad8 to main]
N0 -> N86: [Return edge from bad8 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_8.c 112] bad8 		[N0 -{Return edge from bad8 to main}-> N86]	(the heap object @H(bad8::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad41 to main}-> N88
Message  : the heap object @H(bad41::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good41, On N86 -> N47 (call good41)
> takes the true branch, At N53 of Function good41
> takes the true branch, At N59 of Function good41
> Leaving function: good41, On N46 -> N87 (Return edge from good41 to main)
> Entering function: bad41, On N87 -> N1 (call bad41)
> takes the true branch, At N7 of Function bad41
> takes the false branch, At N13 of Function bad41
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad41)
> takes the true branch, At N22 of Function bad41
<Defect> : N0 -> N88: [Return edge from bad41 to main]
N0 -> N88: [Return edge from bad41 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_41.c 101] bad41 		[N0 -{Return edge from bad41 to main}-> N88]	(the heap object @H(bad41::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad7 to main}-> N86
Message  : the heap object @H(bad7::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good7, On N84 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the true branch, At N57 of Function good7
> Leaving function: good7, On N45 -> N85 (Return edge from good7 to main)
> Entering function: bad7, On N85 -> N1 (call bad7)
> takes the true branch, At N7 of Function bad7
> takes the false branch, At N12 of Function bad7
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad7)
> takes the true branch, At N21 of Function bad7
<Defect> : N0 -> N86: [Return edge from bad7 to main]
N0 -> N86: [Return edge from bad7 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_7.c 105] bad7 		[N0 -{Return edge from bad7 to main}-> N86]	(the heap object @H(bad7::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.098s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N56): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N41
On edge  : N41 -{store i8* %0, i8** %data, align 8}-> N42
Message  : use of uninitialized variable
> Start from entry function: main, At N56 of Function main
> Entering function: good32, On N59 -> N36 (call good32)
<Defect> : N41 -> N42: [store i8* %0, i8** %data, align 8]
N41 -> N42: [store i8* %0, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N75
On edge  : N75 -{store i8* %line, i8** %line.addr, align 8}-> N77
Message  : use of uninitialized variable
> Start from entry function: main, At N56 of Function main
> Entering function: good32, On N59 -> N36 (call good32)
> takes the false branch, At N44 of Function good32
> Entering function: printLine, On N49 -> N73 (call printLine)
<Defect> : N75 -> N77: [store i8* %line, i8** %line.addr, align 8]
N75 -> N77: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad32 to main}-> N61
Message  : the heap object @H(bad32::call) is not referenced any more
> Start from entry function: main, At N56 of Function main
> Entering function: good32, On N59 -> N36 (call good32)
> takes the false branch, At N44 of Function good32
> Entering function: printLine, On N49 -> N73 (call printLine)
> takes the true branch, At N79 of Function printLine
> Leaving function: printLine, On N72 -> N51 (Return edge from printLine to good32)
> Leaving function: good32, On N35 -> N60 (Return edge from good32 to main)
> Entering function: bad32, On N60 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
> Entering function: printLine, On N15 -> N73 (call printLine)
> takes the true branch, At N79 of Function printLine
> Leaving function: printLine, On N72 -> N17 (Return edge from printLine to bad32)
<Defect> : N0 -> N61: [Return edge from bad32 to main]
N0 -> N61: [Return edge from bad32 to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./401_32.c 72] good32 		[N41 -{store i8* %0, i8** %data, align 8}-> N42]	(use of uninitialized variable)
	[* 0] printLine 		[N75 -{store i8* %line, i8** %line.addr, align 8}-> N77]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_32.c 85] bad32 		[N0 -{Return edge from bad32 to main}-> N61]	(the heap object @H(bad32::call) is not referenced any more)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad6 to main}-> N62
Message  : the heap object @H(bad6::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good6, On N60 -> N35 (call good6)
> takes the true branch, At N43 of Function good6
> Leaving function: good6, On N34 -> N61 (Return edge from good6 to main)
> Entering function: bad6, On N61 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad6)
<Defect> : N0 -> N62: [Return edge from bad6 to main]
N0 -> N62: [Return edge from bad6 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_6.c 105] bad6 		[N0 -{Return edge from bad6 to main}-> N62]	(the heap object @H(bad6::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad17 to main}-> N62
Message  : the heap object @H(bad17::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good17, On N60 -> N35 (call good17)
> takes the true branch, At N43 of Function good17
> Leaving function: good17, On N34 -> N61 (Return edge from good17 to main)
> Entering function: bad17, On N61 -> N1 (call bad17)
> takes the false branch, At N9 of Function bad17
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad17)
<Defect> : N0 -> N62: [Return edge from bad17 to main]
N0 -> N62: [Return edge from bad17 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_17.c 102] bad17 		[N0 -{Return edge from bad17 to main}-> N62]	(the heap object @H(bad17::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.138s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad31 to main}-> N62
Message  : the heap object @H(bad31::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good31, On N60 -> N35 (call good31)
> takes the true branch, At N43 of Function good31
> Leaving function: good31, On N34 -> N61 (Return edge from good31 to main)
> Entering function: bad31, On N61 -> N1 (call bad31)
> takes the false branch, At N9 of Function bad31
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad31)
<Defect> : N0 -> N62: [Return edge from bad31 to main]
N0 -> N62: [Return edge from bad31 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_31.c 120] bad31 		[N0 -{Return edge from bad31 to main}-> N62]	(the heap object @H(bad31::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad19 to main}-> N62
Message  : the heap object @H(bad19::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good19, On N60 -> N35 (call good19)
> takes the true branch, At N43 of Function good19
> Leaving function: good19, On N34 -> N61 (Return edge from good19 to main)
> Entering function: bad19, On N61 -> N1 (call bad19)
> takes the false branch, At N9 of Function bad19
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad19)
<Defect> : N0 -> N62: [Return edge from bad19 to main]
N0 -> N62: [Return edge from bad19 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_19.c 105] bad19 		[N0 -{Return edge from bad19 to main}-> N62]	(the heap object @H(bad19::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad49 to main}-> N95
Message  : the heap object @H(bad49::call) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: good49, On N93 -> N50 (call good49)
> takes the true branch, At N56 of Function good49
> takes the true branch, At N62 of Function good49
> Leaving function: good49, On N49 -> N94 (Return edge from good49 to main)
> Entering function: bad49, On N94 -> N1 (call bad49)
> takes the true branch, At N7 of Function bad49
> takes the false branch, At N13 of Function bad49
> Entering function: printIntLine, On N21 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N23 (Return edge from printIntLine to bad49)
> takes the true branch, At N25 of Function bad49
<Defect> : N0 -> N95: [Return edge from bad49 to main]
N0 -> N95: [Return edge from bad49 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_49.c 104] bad49 		[N0 -{Return edge from bad49 to main}-> N95]	(the heap object @H(bad49::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{store i8* %0, i8** %data, align 8}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N55 of Function main
> Entering function: good16, On N58 -> N35 (call good16)
<Defect> : N40 -> N41: [store i8* %0, i8** %data, align 8]
N40 -> N41: [store i8* %0, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N74
On edge  : N74 -{store i8* %line, i8** %line.addr, align 8}-> N76
Message  : use of uninitialized variable
> Start from entry function: main, At N55 of Function main
> Entering function: good16, On N58 -> N35 (call good16)
> takes the false branch, At N43 of Function good16
> Entering function: printLine, On N48 -> N72 (call printLine)
<Defect> : N74 -> N76: [store i8* %line, i8** %line.addr, align 8]
N74 -> N76: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad16 to main}-> N60
Message  : the heap object @H(bad16::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good16, On N58 -> N35 (call good16)
> takes the false branch, At N43 of Function good16
> Entering function: printLine, On N48 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N50 (Return edge from printLine to good16)
> Leaving function: good16, On N34 -> N59 (Return edge from good16 to main)
> Entering function: bad16, On N59 -> N1 (call bad16)
> takes the false branch, At N9 of Function bad16
> Entering function: printLine, On N14 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N16 (Return edge from printLine to bad16)
<Defect> : N0 -> N60: [Return edge from bad16 to main]
N0 -> N60: [Return edge from bad16 to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./401_16.c 72] good16 		[N40 -{store i8* %0, i8** %data, align 8}-> N41]	(use of uninitialized variable)
	[* 0] printLine 		[N74 -{store i8* %line, i8** %line.addr, align 8}-> N76]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_16.c 87] bad16 		[N0 -{Return edge from bad16 to main}-> N60]	(the heap object @H(bad16::call) is not referenced any more)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad20 to main}-> N86
Message  : the heap object @H(bad20::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good20, On N84 -> N46 (call good20)
> takes the true branch, At N52 of Function good20
> takes the true branch, At N57 of Function good20
> Leaving function: good20, On N45 -> N85 (Return edge from good20 to main)
> Entering function: bad20, On N85 -> N1 (call bad20)
> takes the true branch, At N7 of Function bad20
> takes the false branch, At N12 of Function bad20
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad20)
> takes the true branch, At N21 of Function bad20
<Defect> : N0 -> N86: [Return edge from bad20 to main]
N0 -> N86: [Return edge from bad20 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_20.c 104] bad20 		[N0 -{Return edge from bad20 to main}-> N86]	(the heap object @H(bad20::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad45 to main}-> N71
Message  : the heap object @H(bad45::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good45, On N69 -> N39 (call good45)
> takes the true branch, At N48 of Function good45
> Leaving function: good45, On N38 -> N70 (Return edge from good45 to main)
> Entering function: bad45, On N70 -> N1 (call bad45)
> takes the false branch, At N10 of Function bad45
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad45)
<Defect> : N0 -> N71: [Return edge from bad45 to main]
N0 -> N71: [Return edge from bad45 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_45.c 102] bad45 		[N0 -{Return edge from bad45 to main}-> N71]	(the heap object @H(bad45::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad27 to main}-> N86
Message  : the heap object @H(bad27::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good27, On N84 -> N46 (call good27)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good27)
> takes the true branch, At N52 of Function good27
> takes the true branch, At N57 of Function good27
> Leaving function: good27, On N45 -> N85 (Return edge from good27 to main)
> Entering function: bad27, On N85 -> N1 (call bad27)
> Entering function: globalReturnsTrue, On N5 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N6 (Return edge from globalReturnsTrue to bad27)
> takes the true branch, At N7 of Function bad27
> takes the false branch, At N12 of Function bad27
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad27)
> Entering function: globalReturnsTrue, On N19 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N20 (Return edge from globalReturnsTrue to bad27)
> takes the true branch, At N21 of Function bad27
<Defect> : N0 -> N86: [Return edge from bad27 to main]
N0 -> N86: [Return edge from bad27 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_27.c 102] bad27 		[N0 -{Return edge from bad27 to main}-> N86]	(the heap object @H(bad27::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad36 to main}-> N88
Message  : the heap object @H(bad36::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good36, On N86 -> N47 (call good36)
> takes the true branch, At N53 of Function good36
> takes the true branch, At N59 of Function good36
> Leaving function: good36, On N46 -> N87 (Return edge from good36 to main)
> Entering function: bad36, On N87 -> N1 (call bad36)
> takes the true branch, At N7 of Function bad36
> takes the false branch, At N13 of Function bad36
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad36)
> takes the true branch, At N22 of Function bad36
<Defect> : N0 -> N88: [Return edge from bad36 to main]
N0 -> N88: [Return edge from bad36 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_36.c 106] bad36 		[N0 -{Return edge from bad36 to main}-> N88]	(the heap object @H(bad36::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N111): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N20
On edge  : N20 -{store i8* %3, i8** %data, align 8}-> N21
Message  : use of uninitialized variable
> Start from entry function: main, At N111 of Function main
> Entering function: good28, On N114 -> N62 (call good28)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good28)
> takes the false branch, At N68 of Function good28
> takes the true branch, At N84 of Function good28
> Leaving function: good28, On N61 -> N115 (Return edge from good28 to main)
> Entering function: bad28, On N115 -> N1 (call bad28)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the false branch, At N7 of Function bad28
<Defect> : N20 -> N21: [store i8* %3, i8** %data, align 8]
N20 -> N21: [store i8* %3, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N130
On edge  : N130 -{store i8* %line, i8** %line.addr, align 8}-> N132
Message  : use of uninitialized variable
> Start from entry function: main, At N111 of Function main
> Entering function: good28, On N114 -> N62 (call good28)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good28)
> takes the false branch, At N68 of Function good28
> takes the true branch, At N84 of Function good28
> Leaving function: good28, On N61 -> N115 (Return edge from good28 to main)
> Entering function: bad28, On N115 -> N1 (call bad28)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the false branch, At N7 of Function bad28
> takes the false branch, At N23 of Function bad28
> Entering function: printLine, On N28 -> N128 (call printLine)
<Defect> : N130 -> N132: [store i8* %line, i8** %line.addr, align 8]
N130 -> N132: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad28 to main}-> N116
Message  : the heap object @H(bad28::call1) is not referenced any more
> Start from entry function: main, At N111 of Function main
> Entering function: good28, On N114 -> N62 (call good28)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good28)
> takes the false branch, At N68 of Function good28
> takes the true branch, At N84 of Function good28
> Leaving function: good28, On N61 -> N115 (Return edge from good28 to main)
> Entering function: bad28, On N115 -> N1 (call bad28)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the true branch, At N7 of Function bad28
> takes the false branch, At N12 of Function bad28
> Entering function: printLine, On N17 -> N128 (call printLine)
> takes the true branch, At N134 of Function printLine
> Leaving function: printLine, On N127 -> N30 (Return edge from printLine to bad28)
> Entering function: globalReturnsTrueOrFalse, On N30 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N31 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the true branch, At N32 of Function bad28
<Defect> : N0 -> N116: [Return edge from bad28 to main]
N0 -> N116: [Return edge from bad28 to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./401_28.c 65] bad28 		[N20 -{store i8* %3, i8** %data, align 8}-> N21]	(use of uninitialized variable)
	[* 0] printLine 		[N130 -{store i8* %line, i8** %line.addr, align 8}-> N132]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_28.c 123] bad28 		[N0 -{Return edge from bad28 to main}-> N116]	(the heap object @H(bad28::call1) is not referenced any more)

Found 3 defects in all (4 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad9 to main}-> N62
Message  : the heap object @H(bad9::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good9, On N60 -> N35 (call good9)
> takes the true branch, At N43 of Function good9
> Leaving function: good9, On N34 -> N61 (Return edge from good9 to main)
> Entering function: bad9, On N61 -> N1 (call bad9)
> takes the false branch, At N9 of Function bad9
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad9)
<Defect> : N0 -> N62: [Return edge from bad9 to main]
N0 -> N62: [Return edge from bad9 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_9.c 102] bad9 		[N0 -{Return edge from bad9 to main}-> N62]	(the heap object @H(bad9::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N45
On edge  : N45 -{store i32* %1, i32** %data, align 8}-> N46
Message  : use of uninitialized variable
> Start from entry function: main, At N63 of Function main
> Entering function: good43, On N66 -> N39 (call good43)
<Defect> : N45 -> N46: [store i32* %1, i32** %data, align 8]
N45 -> N46: [store i32* %1, i32** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad43 to main}-> N68
Message  : the heap object @H(bad43::call) is not referenced any more
> Start from entry function: main, At N63 of Function main
> Entering function: good43, On N66 -> N39 (call good43)
> takes the false branch, At N48 of Function good43
> Entering function: printIntLine, On N56 -> N71 (call printIntLine)
> Leaving function: printIntLine, On N70 -> N58 (Return edge from printIntLine to good43)
> Leaving function: good43, On N38 -> N67 (Return edge from good43 to main)
> Entering function: bad43, On N67 -> N1 (call bad43)
> takes the false branch, At N10 of Function bad43
> Entering function: printIntLine, On N18 -> N71 (call printIntLine)
> Leaving function: printIntLine, On N70 -> N20 (Return edge from printIntLine to bad43)
<Defect> : N0 -> N68: [Return edge from bad43 to main]
N0 -> N68: [Return edge from bad43 to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./401_43.c 71] good43 		[N45 -{store i32* %1, i32** %data, align 8}-> N46]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_43.c 84] bad43 		[N0 -{Return edge from bad43 to main}-> N68]	(the heap object @H(bad43::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad4 to main}-> N62
Message  : the heap object @H(bad4::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good4, On N60 -> N35 (call good4)
> takes the true branch, At N43 of Function good4
> Leaving function: good4, On N34 -> N61 (Return edge from good4 to main)
> Entering function: bad4, On N61 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad4)
<Defect> : N0 -> N62: [Return edge from bad4 to main]
N0 -> N62: [Return edge from bad4 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_4.c 106] bad4 		[N0 -{Return edge from bad4 to main}-> N62]	(the heap object @H(bad4::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad38 to main}-> N88
Message  : the heap object @H(bad38::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good38, On N86 -> N47 (call good38)
> takes the true branch, At N53 of Function good38
> takes the true branch, At N59 of Function good38
> Leaving function: good38, On N46 -> N87 (Return edge from good38 to main)
> Entering function: bad38, On N87 -> N1 (call bad38)
> takes the true branch, At N7 of Function bad38
> takes the false branch, At N13 of Function bad38
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad38)
> takes the true branch, At N22 of Function bad38
<Defect> : N0 -> N88: [Return edge from bad38 to main]
N0 -> N88: [Return edge from bad38 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_38.c 105] bad38 		[N0 -{Return edge from bad38 to main}-> N88]	(the heap object @H(bad38::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad14 to main}-> N86
Message  : the heap object @H(bad14::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good14, On N84 -> N46 (call good14)
> takes the true branch, At N52 of Function good14
> takes the true branch, At N57 of Function good14
> Leaving function: good14, On N45 -> N85 (Return edge from good14 to main)
> Entering function: bad14, On N85 -> N1 (call bad14)
> takes the true branch, At N7 of Function bad14
> takes the false branch, At N12 of Function bad14
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad14)
> takes the true branch, At N21 of Function bad14
<Defect> : N0 -> N86: [Return edge from bad14 to main]
N0 -> N86: [Return edge from bad14 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_14.c 104] bad14 		[N0 -{Return edge from bad14 to main}-> N86]	(the heap object @H(bad14::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N99): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad12 to main}-> N104
Message  : the heap object @H(bad12::call1) is not referenced any more
> Start from entry function: main, At N99 of Function main
> Entering function: good12, On N102 -> N62 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N68 of Function good12
> Entering function: printLine, On N81 -> N116 (call printLine)
> takes the true branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N83 (Return edge from printLine to good12)
> Entering function: globalReturnsTrueOrFalse, On N83 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N84 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N85 of Function good12
> Leaving function: good12, On N61 -> N103 (Return edge from good12 to main)
> Entering function: bad12, On N103 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N7 of Function bad12
> takes the false branch, At N12 of Function bad12
> Entering function: printLine, On N17 -> N116 (call printLine)
> takes the true branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N30 (Return edge from printLine to bad12)
> Entering function: globalReturnsTrueOrFalse, On N30 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N31 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N32 of Function bad12
<Defect> : N0 -> N104: [Return edge from bad12 to main]
N0 -> N104: [Return edge from bad12 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N90
On edge  : N90 -{call void @free(i8* %5, i8* @free)}-> N92
Message  : null pointer dereference
> Start from entry function: main, At N99 of Function main
> Entering function: good12, On N102 -> N62 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N68 of Function good12
> Entering function: printLine, On N81 -> N116 (call printLine)
> takes the false branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N83 (Return edge from printLine to good12)
> Entering function: globalReturnsTrueOrFalse, On N83 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N84 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N85 of Function good12
<Defect> : N90 -> N92: [call void @free(i8* %5, i8* @free)]
N90 -> N92: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N87
On edge  : N87 -{call void @free(i8* %4, i8* @free)}-> N92
Message  : null pointer dereference
> Start from entry function: main, At N99 of Function main
> Entering function: good12, On N102 -> N62 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N68 of Function good12
> Entering function: printLine, On N81 -> N116 (call printLine)
> takes the false branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N83 (Return edge from printLine to good12)
> Entering function: globalReturnsTrueOrFalse, On N83 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N84 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the true branch, At N85 of Function good12
<Defect> : N87 -> N92: [call void @free(i8* %4, i8* @free)]
N87 -> N92: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N20
On edge  : N20 -{store i8* %3, i8** %data, align 8}-> N21
Message  : use of uninitialized variable
> Start from entry function: main, At N99 of Function main
> Entering function: good12, On N102 -> N62 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N68 of Function good12
> Entering function: printLine, On N81 -> N116 (call printLine)
> takes the true branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N83 (Return edge from printLine to good12)
> Entering function: globalReturnsTrueOrFalse, On N83 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N84 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N85 of Function good12
> Leaving function: good12, On N61 -> N103 (Return edge from good12 to main)
> Entering function: bad12, On N103 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N7 of Function bad12
<Defect> : N20 -> N21: [store i8* %3, i8** %data, align 8]
N20 -> N21: [store i8* %3, i8** %data, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N118
On edge  : N118 -{store i8* %line, i8** %line.addr, align 8}-> N120
Message  : use of uninitialized variable
> Start from entry function: main, At N99 of Function main
> Entering function: good12, On N102 -> N62 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N68 of Function good12
> Entering function: printLine, On N81 -> N116 (call printLine)
> takes the true branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N83 (Return edge from printLine to good12)
> Entering function: globalReturnsTrueOrFalse, On N83 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N84 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N85 of Function good12
> Leaving function: good12, On N61 -> N103 (Return edge from good12 to main)
> Entering function: bad12, On N103 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N7 of Function bad12
> takes the false branch, At N23 of Function bad12
> Entering function: printLine, On N28 -> N116 (call printLine)
<Defect> : N118 -> N120: [store i8* %line, i8** %line.addr, align 8]
N118 -> N120: [store i8* %line, i8** %line.addr, align 8] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_12.c 124] bad12 		[N0 -{Return edge from bad12 to main}-> N104]	(the heap object @H(bad12::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 2
	[./401_12.c 115] good12 		[N90 -{call void @free(i8* %5, i8* @free)}-> N92]	(null pointer dereference)
	[./401_12.c 110] good12 		[N87 -{call void @free(i8* %4, i8* @free)}-> N92]	(null pointer dereference)

CWE_457(Use of Uninitialized Variable): 2
	[./401_12.c 65] bad12 		[N20 -{store i8* %3, i8** %data, align 8}-> N21]	(use of uninitialized variable)
	[* 0] printLine 		[N118 -{store i8* %line, i8** %line.addr, align 8}-> N120]	(use of uninitialized variable)

Found 5 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad5 to main}-> N86
Message  : the heap object @H(bad5::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good5, On N84 -> N46 (call good5)
> takes the true branch, At N52 of Function good5
> takes the true branch, At N57 of Function good5
> Leaving function: good5, On N45 -> N85 (Return edge from good5 to main)
> Entering function: bad5, On N85 -> N1 (call bad5)
> takes the true branch, At N7 of Function bad5
> takes the false branch, At N12 of Function bad5
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad5)
> takes the true branch, At N21 of Function bad5
<Defect> : N0 -> N86: [Return edge from bad5 to main]
N0 -> N86: [Return edge from bad5 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_5.c 105] bad5 		[N0 -{Return edge from bad5 to main}-> N86]	(the heap object @H(bad5::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad18 to main}-> N62
Message  : the heap object @H(bad18::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good18, On N60 -> N35 (call good18)
> takes the true branch, At N43 of Function good18
> Leaving function: good18, On N34 -> N61 (Return edge from good18 to main)
> Entering function: bad18, On N61 -> N1 (call bad18)
> takes the false branch, At N9 of Function bad18
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad18)
<Defect> : N0 -> N62: [Return edge from bad18 to main]
N0 -> N62: [Return edge from bad18 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_18.c 102] bad18 		[N0 -{Return edge from bad18 to main}-> N62]	(the heap object @H(bad18::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad24 to main}-> N62
Message  : the heap object @H(bad24::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good24, On N60 -> N35 (call good24)
> takes the true branch, At N43 of Function good24
> Leaving function: good24, On N34 -> N61 (Return edge from good24 to main)
> Entering function: bad24, On N61 -> N1 (call bad24)
> takes the false branch, At N9 of Function bad24
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad24)
<Defect> : N0 -> N62: [Return edge from bad24 to main]
N0 -> N62: [Return edge from bad24 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_24.c 102] bad24 		[N0 -{Return edge from bad24 to main}-> N62]	(the heap object @H(bad24::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad34 to main}-> N64
Message  : the heap object @H(bad34::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good34, On N62 -> N36 (call good34)
> takes the true branch, At N45 of Function good34
> Leaving function: good34, On N35 -> N63 (Return edge from good34 to main)
> Entering function: bad34, On N63 -> N1 (call bad34)
> takes the false branch, At N10 of Function bad34
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad34)
<Defect> : N0 -> N64: [Return edge from bad34 to main]
N0 -> N64: [Return edge from bad34 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_34.c 101] bad34 		[N0 -{Return edge from bad34 to main}-> N64]	(the heap object @H(bad34::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad29 to main}-> N62
Message  : the heap object @H(bad29::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good29, On N60 -> N35 (call good29)
> takes the true branch, At N43 of Function good29
> Leaving function: good29, On N34 -> N61 (Return edge from good29 to main)
> Entering function: bad29, On N61 -> N1 (call bad29)
> takes the false branch, At N9 of Function bad29
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad29)
<Defect> : N0 -> N62: [Return edge from bad29 to main]
N0 -> N62: [Return edge from bad29 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_29.c 102] bad29 		[N0 -{Return edge from bad29 to main}-> N62]	(the heap object @H(bad29::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad33 to main}-> N64
Message  : the heap object @H(bad33::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good33, On N62 -> N36 (call good33)
> takes the true branch, At N45 of Function good33
> Leaving function: good33, On N35 -> N63 (Return edge from good33 to main)
> Entering function: bad33, On N63 -> N1 (call bad33)
> takes the false branch, At N10 of Function bad33
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad33)
<Defect> : N0 -> N64: [Return edge from bad33 to main]
N0 -> N64: [Return edge from bad33 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_33.c 101] bad33 		[N0 -{Return edge from bad33 to main}-> N64]	(the heap object @H(bad33::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad3 to main}-> N62
Message  : the heap object @H(bad3::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good3, On N60 -> N35 (call good3)
> takes the true branch, At N43 of Function good3
> Leaving function: good3, On N34 -> N61 (Return edge from good3 to main)
> Entering function: bad3, On N61 -> N1 (call bad3)
> takes the false branch, At N9 of Function bad3
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad3)
<Defect> : N0 -> N62: [Return edge from bad3 to main]
N0 -> N62: [Return edge from bad3 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_3.c 102] bad3 		[N0 -{Return edge from bad3 to main}-> N62]	(the heap object @H(bad3::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad26 to main}-> N86
Message  : the heap object @H(bad26::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good26, On N84 -> N46 (call good26)
> takes the true branch, At N52 of Function good26
> takes the true branch, At N57 of Function good26
> Leaving function: good26, On N45 -> N85 (Return edge from good26 to main)
> Entering function: bad26, On N85 -> N1 (call bad26)
> takes the true branch, At N7 of Function bad26
> takes the false branch, At N12 of Function bad26
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad26)
> takes the true branch, At N21 of Function bad26
<Defect> : N0 -> N86: [Return edge from bad26 to main]
N0 -> N86: [Return edge from bad26 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_26.c 102] bad26 		[N0 -{Return edge from bad26 to main}-> N86]	(the heap object @H(bad26::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/401/401_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad47 to main}-> N94
Message  : the heap object @H(bad47::call) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: bad47, On N93 -> N1 (call bad47)
> takes the true branch, At N7 of Function bad47
> takes the false branch, At N13 of Function bad47
> Entering function: printIntLine, On N21 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N23 (Return edge from printIntLine to bad47)
> takes the true branch, At N25 of Function bad47
<Defect> : N0 -> N94: [Return edge from bad47 to main]
N0 -> N94: [Return edge from bad47 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_47.c 104] bad47 		[N0 -{Return edge from bad47 to main}-> N94]	(the heap object @H(bad47::call) is not referenced any more)

Found 1 defects in all (5 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad46 to main}-> N60
Message  : the heap object @H(bad46::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good46, On N58 -> N41 (call good46)
> takes the true branch, At N47 of Function good46
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good46)
> Leaving function: good46, On N40 -> N59 (Return edge from good46 to main)
> Entering function: bad46, On N59 -> N1 (call bad46)
> Entering function: printIntLine, On N12 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N13 (Return edge from printIntLine to bad46)
> takes the true branch, At N15 of Function bad46
> Entering function: printIntLine, On N21 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N22 (Return edge from printIntLine to bad46)
<Defect> : N0 -> N60: [Return edge from bad46 to main]
N0 -> N60: [Return edge from bad46 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{store i32 5, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N55 of Function main
> Entering function: good46, On N58 -> N41 (call good46)
> takes the true branch, At N47 of Function good46
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good46)
> Leaving function: good46, On N40 -> N59 (Return edge from good46 to main)
> Entering function: bad46, On N59 -> N1 (call bad46)
<Defect> : N9 -> N10: [store i32 5, i32* %1, align 4]
N9 -> N10: [store i32 5, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_46.c 108] bad46 		[N0 -{Return edge from bad46 to main}-> N60]	(the heap object @H(bad46::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_46.c 68] bad46 		[N9 -{store i32 5, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good21, On N46 -> N25 (call good21)
> takes the false branch, At N31 of Function good21
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good21)
> Leaving function: good21, On N24 -> N47 (Return edge from good21 to main)
> Entering function: bad21, On N47 -> N1 (call bad21)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_21.c 70] bad21 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good24, On N46 -> N25 (call good24)
> takes the false branch, At N31 of Function good24
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good24)
> Leaving function: good24, On N24 -> N47 (Return edge from good24 to main)
> Entering function: bad24, On N47 -> N1 (call bad24)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_24.c 72] bad24 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N60): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N10
On edge  : N10 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N11
Message  : null pointer dereference
> Start from entry function: main, At N60 of Function main
> Entering function: good18, On N63 -> N38 (call good18)
> takes the false branch, At N45 of Function good18
> Leaving function: good18, On N37 -> N64 (Return edge from good18 to main)
> Entering function: bad18, On N64 -> N1 (call bad18)
<Defect> : N10 -> N11: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N10 -> N11: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_18.c 67] bad18 		[N10 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N11]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i64, i64* %2, align 8}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good37, On N72 -> N37 (call good37)
> takes the true branch, At N42 of Function good37
> takes the false branch, At N47 of Function good37
> takes the false branch, At N52 of Function good37
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good37)
> Leaving function: good37, On N36 -> N73 (Return edge from good37 to main)
> Entering function: bad37, On N73 -> N1 (call bad37)
> takes the true branch, At N6 of Function bad37
> takes the true branch, At N11 of Function bad37
<Defect> : N13 -> N14: [%3 = load i64, i64* %2, align 8]
N13 -> N14: [%3 = load i64, i64* %2, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_37.c 72] bad37 		[N13 -{%3 = load i64, i64* %2, align 8}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good15, On N61 -> N37 (call good15)
> takes the false branch, At N43 of Function good15
> Leaving function: good15, On N36 -> N62 (Return edge from good15 to main)
> Entering function: bad15, On N62 -> N1 (call bad15)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_15.c 68] bad15 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good33, On N46 -> N25 (call good33)
> takes the false branch, At N31 of Function good33
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good33)
> Leaving function: good33, On N24 -> N47 (Return edge from good33 to main)
> Entering function: bad33, On N47 -> N1 (call bad33)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_33.c 70] bad33 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N38): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N38 of Function main
> Entering function: good19, On N41 -> N25 (call good19)
> Entering function: printIntLine, On N34 -> N56 (call printIntLine)
> Leaving function: printIntLine, On N55 -> N35 (Return edge from printIntLine to good19)
> Leaving function: good19, On N24 -> N42 (Return edge from good19 to main)
> Entering function: bad19, On N42 -> N1 (call bad19)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_19.c 65] bad19 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good3, On N61 -> N37 (call good3)
> takes the false branch, At N43 of Function good3
> Leaving function: good3, On N36 -> N62 (Return edge from good3 to main)
> Entering function: bad3, On N62 -> N1 (call bad3)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_3.c 67] bad3 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good4, On N61 -> N37 (call good4)
> takes the false branch, At N43 of Function good4
> Leaving function: good4, On N36 -> N62 (Return edge from good4 to main)
> Entering function: bad4, On N62 -> N1 (call bad4)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_4.c 70] bad4 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good7, On N75 -> N43 (call good7)
> takes the false branch, At N47 of Function good7
> takes the false branch, At N54 of Function good7
> Leaving function: good7, On N42 -> N76 (Return edge from good7 to main)
> Entering function: bad7, On N76 -> N1 (call bad7)
> takes the true branch, At N5 of Function bad7
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_7.c 69] bad7 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good27, On N46 -> N25 (call good27)
> takes the false branch, At N31 of Function good27
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good27)
> Leaving function: good27, On N24 -> N47 (Return edge from good27 to main)
> Entering function: bad27, On N47 -> N1 (call bad27)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_27.c 70] bad27 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%1 = load i64, i64* %0, align 8}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good38, On N72 -> N37 (call good38)
> Entering function: staticReturnsTrue, On N40 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N41 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N42 of Function good38
> Entering function: staticReturnsFalse, On N45 -> N120 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N119 -> N46 (Return edge from staticReturnsFalse to good38)
> takes the false branch, At N47 of Function good38
> takes the false branch, At N52 of Function good38
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good38)
> Leaving function: good38, On N36 -> N73 (Return edge from good38 to main)
> Entering function: bad38, On N73 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N4 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N5 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N6 of Function bad38
> Entering function: staticReturnsTrue, On N9 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N10 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N11 of Function bad38
<Defect> : N13 -> N14: [%1 = load i64, i64* %0, align 8]
N13 -> N14: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_38.c 80] bad38 		[N13 -{%1 = load i64, i64* %0, align 8}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N45): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%2 = load i32, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N45 of Function main
> Entering function: good41, On N48 -> N31 (call good41)
> takes the true branch, At N37 of Function good41
> Entering function: printLine, On N42 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N40 (Return edge from printLine to good41)
> Leaving function: good41, On N30 -> N49 (Return edge from good41 to main)
> Entering function: bad41, On N49 -> N1 (call bad41)
> takes the true branch, At N7 of Function bad41
<Defect> : N9 -> N10: [%2 = load i32, i32* %1, align 4]
N9 -> N10: [%2 = load i32, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_41.c 66] bad41 		[N9 -{%2 = load i32, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad49 to main}-> N60
Message  : the heap object @H(bad49::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good49, On N58 -> N41 (call good49)
> takes the true branch, At N47 of Function good49
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good49)
> Leaving function: good49, On N40 -> N59 (Return edge from good49 to main)
> Entering function: bad49, On N59 -> N1 (call bad49)
> Entering function: printIntLine, On N12 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N13 (Return edge from printIntLine to bad49)
> takes the true branch, At N15 of Function bad49
> Entering function: printIntLine, On N21 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N22 (Return edge from printIntLine to bad49)
<Defect> : N0 -> N60: [Return edge from bad49 to main]
N0 -> N60: [Return edge from bad49 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{store i32 5, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N55 of Function main
> Entering function: good49, On N58 -> N41 (call good49)
> takes the true branch, At N47 of Function good49
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good49)
> Leaving function: good49, On N40 -> N59 (Return edge from good49 to main)
> Entering function: bad49, On N59 -> N1 (call bad49)
<Defect> : N9 -> N10: [store i32 5, i32* %1, align 4]
N9 -> N10: [store i32 5, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_49.c 105] bad49 		[N0 -{Return edge from bad49 to main}-> N60]	(the heap object @H(bad49::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_49.c 66] bad49 		[N9 -{store i32 5, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N50
On edge  : N50 -{store i32 5, i32* %2, align 4}-> N51
Message  : null pointer dereference
> Start from entry function: main, At N65 of Function main
> Entering function: good50, On N68 -> N37 (call good50)
> takes the false branch, At N41 of Function good50
<Defect> : N50 -> N51: [store i32 5, i32* %2, align 4]
N50 -> N51: [store i32 5, i32* %2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N36
On edge  : N36 -{Return edge from good50 to main}-> N69
Message  : the heap object @H(good50::call) is not referenced any more
> Start from entry function: main, At N65 of Function main
> Entering function: good50, On N68 -> N37 (call good50)
> takes the false branch, At N41 of Function good50
> Entering function: printIntLine, On N53 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N54 (Return edge from printIntLine to good50)
> Entering function: printIntLine, On N58 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N60 (Return edge from printIntLine to good50)
<Defect> : N36 -> N69: [Return edge from good50 to main]
N36 -> N69: [Return edge from good50 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_50.c 95] good50 		[N50 -{store i32 5, i32* %2, align 4}-> N51]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./476_50.c 106] good50 		[N36 -{Return edge from good50 to main}-> N69]	(the heap object @H(good50::call) is not referenced any more)

Found 2 defects in all (5 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good39, On N46 -> N25 (call good39)
> takes the false branch, At N31 of Function good39
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good39)
> Leaving function: good39, On N24 -> N47 (Return edge from good39 to main)
> Entering function: bad39, On N47 -> N1 (call bad39)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_39.c 70] bad39 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good34, On N46 -> N25 (call good34)
> takes the false branch, At N31 of Function good34
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good34)
> Leaving function: good34, On N24 -> N47 (Return edge from good34 to main)
> Entering function: bad34, On N47 -> N1 (call bad34)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_34.c 73] bad34 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good20, On N46 -> N25 (call good20)
> takes the false branch, At N31 of Function good20
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good20)
> Leaving function: good20, On N24 -> N47 (Return edge from good20 to main)
> Entering function: bad20, On N47 -> N1 (call bad20)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_20.c 70] bad20 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i32, i32* %2, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good28, On N72 -> N37 (call good28)
> takes the true branch, At N42 of Function good28
> takes the false branch, At N47 of Function good28
> takes the false branch, At N52 of Function good28
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good28)
> Leaving function: good28, On N36 -> N73 (Return edge from good28 to main)
> Entering function: bad28, On N73 -> N1 (call bad28)
> takes the true branch, At N6 of Function bad28
> takes the true branch, At N11 of Function bad28
<Defect> : N13 -> N14: [%3 = load i32, i32* %2, align 4]
N13 -> N14: [%3 = load i32, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_28.c 70] bad28 		[N13 -{%3 = load i32, i32* %2, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.123s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good22, On N46 -> N25 (call good22)
> takes the false branch, At N31 of Function good22
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good22)
> Leaving function: good22, On N24 -> N47 (Return edge from good22 to main)
> Entering function: bad22, On N47 -> N1 (call bad22)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_22.c 73] bad22 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{store i32 5, i32* %2, align 4}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good47, On N72 -> N47 (call good47)
> takes the false branch, At N51 of Function good47
> takes the true branch, At N58 of Function good47
> Entering function: printLine, On N66 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N62 (Return edge from printLine to good47)
> Leaving function: good47, On N46 -> N73 (Return edge from good47 to main)
> Entering function: bad47, On N73 -> N1 (call bad47)
> takes the true branch, At N5 of Function bad47
<Defect> : N12 -> N13: [store i32 5, i32* %2, align 4]
N12 -> N13: [store i32 5, i32* %2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad47 to main}-> N74
Message  : the heap object @H(bad47::call) is not referenced any more
> Start from entry function: main, At N69 of Function main
> Entering function: good47, On N72 -> N47 (call good47)
> takes the false branch, At N51 of Function good47
> takes the true branch, At N58 of Function good47
> Entering function: printLine, On N66 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N62 (Return edge from printLine to good47)
> Leaving function: good47, On N46 -> N73 (Return edge from good47 to main)
> Entering function: bad47, On N73 -> N1 (call bad47)
> takes the true branch, At N5 of Function bad47
> Entering function: printIntLine, On N15 -> N87 (call printIntLine)
> Leaving function: printIntLine, On N86 -> N16 (Return edge from printIntLine to bad47)
> takes the true branch, At N18 of Function bad47
> Entering function: printIntLine, On N24 -> N87 (call printIntLine)
> Leaving function: printIntLine, On N86 -> N26 (Return edge from printIntLine to bad47)
<Defect> : N0 -> N74: [Return edge from bad47 to main]
N0 -> N74: [Return edge from bad47 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_47.c 68] bad47 		[N12 -{store i32 5, i32* %2, align 4}-> N13]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./476_47.c 108] bad47 		[N0 -{Return edge from bad47 to main}-> N74]	(the heap object @H(bad47::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good8, On N75 -> N43 (call good8)
> Entering function: staticReturnsFalse, On N45 -> N123 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N122 -> N46 (Return edge from staticReturnsFalse to good8)
> takes the false branch, At N47 of Function good8
> takes the false branch, At N54 of Function good8
> Leaving function: good8, On N42 -> N76 (Return edge from good8 to main)
> Entering function: bad8, On N76 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N3 -> N127 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N126 -> N4 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N5 of Function bad8
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_8.c 77] bad8 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N36
On edge  : N36 -{Return edge from good48 to main}-> N69
Message  : the heap object @H(good48::call1) is not referenced any more
> Start from entry function: main, At N65 of Function main
> Entering function: good48, On N68 -> N37 (call good48)
> Entering function: staticReturnsFalse, On N39 -> N116 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N115 -> N40 (Return edge from staticReturnsFalse to good48)
> takes the false branch, At N41 of Function good48
> Entering function: printIntLine, On N53 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N54 (Return edge from printIntLine to good48)
> Entering function: printIntLine, On N58 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N60 (Return edge from printIntLine to good48)
<Defect> : N36 -> N69: [Return edge from good48 to main]
N36 -> N69: [Return edge from good48 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N50
On edge  : N50 -{store i32 5, i32* %1, align 4}-> N51
Message  : null pointer dereference
> Start from entry function: main, At N65 of Function main
> Entering function: good48, On N68 -> N37 (call good48)
> Entering function: staticReturnsFalse, On N39 -> N116 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N115 -> N40 (Return edge from staticReturnsFalse to good48)
> takes the false branch, At N41 of Function good48
<Defect> : N50 -> N51: [store i32 5, i32* %1, align 4]
N50 -> N51: [store i32 5, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_48.c 116] good48 		[N36 -{Return edge from good48 to main}-> N69]	(the heap object @H(good48::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_48.c 105] good48 		[N50 -{store i32 5, i32* %1, align 4}-> N51]	(null pointer dereference)

Found 2 defects in all (6 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%1 = load i32, i32* %0, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good29, On N72 -> N37 (call good29)
> Entering function: globalReturnsTrue, On N40 -> N27 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N26 -> N41 (Return edge from globalReturnsTrue to good29)
> takes the true branch, At N42 of Function good29
> Entering function: globalReturnsFalse, On N45 -> N23 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N22 -> N46 (Return edge from globalReturnsFalse to good29)
> takes the false branch, At N47 of Function good29
> takes the false branch, At N52 of Function good29
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good29)
> Leaving function: good29, On N36 -> N73 (Return edge from good29 to main)
> Entering function: bad29, On N73 -> N1 (call bad29)
> Entering function: globalReturnsTrue, On N4 -> N27 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N26 -> N5 (Return edge from globalReturnsTrue to bad29)
> takes the true branch, At N6 of Function bad29
> Entering function: globalReturnsTrue, On N9 -> N27 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N26 -> N10 (Return edge from globalReturnsTrue to bad29)
> takes the true branch, At N11 of Function bad29
<Defect> : N13 -> N14: [%1 = load i32, i32* %0, align 4]
N13 -> N14: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_29.c 70] bad29 		[N13 -{%1 = load i32, i32* %0, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good36, On N46 -> N25 (call good36)
> takes the false branch, At N31 of Function good36
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good36)
> Leaving function: good36, On N24 -> N47 (Return edge from good36 to main)
> Entering function: bad36, On N47 -> N1 (call bad36)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_36.c 72] bad36 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good5, On N75 -> N43 (call good5)
> takes the false branch, At N47 of Function good5
> takes the false branch, At N54 of Function good5
> Leaving function: good5, On N42 -> N76 (Return edge from good5 to main)
> Entering function: bad5, On N76 -> N1 (call bad5)
> takes the true branch, At N5 of Function bad5
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_5.c 70] bad5 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.143s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N10
On edge  : N10 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N11
Message  : null pointer dereference
> Start from entry function: main, At N62 of Function main
> Entering function: good16, On N65 -> N39 (call good16)
> takes the false branch, At N46 of Function good16
> Leaving function: good16, On N38 -> N66 (Return edge from good16 to main)
> Entering function: bad16, On N66 -> N1 (call bad16)
<Defect> : N10 -> N11: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N10 -> N11: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_16.c 67] bad16 		[N10 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N11]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good9, On N61 -> N37 (call good9)
> takes the false branch, At N43 of Function good9
> Leaving function: good9, On N36 -> N62 (Return edge from good9 to main)
> Entering function: bad9, On N62 -> N1 (call bad9)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_9.c 67] bad9 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad45 to main}-> N70
Message  : the heap object @H(bad45::call) is not referenced any more
> Start from entry function: main, At N65 of Function main
> Entering function: good45, On N68 -> N43 (call good45)
> takes the false branch, At N47 of Function good45
> takes the true branch, At N54 of Function good45
> Entering function: printLine, On N62 -> N92 (call printLine)
> takes the true branch, At N98 of Function printLine
> Leaving function: printLine, On N91 -> N58 (Return edge from printLine to good45)
> Leaving function: good45, On N42 -> N69 (Return edge from good45 to main)
> Entering function: bad45, On N69 -> N1 (call bad45)
> takes the false branch, At N5 of Function bad45
> Entering function: printIntLine, On N17 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N18 (Return edge from printIntLine to bad45)
> Entering function: printIntLine, On N22 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N24 (Return edge from printIntLine to bad45)
<Defect> : N0 -> N70: [Return edge from bad45 to main]
N0 -> N70: [Return edge from bad45 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N14
On edge  : N14 -{store i32 5, i32* %2, align 4}-> N15
Message  : null pointer dereference
> Start from entry function: main, At N65 of Function main
> Entering function: good45, On N68 -> N43 (call good45)
> takes the false branch, At N47 of Function good45
> takes the true branch, At N54 of Function good45
> Entering function: printLine, On N62 -> N92 (call printLine)
> takes the true branch, At N98 of Function printLine
> Leaving function: printLine, On N91 -> N58 (Return edge from printLine to good45)
> Leaving function: good45, On N42 -> N69 (Return edge from good45 to main)
> Entering function: bad45, On N69 -> N1 (call bad45)
> takes the false branch, At N5 of Function bad45
<Defect> : N14 -> N15: [store i32 5, i32* %2, align 4]
N14 -> N15: [store i32 5, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_45.c 110] bad45 		[N0 -{Return edge from bad45 to main}-> N70]	(the heap object @H(bad45::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_45.c 98] bad45 		[N14 -{store i32 5, i32* %2, align 4}-> N15]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good6, On N61 -> N37 (call good6)
> takes the false branch, At N43 of Function good6
> Leaving function: good6, On N36 -> N62 (Return edge from good6 to main)
> Entering function: bad6, On N62 -> N1 (call bad6)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_6.c 69] bad6 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i64, i64* %2, align 8}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good35, On N72 -> N37 (call good35)
> takes the true branch, At N42 of Function good35
> takes the false branch, At N47 of Function good35
> takes the false branch, At N52 of Function good35
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good35)
> Leaving function: good35, On N36 -> N73 (Return edge from good35 to main)
> Entering function: bad35, On N73 -> N1 (call bad35)
> takes the true branch, At N6 of Function bad35
> takes the true branch, At N11 of Function bad35
<Defect> : N13 -> N14: [%3 = load i64, i64* %2, align 8]
N13 -> N14: [%3 = load i64, i64* %2, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_35.c 73] bad35 		[N13 -{%3 = load i64, i64* %2, align 8}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N106 of Function main
> Entering function: good12, On N109 -> N61 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N64 -> N55 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N54 -> N65 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N66 of Function good12
> takes the false branch, At N84 of Function good12
> Leaving function: good12, On N60 -> N110 (Return edge from good12 to main)
> Entering function: bad12, On N110 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N4 -> N55 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N54 -> N5 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N6 of Function bad12
<Defect> : N13 -> N14: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N13 -> N14: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_12.c 67] bad12 		[N13 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N14]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i32, i32* %2, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good23, On N72 -> N37 (call good23)
> takes the true branch, At N42 of Function good23
> takes the false branch, At N47 of Function good23
> takes the false branch, At N52 of Function good23
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good23)
> Leaving function: good23, On N36 -> N73 (Return edge from good23 to main)
> Entering function: bad23, On N73 -> N1 (call bad23)
> takes the true branch, At N6 of Function bad23
> takes the true branch, At N11 of Function bad23
<Defect> : N13 -> N14: [%3 = load i32, i32* %2, align 4]
N13 -> N14: [%3 = load i32, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_23.c 73] bad23 		[N13 -{%3 = load i32, i32* %2, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%1 = load i32, i32* %0, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good26, On N72 -> N37 (call good26)
> Entering function: staticReturnsTrue, On N40 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N41 (Return edge from staticReturnsTrue to good26)
> takes the true branch, At N42 of Function good26
> Entering function: staticReturnsFalse, On N45 -> N120 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N119 -> N46 (Return edge from staticReturnsFalse to good26)
> takes the false branch, At N47 of Function good26
> takes the false branch, At N52 of Function good26
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good26)
> Leaving function: good26, On N36 -> N73 (Return edge from good26 to main)
> Entering function: bad26, On N73 -> N1 (call bad26)
> Entering function: staticReturnsTrue, On N4 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N5 (Return edge from staticReturnsTrue to bad26)
> takes the true branch, At N6 of Function bad26
> Entering function: staticReturnsTrue, On N9 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N10 (Return edge from staticReturnsTrue to bad26)
> takes the true branch, At N11 of Function bad26
<Defect> : N13 -> N14: [%1 = load i32, i32* %0, align 4]
N13 -> N14: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_26.c 80] bad26 		[N13 -{%1 = load i32, i32* %0, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.153s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N98): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N18
On edge  : N18 -{%1 = load i32, i32* %0, align 4}-> N19
Message  : null pointer dereference
> Start from entry function: main, At N98 of Function main
> Entering function: good30, On N101 -> N54 (call good30)
> Entering function: globalReturnsTrueOrFalse, On N57 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N58 (Return edge from globalReturnsTrueOrFalse to good30)
> takes the true branch, At N59 of Function good30
> Entering function: globalReturnsTrueOrFalse, On N64 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N65 (Return edge from globalReturnsTrueOrFalse to good30)
> takes the false branch, At N66 of Function good30
> takes the false branch, At N79 of Function good30
> Entering function: printLine, On N96 -> N125 (call printLine)
> takes the true branch, At N131 of Function printLine
> Leaving function: printLine, On N124 -> N87 (Return edge from printLine to good30)
> Leaving function: good30, On N53 -> N102 (Return edge from good30 to main)
> Entering function: bad30, On N102 -> N1 (call bad30)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N6 (Return edge from globalReturnsTrueOrFalse to bad30)
> takes the false branch, At N7 of Function bad30
> Entering function: globalReturnsTrueOrFalse, On N14 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N15 (Return edge from globalReturnsTrueOrFalse to bad30)
> takes the true branch, At N16 of Function bad30
<Defect> : N18 -> N19: [%1 = load i32, i32* %0, align 4]
N18 -> N19: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_30.c 78] bad30 		[N18 -{%1 = load i32, i32* %0, align 4}-> N19]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad44 to main}-> N60
Message  : the heap object @H(bad44::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good44, On N58 -> N41 (call good44)
> takes the true branch, At N47 of Function good44
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good44)
> Leaving function: good44, On N40 -> N59 (Return edge from good44 to main)
> Entering function: bad44, On N59 -> N1 (call bad44)
> Entering function: printIntLine, On N12 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N13 (Return edge from printIntLine to bad44)
> takes the true branch, At N15 of Function bad44
> Entering function: printIntLine, On N21 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N22 (Return edge from printIntLine to bad44)
<Defect> : N0 -> N60: [Return edge from bad44 to main]
N0 -> N60: [Return edge from bad44 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{store i32 5, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N55 of Function main
> Entering function: good44, On N58 -> N41 (call good44)
> takes the true branch, At N47 of Function good44
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good44)
> Leaving function: good44, On N40 -> N59 (Return edge from good44 to main)
> Entering function: bad44, On N59 -> N1 (call bad44)
<Defect> : N9 -> N10: [store i32 5, i32* %1, align 4]
N9 -> N10: [store i32 5, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_44.c 108] bad44 		[N0 -{Return edge from bad44 to main}-> N60]	(the heap object @H(bad44::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_44.c 69] bad44 		[N9 -{store i32 5, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good1, On N61 -> N37 (call good1)
> takes the false branch, At N43 of Function good1
> Leaving function: good1, On N36 -> N62 (Return edge from good1 to main)
> Entering function: bad1, On N62 -> N1 (call bad1)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_1.c 65] bad1 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good11, On N75 -> N43 (call good11)
> Entering function: globalReturnsFalse, On N45 -> N29 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N28 -> N46 (Return edge from globalReturnsFalse to good11)
> takes the false branch, At N47 of Function good11
> takes the false branch, At N54 of Function good11
> Leaving function: good11, On N42 -> N76 (Return edge from good11 to main)
> Entering function: bad11, On N76 -> N1 (call bad11)
> Entering function: globalReturnsTrue, On N3 -> N33 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N32 -> N4 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N5 of Function bad11
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_11.c 67] bad11 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good14, On N75 -> N43 (call good14)
> takes the false branch, At N47 of Function good14
> takes the false branch, At N54 of Function good14
> Leaving function: good14, On N42 -> N76 (Return edge from good14 to main)
> Entering function: bad14, On N76 -> N1 (call bad14)
> takes the true branch, At N5 of Function bad14
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_14.c 67] bad14 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.163s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N86): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N16
On edge  : N16 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N17
Message  : null pointer dereference
> Start from entry function: main, At N86 of Function main
> Entering function: good17, On N89 -> N51 (call good17)
> takes the true branch, At N59 of Function good17
> takes the false branch, At N64 of Function good17
> takes the false branch, At N59 of Function good17
> Leaving function: good17, On N50 -> N90 (Return edge from good17 to main)
> Entering function: bad17, On N90 -> N1 (call bad17)
> takes the true branch, At N9 of Function bad17
<Defect> : N16 -> N17: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N16 -> N17: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_17.c 68] bad17 		[N16 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N17]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good13, On N61 -> N37 (call good13)
> takes the false branch, At N43 of Function good13
> Leaving function: good13, On N36 -> N62 (Return edge from good13 to main)
> Entering function: bad13, On N62 -> N1 (call bad13)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_13.c 67] bad13 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.141s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N45): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%2 = load i32, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N45 of Function main
> Entering function: good42, On N48 -> N31 (call good42)
> takes the true branch, At N37 of Function good42
> Entering function: printLine, On N42 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N40 (Return edge from printLine to good42)
> Leaving function: good42, On N30 -> N49 (Return edge from good42 to main)
> Entering function: bad42, On N49 -> N1 (call bad42)
> takes the true branch, At N7 of Function bad42
<Defect> : N9 -> N10: [%2 = load i32, i32* %1, align 4]
N9 -> N10: [%2 = load i32, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_42.c 68] bad42 		[N9 -{%2 = load i32, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.149s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good10, On N75 -> N43 (call good10)
> takes the false branch, At N47 of Function good10
> takes the false branch, At N54 of Function good10
> Leaving function: good10, On N42 -> N76 (Return edge from good10 to main)
> Entering function: bad10, On N76 -> N1 (call bad10)
> takes the true branch, At N5 of Function bad10
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_10.c 67] bad10 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good32, On N46 -> N25 (call good32)
> takes the false branch, At N31 of Function good32
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good32)
> Leaving function: good32, On N24 -> N47 (Return edge from good32 to main)
> Entering function: bad32, On N47 -> N1 (call bad32)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_32.c 70] bad32 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i64, i64* %2, align 8}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good40, On N72 -> N37 (call good40)
> takes the true branch, At N42 of Function good40
> takes the false branch, At N47 of Function good40
> takes the false branch, At N52 of Function good40
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good40)
> Leaving function: good40, On N36 -> N73 (Return edge from good40 to main)
> Entering function: bad40, On N73 -> N1 (call bad40)
> takes the true branch, At N6 of Function bad40
> takes the true branch, At N11 of Function bad40
<Defect> : N13 -> N14: [%3 = load i64, i64* %2, align 8]
N13 -> N14: [%3 = load i64, i64* %2, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_40.c 70] bad40 		[N13 -{%3 = load i64, i64* %2, align 8}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N38): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N38 of Function main
> Entering function: good31, On N41 -> N25 (call good31)
> Entering function: printLongLine, On N34 -> N80 (call printLongLine)
> Leaving function: printLongLine, On N79 -> N35 (Return edge from printLongLine to good31)
> Leaving function: good31, On N24 -> N42 (Return edge from good31 to main)
> Entering function: bad31, On N42 -> N1 (call bad31)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_31.c 65] bad31 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.138s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good2, On N61 -> N37 (call good2)
> takes the false branch, At N43 of Function good2
> Leaving function: good2, On N36 -> N62 (Return edge from good2 to main)
> Entering function: bad2, On N62 -> N1 (call bad2)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_2.c 67] bad2 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.098s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N45): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%2 = load i32, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N45 of Function main
> Entering function: good43, On N48 -> N31 (call good43)
> takes the true branch, At N37 of Function good43
> Entering function: printLine, On N42 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N40 (Return edge from printLine to good43)
> Leaving function: good43, On N30 -> N49 (Return edge from good43 to main)
> Entering function: bad43, On N49 -> N1 (call bad43)
> takes the true branch, At N7 of Function bad43
<Defect> : N9 -> N10: [%2 = load i32, i32* %1, align 4]
N9 -> N10: [%2 = load i32, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_43.c 68] bad43 		[N9 -{%2 = load i32, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/476/476_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i32, i32* %2, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good25, On N72 -> N37 (call good25)
> takes the true branch, At N42 of Function good25
> takes the false branch, At N47 of Function good25
> takes the false branch, At N52 of Function good25
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good25)
> Leaving function: good25, On N36 -> N73 (Return edge from good25 to main)
> Entering function: bad25, On N73 -> N1 (call bad25)
> takes the true branch, At N6 of Function bad25
> takes the true branch, At N11 of Function bad25
<Defect> : N13 -> N14: [%3 = load i32, i32* %2, align 4]
N13 -> N14: [%3 = load i32, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_25.c 72] bad25 		[N13 -{%3 = load i32, i32* %2, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad14]
 +bad14
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.133s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N49 of Function main
> Entering function: good14, On N52 -> N25 (call good14)
> takes the true branch, At N34 of Function good14
> Entering function: printHexCharLine, On N42 -> N57 (call printHexCharLine)
> Leaving function: printHexCharLine, On N56 -> N44 (Return edge from printHexCharLine to good14)
> Leaving function: good14, On N24 -> N53 (Return edge from good14 to main)
> Entering function: bad14, On N53 -> N1 (call bad14)
> takes the true branch, At N10 of Function bad14
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_14.c 58] bad14 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad40]
 +bad40
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N70): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N18
On edge  : N18 -{%conv3 = trunc i32 %sub to i8}-> N19
Message  : integer underflow
> Start from entry function: main, At N70 of Function main
> Entering function: good40, On N73 -> N30 (call good40)
> takes the true branch, At N37 of Function good40
> takes the false branch, At N42 of Function good40
> takes the false branch, At N48 of Function good40
> Entering function: printLine, On N68 -> N97 (call printLine)
> takes the true branch, At N103 of Function printLine
> Leaving function: printLine, On N96 -> N61 (Return edge from printLine to good40)
> Leaving function: good40, On N29 -> N74 (Return edge from good40 to main)
> Entering function: bad40, On N74 -> N1 (call bad40)
> takes the true branch, At N8 of Function bad40
> takes the true branch, At N13 of Function bad40
<Defect> : N18 -> N19: [%conv3 = trunc i32 %sub to i8]
N18 -> N19: [%conv3 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_40.c 56] bad40 		[N18 -{%conv3 = trunc i32 %sub to i8}-> N19]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad48]
 +bad48
SCC(1): [printLine]
 +printLine
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N88): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N23
On edge  : N23 -{%conv7 = trunc i32 %mul to i16}-> N24
Message  : integer underflow
> Start from entry function: main, At N88 of Function main
> Entering function: good48, On N91 -> N39 (call good48)
> takes the true branch, At N46 of Function good48
> takes the false branch, At N52 of Function good48
> takes the false branch, At N58 of Function good48
> Leaving function: good48, On N38 -> N92 (Return edge from good48 to main)
> Entering function: bad48, On N92 -> N1 (call bad48)
> takes the true branch, At N8 of Function bad48
> takes the true branch, At N14 of Function bad48
> takes the true branch, At N18 of Function bad48
<Defect> : N23 -> N24: [%conv7 = trunc i32 %mul to i16]
N23 -> N24: [%conv7 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_48.c 57] bad48 		[N23 -{%conv7 = trunc i32 %mul to i16}-> N24]	(integer underflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [printLine]
 +printLine
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N16
On edge  : N16 -{%conv3 = trunc i32 %mul to i16}-> N17
Message  : integer underflow
> Start from entry function: main, At N62 of Function main
> Entering function: good44, On N65 -> N27 (call good44)
> takes the false branch, At N37 of Function good44
> Leaving function: good44, On N26 -> N66 (Return edge from good44 to main)
> Entering function: bad44, On N66 -> N1 (call bad44)
> takes the true branch, At N11 of Function bad44
<Defect> : N16 -> N17: [%conv3 = trunc i32 %mul to i16]
N16 -> N17: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_44.c 55] bad44 		[N16 -{%conv3 = trunc i32 %mul to i16}-> N17]	(integer underflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printUnsignedLine]
 +printUnsignedLine
SCC(1): [bad5]
 +bad5
SCC(1): [printLine]
 +printLine
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.138s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N17
On edge  : N17 -{%sub = sub i32 %3, 1}-> N18
Message  : integer underflow
> Start from entry function: main, At N65 of Function main
> Entering function: good5, On N68 -> N29 (call good5)
> takes the true branch, At N36 of Function good5
> takes the true branch, At N42 of Function good5
> takes the false branch, At N45 of Function good5
> Entering function: printLine, On N63 -> N92 (call printLine)
> takes the true branch, At N98 of Function printLine
> Leaving function: printLine, On N91 -> N56 (Return edge from printLine to good5)
> Leaving function: good5, On N28 -> N69 (Return edge from good5 to main)
> Entering function: bad5, On N69 -> N1 (call bad5)
> takes the true branch, At N8 of Function bad5
> takes the true branch, At N14 of Function bad5
<Defect> : N17 -> N18: [%sub = sub i32 %3, 1]
N17 -> N18: [%sub = sub i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_5.c 58] bad5 		[N17 -{%sub = sub i32 %3, 1}-> N18]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad6]
 +bad6
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.141s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N49 of Function main
> Entering function: good6, On N52 -> N25 (call good6)
> takes the true branch, At N34 of Function good6
> Entering function: printHexCharLine, On N42 -> N57 (call printHexCharLine)
> Leaving function: printHexCharLine, On N56 -> N44 (Return edge from printHexCharLine to good6)
> Leaving function: good6, On N24 -> N53 (Return edge from good6 to main)
> Entering function: bad6, On N53 -> N1 (call bad6)
> takes the true branch, At N10 of Function bad6
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_6.c 50] bad6 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [printLine]
 +printLine
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N88): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N23
On edge  : N23 -{%conv6 = trunc i32 %mul to i16}-> N24
Message  : integer underflow
> Start from entry function: main, At N88 of Function main
> Entering function: good46, On N91 -> N39 (call good46)
> takes the true branch, At N46 of Function good46
> takes the false branch, At N52 of Function good46
> takes the false branch, At N58 of Function good46
> Leaving function: good46, On N38 -> N92 (Return edge from good46 to main)
> Entering function: bad46, On N92 -> N1 (call bad46)
> takes the true branch, At N8 of Function bad46
> takes the true branch, At N14 of Function bad46
> takes the true branch, At N18 of Function bad46
<Defect> : N23 -> N24: [%conv6 = trunc i32 %mul to i16]
N23 -> N24: [%conv6 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_46.c 58] bad46 		[N23 -{%conv6 = trunc i32 %mul to i16}-> N24]	(integer underflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad28]
 +bad28
SCC(1): [printLine]
 +printLine
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N58 of Function main
> Entering function: good28, On N61 -> N25 (call good28)
> takes the true branch, At N34 of Function good28
> takes the false branch, At N38 of Function good28
> Entering function: printLine, On N56 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good28)
> Leaving function: good28, On N24 -> N62 (Return edge from good28 to main)
> Entering function: bad28, On N62 -> N1 (call bad28)
> takes the true branch, At N10 of Function bad28
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_28.c 55] bad28 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad50]
 +bad50
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N38): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N12
On edge  : N12 -{%conv1 = trunc i32 %sub to i16}-> N13
Message  : integer underflow
> Start from entry function: main, At N38 of Function main
> Entering function: good50, On N41 -> N20 (call good50)
> Entering function: printIntLine, On N34 -> N56 (call printIntLine)
> Leaving function: printIntLine, On N55 -> N35 (Return edge from printIntLine to good50)
> Leaving function: good50, On N19 -> N42 (Return edge from good50 to main)
> Entering function: bad50, On N42 -> N1 (call bad50)
<Defect> : N12 -> N13: [%conv1 = trunc i32 %sub to i16]
N12 -> N13: [%conv1 = trunc i32 %sub to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_50.c 49] bad50 		[N12 -{%conv1 = trunc i32 %sub to i16}-> N13]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad33]
 +bad33
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N84): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N22
On edge  : N22 -{%conv7 = trunc i32 %mul to i8}-> N23
Message  : integer underflow
> Start from entry function: main, At N84 of Function main
> Entering function: good33, On N87 -> N37 (call good33)
> Entering function: staticReturnsTrue, On N42 -> N148 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N147 -> N43 (Return edge from staticReturnsTrue to good33)
> takes the true branch, At N44 of Function good33
> Entering function: staticReturnsFalse, On N47 -> N144 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N143 -> N48 (Return edge from staticReturnsFalse to good33)
> takes the false branch, At N49 of Function good33
> takes the true branch, At N55 of Function good33
> takes the false branch, At N59 of Function good33
> Entering function: printLine, On N82 -> N111 (call printLine)
> takes the true branch, At N117 of Function printLine
> Leaving function: printLine, On N110 -> N73 (Return edge from printLine to good33)
> Leaving function: good33, On N36 -> N88 (Return edge from good33 to main)
> Entering function: bad33, On N88 -> N1 (call bad33)
> Entering function: staticReturnsTrue, On N6 -> N148 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N147 -> N7 (Return edge from staticReturnsTrue to bad33)
> takes the true branch, At N8 of Function bad33
> Entering function: staticReturnsTrue, On N11 -> N148 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N147 -> N12 (Return edge from staticReturnsTrue to bad33)
> takes the true branch, At N13 of Function bad33
> takes the true branch, At N17 of Function bad33
<Defect> : N22 -> N23: [%conv7 = trunc i32 %mul to i8]
N22 -> N23: [%conv7 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_33.c 65] bad33 		[N22 -{%conv7 = trunc i32 %mul to i8}-> N23]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad39]
 +bad39
SCC(1): [printLine]
 +printLine
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N44 of Function main
> Entering function: good39, On N47 -> N18 (call good39)
> takes the false branch, At N27 of Function good39
> Entering function: printLine, On N42 -> N71 (call printLine)
> takes the true branch, At N77 of Function printLine
> Leaving function: printLine, On N70 -> N39 (Return edge from printLine to good39)
> Leaving function: good39, On N17 -> N48 (Return edge from good39 to main)
> Entering function: bad39, On N48 -> N1 (call bad39)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_39.c 56] bad39 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad3]
 +bad3
SCC(1): [printLine]
 +printLine
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N39): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N9
On edge  : N9 -{%sub = sub i32 %0, 1}-> N10
Message  : integer underflow
> Start from entry function: main, At N39 of Function main
> Entering function: good3, On N42 -> N16 (call good3)
> takes the false branch, At N24 of Function good3
> Entering function: printLine, On N37 -> N66 (call printLine)
> takes the true branch, At N72 of Function printLine
> Leaving function: printLine, On N65 -> N34 (Return edge from printLine to good3)
> Leaving function: good3, On N15 -> N43 (Return edge from good3 to main)
> Entering function: bad3, On N43 -> N1 (call bad3)
<Defect> : N9 -> N10: [%sub = sub i32 %0, 1]
N9 -> N10: [%sub = sub i32 %0, 1] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_3.c 53] bad3 		[N9 -{%sub = sub i32 %0, 1}-> N10]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad38]
 +bad38
SCC(1): [printLine]
 +printLine
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N70): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N18
On edge  : N18 -{%conv3 = trunc i32 %sub to i8}-> N19
Message  : integer underflow
> Start from entry function: main, At N70 of Function main
> Entering function: good38, On N73 -> N30 (call good38)
> takes the true branch, At N37 of Function good38
> takes the false branch, At N42 of Function good38
> takes the false branch, At N48 of Function good38
> Entering function: printLine, On N68 -> N97 (call printLine)
> takes the true branch, At N103 of Function printLine
> Leaving function: printLine, On N96 -> N61 (Return edge from printLine to good38)
> Leaving function: good38, On N29 -> N74 (Return edge from good38 to main)
> Entering function: bad38, On N74 -> N1 (call bad38)
> takes the true branch, At N8 of Function bad38
> takes the true branch, At N13 of Function bad38
<Defect> : N18 -> N19: [%conv3 = trunc i32 %sub to i8]
N18 -> N19: [%conv3 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_38.c 57] bad38 		[N18 -{%conv3 = trunc i32 %sub to i8}-> N19]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad26]
 +bad26
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N49 of Function main
> Entering function: good26, On N52 -> N25 (call good26)
> takes the true branch, At N34 of Function good26
> Entering function: printHexCharLine, On N42 -> N57 (call printHexCharLine)
> Leaving function: printHexCharLine, On N56 -> N44 (Return edge from printHexCharLine to good26)
> Leaving function: good26, On N24 -> N53 (Return edge from good26 to main)
> Entering function: bad26, On N53 -> N1 (call bad26)
> takes the true branch, At N10 of Function bad26
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_26.c 50] bad26 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad27]
 +bad27
SCC(1): [printLine]
 +printLine
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N58 of Function main
> Entering function: good27, On N61 -> N25 (call good27)
> takes the true branch, At N34 of Function good27
> takes the false branch, At N38 of Function good27
> Entering function: printLine, On N56 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good27)
> Leaving function: good27, On N24 -> N62 (Return edge from good27 to main)
> Entering function: bad27, On N62 -> N1 (call bad27)
> takes the true branch, At N10 of Function bad27
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_27.c 55] bad27 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad1]
 +bad1
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.132s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N51): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i16}-> N16
Message  : integer underflow
> Start from entry function: main, At N51 of Function main
> Entering function: good1, On N54 -> N26 (call good1)
> takes the true branch, At N35 of Function good1
> Entering function: printIntLine, On N44 -> N69 (call printIntLine)
> Leaving function: printIntLine, On N68 -> N46 (Return edge from printIntLine to good1)
> Leaving function: good1, On N25 -> N55 (Return edge from good1 to main)
> Entering function: bad1, On N55 -> N1 (call bad1)
> takes the true branch, At N10 of Function bad1
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i16]
N15 -> N16: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_1.c 48] bad1 		[N15 -{%conv3 = trunc i32 %mul to i16}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad21]
 +bad21
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.179s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N35 of Function main
> Entering function: good21, On N38 -> N18 (call good21)
> Entering function: printHexCharLine, On N31 -> N43 (call printHexCharLine)
> Leaving function: printHexCharLine, On N42 -> N32 (Return edge from printHexCharLine to good21)
> Leaving function: good21, On N17 -> N39 (Return edge from good21 to main)
> Entering function: bad21, On N39 -> N1 (call bad21)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_21.c 55] bad21 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.148s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N52): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N16
On edge  : N16 -{%conv3 = trunc i32 %mul to i16}-> N17
Message  : integer underflow
> Start from entry function: main, At N52 of Function main
> Entering function: good42, On N55 -> N27 (call good42)
> takes the true branch, At N36 of Function good42
> Entering function: printIntLine, On N45 -> N70 (call printIntLine)
> Leaving function: printIntLine, On N69 -> N47 (Return edge from printIntLine to good42)
> Leaving function: good42, On N26 -> N56 (Return edge from good42 to main)
> Entering function: bad42, On N56 -> N1 (call bad42)
> takes the true branch, At N11 of Function bad42
<Defect> : N16 -> N17: [%conv3 = trunc i32 %mul to i16]
N16 -> N17: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_42.c 50] bad42 		[N16 -{%conv3 = trunc i32 %mul to i16}-> N17]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad4]
 +bad4
SCC(1): [printLine]
 +printLine
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.152s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N39): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N9
On edge  : N9 -{%sub = sub i64 %0, 1}-> N10
Message  : integer underflow
> Start from entry function: main, At N39 of Function main
> Entering function: good4, On N42 -> N16 (call good4)
> takes the false branch, At N24 of Function good4
> Entering function: printLine, On N37 -> N66 (call printLine)
> takes the true branch, At N72 of Function printLine
> Leaving function: printLine, On N65 -> N34 (Return edge from printLine to good4)
> Leaving function: good4, On N15 -> N43 (Return edge from good4 to main)
> Entering function: bad4, On N43 -> N1 (call bad4)
<Defect> : N9 -> N10: [%sub = sub i64 %0, 1]
N9 -> N10: [%sub = sub i64 %0, 1] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_4.c 58] bad4 		[N9 -{%sub = sub i64 %0, 1}-> N10]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad31]
 +bad31
SCC(1): [printLine]
 +printLine
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N58 of Function main
> Entering function: good31, On N61 -> N25 (call good31)
> takes the true branch, At N34 of Function good31
> takes the false branch, At N38 of Function good31
> Entering function: printLine, On N56 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good31)
> Leaving function: good31, On N24 -> N62 (Return edge from good31 to main)
> Entering function: bad31, On N62 -> N1 (call bad31)
> takes the true branch, At N10 of Function bad31
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_31.c 57] bad31 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad45]
 +bad45
SCC(1): [printLine]
 +printLine
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N16
On edge  : N16 -{%conv3 = trunc i32 %mul to i16}-> N17
Message  : integer underflow
> Start from entry function: main, At N62 of Function main
> Entering function: good45, On N65 -> N27 (call good45)
> takes the false branch, At N37 of Function good45
> Leaving function: good45, On N26 -> N66 (Return edge from good45 to main)
> Entering function: bad45, On N66 -> N1 (call bad45)
> takes the true branch, At N11 of Function bad45
<Defect> : N16 -> N17: [%conv3 = trunc i32 %mul to i16]
N16 -> N17: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_45.c 58] bad45 		[N16 -{%conv3 = trunc i32 %mul to i16}-> N17]	(integer underflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad32]
 +bad32
SCC(1): [printLine]
 +printLine
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N84): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N22
On edge  : N22 -{%conv7 = trunc i32 %mul to i8}-> N23
Message  : integer underflow
> Start from entry function: main, At N84 of Function main
> Entering function: good32, On N87 -> N37 (call good32)
> takes the true branch, At N44 of Function good32
> takes the false branch, At N49 of Function good32
> takes the true branch, At N55 of Function good32
> takes the false branch, At N59 of Function good32
> Entering function: printLine, On N82 -> N111 (call printLine)
> takes the true branch, At N117 of Function printLine
> Leaving function: printLine, On N110 -> N73 (Return edge from printLine to good32)
> Leaving function: good32, On N36 -> N88 (Return edge from good32 to main)
> Entering function: bad32, On N88 -> N1 (call bad32)
> takes the true branch, At N8 of Function bad32
> takes the true branch, At N13 of Function bad32
> takes the true branch, At N17 of Function bad32
<Defect> : N22 -> N23: [%conv7 = trunc i32 %mul to i8]
N22 -> N23: [%conv7 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_32.c 57] bad32 		[N22 -{%conv7 = trunc i32 %mul to i8}-> N23]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad47]
 +bad47
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N16
On edge  : N16 -{%conv3 = trunc i32 %mul to i16}-> N17
Message  : integer underflow
> Start from entry function: main, At N62 of Function main
> Entering function: good47, On N65 -> N27 (call good47)
> takes the false branch, At N37 of Function good47
> Leaving function: good47, On N26 -> N66 (Return edge from good47 to main)
> Entering function: bad47, On N66 -> N1 (call bad47)
> takes the true branch, At N11 of Function bad47
<Defect> : N16 -> N17: [%conv3 = trunc i32 %mul to i16]
N16 -> N17: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_47.c 57] bad47 		[N16 -{%conv3 = trunc i32 %mul to i16}-> N17]	(integer underflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad7]
 +bad7
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N49 of Function main
> Entering function: good7, On N52 -> N25 (call good7)
> takes the true branch, At N34 of Function good7
> Entering function: printHexCharLine, On N42 -> N57 (call printHexCharLine)
> Leaving function: printHexCharLine, On N56 -> N44 (Return edge from printHexCharLine to good7)
> Leaving function: good7, On N24 -> N53 (Return edge from good7 to main)
> Entering function: bad7, On N53 -> N1 (call bad7)
> takes the true branch, At N10 of Function bad7
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_7.c 55] bad7 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad11]
 +bad11
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N49 of Function main
> Entering function: good11, On N52 -> N25 (call good11)
> takes the true branch, At N34 of Function good11
> Entering function: printHexCharLine, On N42 -> N57 (call printHexCharLine)
> Leaving function: printHexCharLine, On N56 -> N44 (Return edge from printHexCharLine to good11)
> Leaving function: good11, On N24 -> N53 (Return edge from good11 to main)
> Entering function: bad11, On N53 -> N1 (call bad11)
> takes the true branch, At N10 of Function bad11
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_11.c 57] bad11 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad35]
 +bad35
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N44 of Function main
> Entering function: good35, On N47 -> N18 (call good35)
> takes the false branch, At N27 of Function good35
> Entering function: printLine, On N42 -> N71 (call printLine)
> takes the true branch, At N77 of Function printLine
> Leaving function: printLine, On N70 -> N39 (Return edge from printLine to good35)
> Leaving function: good35, On N17 -> N48 (Return edge from good35 to main)
> Entering function: bad35, On N48 -> N1 (call bad35)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_35.c 54] bad35 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad24]
 +bad24
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.147s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N35 of Function main
> Entering function: good24, On N38 -> N18 (call good24)
> Entering function: printHexCharLine, On N31 -> N43 (call printHexCharLine)
> Leaving function: printHexCharLine, On N42 -> N32 (Return edge from printHexCharLine to good24)
> Leaving function: good24, On N17 -> N39 (Return edge from good24 to main)
> Entering function: bad24, On N39 -> N1 (call bad24)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_24.c 61] bad24 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad13]
 +bad13
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N75): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N22
On edge  : N22 -{%conv7 = trunc i32 %mul to i8}-> N23
Message  : integer underflow
> Start from entry function: main, At N75 of Function main
> Entering function: good13, On N78 -> N37 (call good13)
> Entering function: staticReturnsFalse, On N42 -> N135 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N134 -> N43 (Return edge from staticReturnsFalse to good13)
> takes the false branch, At N44 of Function good13
> Entering function: staticReturnsTrue, On N49 -> N139 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N138 -> N50 (Return edge from staticReturnsTrue to good13)
> takes the true branch, At N51 of Function good13
> takes the true branch, At N55 of Function good13
> Entering function: printHexCharLine, On N63 -> N83 (call printHexCharLine)
> Leaving function: printHexCharLine, On N82 -> N66 (Return edge from printHexCharLine to good13)
> Leaving function: good13, On N36 -> N79 (Return edge from good13 to main)
> Entering function: bad13, On N79 -> N1 (call bad13)
> Entering function: staticReturnsTrue, On N6 -> N139 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N138 -> N7 (Return edge from staticReturnsTrue to bad13)
> takes the true branch, At N8 of Function bad13
> Entering function: staticReturnsTrue, On N11 -> N139 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N138 -> N12 (Return edge from staticReturnsTrue to bad13)
> takes the true branch, At N13 of Function bad13
> takes the true branch, At N17 of Function bad13
<Defect> : N22 -> N23: [%conv7 = trunc i32 %mul to i8]
N22 -> N23: [%conv7 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_13.c 65] bad13 		[N22 -{%conv7 = trunc i32 %mul to i8}-> N23]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad19]
 +bad19
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N35 of Function main
> Entering function: good19, On N38 -> N18 (call good19)
> Entering function: printHexCharLine, On N31 -> N43 (call printHexCharLine)
> Leaving function: printHexCharLine, On N42 -> N32 (Return edge from printHexCharLine to good19)
> Leaving function: good19, On N17 -> N39 (Return edge from good19 to main)
> Entering function: bad19, On N39 -> N1 (call bad19)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_19.c 56] bad19 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad36]
 +bad36
SCC(1): [printLine]
 +printLine
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N44 of Function main
> Entering function: good36, On N47 -> N18 (call good36)
> takes the false branch, At N27 of Function good36
> Entering function: printLine, On N42 -> N71 (call printLine)
> takes the true branch, At N77 of Function printLine
> Leaving function: printLine, On N70 -> N39 (Return edge from printLine to good36)
> Leaving function: good36, On N17 -> N48 (Return edge from good36 to main)
> Entering function: bad36, On N48 -> N1 (call bad36)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_36.c 53] bad36 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad8]
 +bad8
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N49 of Function main
> Entering function: good8, On N52 -> N25 (call good8)
> takes the true branch, At N34 of Function good8
> Entering function: printHexCharLine, On N42 -> N57 (call printHexCharLine)
> Leaving function: printHexCharLine, On N56 -> N44 (Return edge from printHexCharLine to good8)
> Leaving function: good8, On N24 -> N53 (Return edge from good8 to main)
> Entering function: bad8, On N53 -> N1 (call bad8)
> takes the true branch, At N10 of Function bad8
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_8.c 55] bad8 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad23]
 +bad23
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N61): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N18
On edge  : N18 -{%conv4 = trunc i32 %sub to i8}-> N19
Message  : integer underflow
> Start from entry function: main, At N61 of Function main
> Entering function: good23, On N64 -> N30 (call good23)
> Entering function: staticReturnsFalse, On N35 -> N121 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N120 -> N36 (Return edge from staticReturnsFalse to good23)
> takes the false branch, At N37 of Function good23
> Entering function: staticReturnsTrue, On N42 -> N125 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N124 -> N43 (Return edge from staticReturnsTrue to good23)
> takes the true branch, At N44 of Function good23
> Entering function: printHexCharLine, On N52 -> N69 (call printHexCharLine)
> Leaving function: printHexCharLine, On N68 -> N54 (Return edge from printHexCharLine to good23)
> Leaving function: good23, On N29 -> N65 (Return edge from good23 to main)
> Entering function: bad23, On N65 -> N1 (call bad23)
> Entering function: staticReturnsTrue, On N6 -> N125 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N124 -> N7 (Return edge from staticReturnsTrue to bad23)
> takes the true branch, At N8 of Function bad23
> Entering function: staticReturnsTrue, On N11 -> N125 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N124 -> N12 (Return edge from staticReturnsTrue to bad23)
> takes the true branch, At N13 of Function bad23
<Defect> : N18 -> N19: [%conv4 = trunc i32 %sub to i8]
N18 -> N19: [%conv4 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_23.c 63] bad23 		[N18 -{%conv4 = trunc i32 %sub to i8}-> N19]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad30]
 +bad30
SCC(1): [printLine]
 +printLine
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N84): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N22
On edge  : N22 -{%conv6 = trunc i32 %mul to i8}-> N23
Message  : integer underflow
> Start from entry function: main, At N84 of Function main
> Entering function: good30, On N87 -> N37 (call good30)
> takes the true branch, At N44 of Function good30
> takes the false branch, At N49 of Function good30
> takes the true branch, At N55 of Function good30
> takes the false branch, At N59 of Function good30
> Entering function: printLine, On N82 -> N111 (call printLine)
> takes the true branch, At N117 of Function printLine
> Leaving function: printLine, On N110 -> N73 (Return edge from printLine to good30)
> Leaving function: good30, On N36 -> N88 (Return edge from good30 to main)
> Entering function: bad30, On N88 -> N1 (call bad30)
> takes the true branch, At N8 of Function bad30
> takes the true branch, At N13 of Function bad30
> takes the true branch, At N17 of Function bad30
<Defect> : N22 -> N23: [%conv6 = trunc i32 %mul to i8]
N22 -> N23: [%conv6 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_30.c 58] bad30 		[N22 -{%conv6 = trunc i32 %mul to i8}-> N23]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad25]
 +bad25
SCC(1): [printLine]
 +printLine
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N61): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N18
On edge  : N18 -{%conv3 = trunc i32 %sub to i8}-> N19
Message  : integer underflow
> Start from entry function: main, At N61 of Function main
> Entering function: good25, On N64 -> N30 (call good25)
> takes the false branch, At N37 of Function good25
> takes the true branch, At N44 of Function good25
> Entering function: printHexCharLine, On N52 -> N69 (call printHexCharLine)
> Leaving function: printHexCharLine, On N68 -> N54 (Return edge from printHexCharLine to good25)
> Leaving function: good25, On N29 -> N65 (Return edge from good25 to main)
> Entering function: bad25, On N65 -> N1 (call bad25)
> takes the true branch, At N8 of Function bad25
> takes the true branch, At N13 of Function bad25
<Defect> : N18 -> N19: [%conv3 = trunc i32 %sub to i8]
N18 -> N19: [%conv3 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_25.c 61] bad25 		[N18 -{%conv3 = trunc i32 %sub to i8}-> N19]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad37]
 +bad37
SCC(1): [printLine]
 +printLine
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N44 of Function main
> Entering function: good37, On N47 -> N18 (call good37)
> takes the false branch, At N27 of Function good37
> Entering function: printLine, On N42 -> N71 (call printLine)
> takes the true branch, At N77 of Function printLine
> Leaving function: printLine, On N70 -> N39 (Return edge from printLine to good37)
> Leaving function: good37, On N17 -> N48 (Return edge from good37 to main)
> Entering function: bad37, On N48 -> N1 (call bad37)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_37.c 57] bad37 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad41]
 +bad41
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N70): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N18
On edge  : N18 -{%conv4 = trunc i32 %sub to i8}-> N19
Message  : integer underflow
> Start from entry function: main, At N70 of Function main
> Entering function: good41, On N73 -> N30 (call good41)
> Entering function: staticReturnsTrue, On N35 -> N134 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N133 -> N36 (Return edge from staticReturnsTrue to good41)
> takes the true branch, At N37 of Function good41
> Entering function: staticReturnsFalse, On N40 -> N130 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N129 -> N41 (Return edge from staticReturnsFalse to good41)
> takes the false branch, At N42 of Function good41
> takes the false branch, At N48 of Function good41
> Entering function: printLine, On N68 -> N97 (call printLine)
> takes the true branch, At N103 of Function printLine
> Leaving function: printLine, On N96 -> N61 (Return edge from printLine to good41)
> Leaving function: good41, On N29 -> N74 (Return edge from good41 to main)
> Entering function: bad41, On N74 -> N1 (call bad41)
> Entering function: staticReturnsTrue, On N6 -> N134 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N133 -> N7 (Return edge from staticReturnsTrue to bad41)
> takes the true branch, At N8 of Function bad41
> Entering function: staticReturnsTrue, On N11 -> N134 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N133 -> N12 (Return edge from staticReturnsTrue to bad41)
> takes the true branch, At N13 of Function bad41
<Defect> : N18 -> N19: [%conv4 = trunc i32 %sub to i8]
N18 -> N19: [%conv4 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_41.c 64] bad41 		[N18 -{%conv4 = trunc i32 %sub to i8}-> N19]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad34]
 +bad34
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.123s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N35 of Function main
> Entering function: good34, On N38 -> N18 (call good34)
> Entering function: printHexCharLine, On N31 -> N43 (call printHexCharLine)
> Leaving function: printHexCharLine, On N42 -> N32 (Return edge from printHexCharLine to good34)
> Leaving function: good34, On N17 -> N39 (Return edge from good34 to main)
> Entering function: bad34, On N39 -> N1 (call bad34)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_34.c 49] bad34 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad9]
 +bad9
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N49 of Function main
> Entering function: good9, On N52 -> N25 (call good9)
> takes the true branch, At N34 of Function good9
> Entering function: printHexCharLine, On N42 -> N57 (call printHexCharLine)
> Leaving function: printHexCharLine, On N56 -> N44 (Return edge from printHexCharLine to good9)
> Leaving function: good9, On N24 -> N53 (Return edge from good9 to main)
> Entering function: bad9, On N53 -> N1 (call bad9)
> takes the true branch, At N10 of Function bad9
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_9.c 58] bad9 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad49]
 +bad49
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.132s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N88): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N23
On edge  : N23 -{%conv8 = trunc i32 %mul to i16}-> N24
Message  : integer underflow
> Start from entry function: main, At N88 of Function main
> Entering function: good49, On N91 -> N39 (call good49)
> Entering function: staticReturnsTrue, On N44 -> N152 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N151 -> N45 (Return edge from staticReturnsTrue to good49)
> takes the true branch, At N46 of Function good49
> Entering function: staticReturnsFalse, On N50 -> N148 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N147 -> N51 (Return edge from staticReturnsFalse to good49)
> takes the false branch, At N52 of Function good49
> takes the false branch, At N58 of Function good49
> Leaving function: good49, On N38 -> N92 (Return edge from good49 to main)
> Entering function: bad49, On N92 -> N1 (call bad49)
> Entering function: staticReturnsTrue, On N6 -> N152 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N151 -> N7 (Return edge from staticReturnsTrue to bad49)
> takes the true branch, At N8 of Function bad49
> Entering function: staticReturnsTrue, On N12 -> N152 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N151 -> N13 (Return edge from staticReturnsTrue to bad49)
> takes the true branch, At N14 of Function bad49
> takes the true branch, At N18 of Function bad49
<Defect> : N23 -> N24: [%conv8 = trunc i32 %mul to i16]
N23 -> N24: [%conv8 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_49.c 65] bad49 		[N23 -{%conv8 = trunc i32 %mul to i16}-> N24]	(integer underflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad15]
 +bad15
SCC(1): [printLine]
 +printLine
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N75): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N22
On edge  : N22 -{%conv6 = trunc i32 %mul to i8}-> N23
Message  : integer underflow
> Start from entry function: main, At N75 of Function main
> Entering function: good15, On N78 -> N37 (call good15)
> takes the false branch, At N44 of Function good15
> takes the true branch, At N51 of Function good15
> takes the true branch, At N55 of Function good15
> Entering function: printHexCharLine, On N63 -> N83 (call printHexCharLine)
> Leaving function: printHexCharLine, On N82 -> N66 (Return edge from printHexCharLine to good15)
> Leaving function: good15, On N36 -> N79 (Return edge from good15 to main)
> Entering function: bad15, On N79 -> N1 (call bad15)
> takes the true branch, At N8 of Function bad15
> takes the true branch, At N13 of Function bad15
> takes the true branch, At N17 of Function bad15
<Defect> : N22 -> N23: [%conv6 = trunc i32 %mul to i8]
N22 -> N23: [%conv6 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_15.c 62] bad15 		[N22 -{%conv6 = trunc i32 %mul to i8}-> N23]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad2]
 +bad2
SCC(1): [printLine]
 +printLine
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N44 of Function main
> Entering function: good2, On N47 -> N18 (call good2)
> takes the false branch, At N27 of Function good2
> Entering function: printLine, On N42 -> N71 (call printLine)
> takes the true branch, At N77 of Function printLine
> Leaving function: printLine, On N70 -> N39 (Return edge from printLine to good2)
> Leaving function: good2, On N17 -> N48 (Return edge from good2 to main)
> Entering function: bad2, On N48 -> N1 (call bad2)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_2.c 52] bad2 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad10]
 +bad10
SCC(1): [printLine]
 +printLine
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.133s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N75): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N22
On edge  : N22 -{%conv6 = trunc i32 %mul to i8}-> N23
Message  : integer underflow
> Start from entry function: main, At N75 of Function main
> Entering function: good10, On N78 -> N37 (call good10)
> takes the false branch, At N44 of Function good10
> takes the true branch, At N51 of Function good10
> takes the true branch, At N55 of Function good10
> Entering function: printHexCharLine, On N63 -> N83 (call printHexCharLine)
> Leaving function: printHexCharLine, On N82 -> N66 (Return edge from printHexCharLine to good10)
> Leaving function: good10, On N36 -> N79 (Return edge from good10 to main)
> Entering function: bad10, On N79 -> N1 (call bad10)
> takes the true branch, At N8 of Function bad10
> takes the true branch, At N13 of Function bad10
> takes the true branch, At N17 of Function bad10
<Defect> : N22 -> N23: [%conv6 = trunc i32 %mul to i8]
N22 -> N23: [%conv6 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_10.c 58] bad10 		[N22 -{%conv6 = trunc i32 %mul to i8}-> N23]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad12]
 +bad12
SCC(1): [printLine]
 +printLine
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N75): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N22
On edge  : N22 -{%conv7 = trunc i32 %mul to i8}-> N23
Message  : integer underflow
> Start from entry function: main, At N75 of Function main
> Entering function: good12, On N78 -> N37 (call good12)
> takes the false branch, At N44 of Function good12
> takes the true branch, At N51 of Function good12
> takes the true branch, At N55 of Function good12
> Entering function: printHexCharLine, On N63 -> N83 (call printHexCharLine)
> Leaving function: printHexCharLine, On N82 -> N66 (Return edge from printHexCharLine to good12)
> Leaving function: good12, On N36 -> N79 (Return edge from good12 to main)
> Entering function: bad12, On N79 -> N1 (call bad12)
> takes the true branch, At N8 of Function bad12
> takes the true branch, At N13 of Function bad12
> takes the true branch, At N17 of Function bad12
<Defect> : N22 -> N23: [%conv7 = trunc i32 %mul to i8]
N22 -> N23: [%conv7 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_12.c 57] bad12 		[N22 -{%conv7 = trunc i32 %mul to i8}-> N23]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad20]
 +bad20
SCC(1): [printLine]
 +printLine
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N61): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N18
On edge  : N18 -{%conv3 = trunc i32 %sub to i8}-> N19
Message  : integer underflow
> Start from entry function: main, At N61 of Function main
> Entering function: good20, On N64 -> N30 (call good20)
> takes the false branch, At N37 of Function good20
> takes the true branch, At N44 of Function good20
> Entering function: printHexCharLine, On N52 -> N69 (call printHexCharLine)
> Leaving function: printHexCharLine, On N68 -> N54 (Return edge from printHexCharLine to good20)
> Leaving function: good20, On N29 -> N65 (Return edge from good20 to main)
> Entering function: bad20, On N65 -> N1 (call bad20)
> takes the true branch, At N8 of Function bad20
> takes the true branch, At N13 of Function bad20
<Defect> : N18 -> N19: [%conv3 = trunc i32 %sub to i8]
N18 -> N19: [%conv3 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_20.c 56] bad20 		[N18 -{%conv3 = trunc i32 %sub to i8}-> N19]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad16]
 +bad16
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N35 of Function main
> Entering function: good16, On N38 -> N18 (call good16)
> Entering function: printHexCharLine, On N31 -> N43 (call printHexCharLine)
> Leaving function: printHexCharLine, On N42 -> N32 (Return edge from printHexCharLine to good16)
> Leaving function: good16, On N17 -> N39 (Return edge from good16 to main)
> Entering function: bad16, On N39 -> N1 (call bad16)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_16.c 48] bad16 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [printLine]
 +printLine
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N16
On edge  : N16 -{%conv3 = trunc i32 %mul to i16}-> N17
Message  : integer underflow
> Start from entry function: main, At N62 of Function main
> Entering function: good43, On N65 -> N27 (call good43)
> takes the false branch, At N37 of Function good43
> Leaving function: good43, On N26 -> N66 (Return edge from good43 to main)
> Entering function: bad43, On N66 -> N1 (call bad43)
> takes the true branch, At N11 of Function bad43
<Defect> : N16 -> N17: [%conv3 = trunc i32 %mul to i16]
N16 -> N17: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_43.c 55] bad43 		[N16 -{%conv3 = trunc i32 %mul to i16}-> N17]	(integer underflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad22]
 +bad22
SCC(1): [printLine]
 +printLine
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N61): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N18
On edge  : N18 -{%conv3 = trunc i32 %sub to i8}-> N19
Message  : integer underflow
> Start from entry function: main, At N61 of Function main
> Entering function: good22, On N64 -> N30 (call good22)
> takes the false branch, At N37 of Function good22
> takes the true branch, At N44 of Function good22
> Entering function: printHexCharLine, On N52 -> N69 (call printHexCharLine)
> Leaving function: printHexCharLine, On N68 -> N54 (Return edge from printHexCharLine to good22)
> Leaving function: good22, On N29 -> N65 (Return edge from good22 to main)
> Entering function: bad22, On N65 -> N1 (call bad22)
> takes the true branch, At N8 of Function bad22
> takes the true branch, At N13 of Function bad22
<Defect> : N18 -> N19: [%conv3 = trunc i32 %sub to i8]
N18 -> N19: [%conv3 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_22.c 55] bad22 		[N18 -{%conv3 = trunc i32 %sub to i8}-> N19]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad17]
 +bad17
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N35 of Function main
> Entering function: good17, On N38 -> N18 (call good17)
> Entering function: printHexCharLine, On N31 -> N43 (call printHexCharLine)
> Leaving function: printHexCharLine, On N42 -> N32 (Return edge from printHexCharLine to good17)
> Leaving function: good17, On N17 -> N39 (Return edge from good17 to main)
> Entering function: bad17, On N39 -> N1 (call bad17)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_17.c 53] bad17 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad18]
 +bad18
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %sub to i8}-> N12
Message  : integer underflow
> Start from entry function: main, At N35 of Function main
> Entering function: good18, On N38 -> N18 (call good18)
> Entering function: printHexCharLine, On N31 -> N43 (call printHexCharLine)
> Leaving function: printHexCharLine, On N42 -> N32 (Return edge from printHexCharLine to good18)
> Leaving function: good18, On N17 -> N39 (Return edge from good18 to main)
> Entering function: bad18, On N39 -> N1 (call bad18)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %sub to i8]
N11 -> N12: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_18.c 53] bad18 		[N11 -{%conv1 = trunc i32 %sub to i8}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/191/191_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad29]
 +bad29
SCC(1): [printLine]
 +printLine
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [printUnsignedLine]
 +printUnsignedLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N15
On edge  : N15 -{%conv3 = trunc i32 %mul to i8}-> N16
Message  : integer underflow
> Start from entry function: main, At N58 of Function main
> Entering function: good29, On N61 -> N25 (call good29)
> takes the true branch, At N34 of Function good29
> takes the false branch, At N38 of Function good29
> Entering function: printLine, On N56 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good29)
> Leaving function: good29, On N24 -> N62 (Return edge from good29 to main)
> Entering function: bad29, On N62 -> N1 (call bad29)
> takes the true branch, At N10 of Function bad29
<Defect> : N15 -> N16: [%conv3 = trunc i32 %mul to i8]
N15 -> N16: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_29.c 58] bad29 		[N15 -{%conv3 = trunc i32 %mul to i8}-> N16]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N9
On edge  : N9 -{%add = add i64 %0, 1}-> N10
Message  : integer overflow
> Start from entry function: main, At N53 of Function main
> Entering function: good13, On N56 -> N30 (call good13)
> takes the false branch, At N38 of Function good13
> Entering function: printLine, On N51 -> N80 (call printLine)
> takes the true branch, At N86 of Function printLine
> Leaving function: printLine, On N79 -> N48 (Return edge from printLine to good13)
> Leaving function: good13, On N29 -> N57 (Return edge from good13 to main)
> Entering function: bad13, On N57 -> N1 (call bad13)
<Defect> : N9 -> N10: [%add = add i64 %0, 1]
N9 -> N10: [%add = add i64 %0, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_13.c 73] bad13 		[N9 -{%add = add i64 %0, 1}-> N10]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad47]
 +bad47
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N88): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N23
On edge  : N23 -{%conv6 = trunc i32 %mul to i16}-> N24
Message  : integer overflow
> Start from entry function: main, At N88 of Function main
> Entering function: good47, On N91 -> N39 (call good47)
> takes the true branch, At N46 of Function good47
> takes the false branch, At N52 of Function good47
> takes the false branch, At N58 of Function good47
> Leaving function: good47, On N38 -> N92 (Return edge from good47 to main)
> Entering function: bad47, On N92 -> N1 (call bad47)
> takes the true branch, At N8 of Function bad47
> takes the true branch, At N14 of Function bad47
> takes the true branch, At N18 of Function bad47
<Defect> : N23 -> N24: [%conv6 = trunc i32 %mul to i16]
N23 -> N24: [%conv6 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_47.c 57] bad47 		[N23 -{%conv6 = trunc i32 %mul to i16}-> N24]	(integer overflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N91): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N19
On edge  : N19 -{%mul = mul i64 %3, 2}-> N20
Message  : integer overflow
> Start from entry function: main, At N91 of Function main
> Entering function: good14, On N94 -> N48 (call good14)
> takes the true branch, At N55 of Function good14
> takes the false branch, At N60 of Function good14
> takes the true branch, At N65 of Function good14
> takes the false branch, At N68 of Function good14
> Entering function: printLine, On N89 -> N118 (call printLine)
> takes the true branch, At N124 of Function printLine
> Leaving function: printLine, On N117 -> N80 (Return edge from printLine to good14)
> Leaving function: good14, On N47 -> N95 (Return edge from good14 to main)
> Entering function: bad14, On N95 -> N1 (call bad14)
> takes the true branch, At N8 of Function bad14
> takes the true branch, At N13 of Function bad14
> takes the true branch, At N16 of Function bad14
<Defect> : N19 -> N20: [%mul = mul i64 %3, 2]
N19 -> N20: [%mul = mul i64 %3, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_14.c 74] bad14 		[N19 -{%mul = mul i64 %3, 2}-> N20]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [bad37]
 +bad37
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N71): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N23
On edge  : N23 -{%add = add i32 %2, 1}-> N24
Message  : integer overflow
> Start from entry function: main, At N71 of Function main
> Entering function: good37, On N74 -> N32 (call good37)
> takes the true branch, At N45 of Function good37
> takes the false branch, At N54 of Function good37
> Entering function: printLine, On N69 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good37)
> Leaving function: good37, On N31 -> N75 (Return edge from good37 to main)
> Entering function: bad37, On N75 -> N1 (call bad37)
> takes the true branch, At N14 of Function bad37
<Defect> : N23 -> N24: [%add = add i32 %2, 1]
N23 -> N24: [%add = add i32 %2, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_37.c 71] bad37 		[N23 -{%add = add i32 %2, 1}-> N24]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%add = add i32 %3, 1}-> N18
Message  : integer overflow
> Start from entry function: main, At N81 of Function main
> Entering function: good42, On N84 -> N43 (call good42)
> takes the true branch, At N50 of Function good42
> takes the false branch, At N56 of Function good42
> takes the false branch, At N61 of Function good42
> Entering function: printLine, On N79 -> N108 (call printLine)
> takes the true branch, At N114 of Function printLine
> Leaving function: printLine, On N107 -> N72 (Return edge from printLine to good42)
> Leaving function: good42, On N42 -> N85 (Return edge from good42 to main)
> Entering function: bad42, On N85 -> N1 (call bad42)
> takes the true branch, At N8 of Function bad42
> takes the true branch, At N14 of Function bad42
<Defect> : N17 -> N18: [%add = add i32 %3, 1]
N17 -> N18: [%add = add i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_42.c 72] bad42 		[N17 -{%add = add i32 %3, 1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad21]
 +bad21
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N71): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N45
On edge  : N45 -{store i32* %data, i32** %dataPtr1, align 8}-> N47
Message  : use of uninitialized variable
> Start from entry function: main, At N71 of Function main
> Entering function: good21, On N74 -> N36 (call good21)
<Defect> : N45 -> N47: [store i32* %data, i32** %dataPtr1, align 8]
N45 -> N47: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N47
On edge  : N47 -{store i32* %data, i32** %dataPtr2, align 8}-> N48
Message  : use of uninitialized variable
> Start from entry function: main, At N71 of Function main
> Entering function: good21, On N74 -> N36 (call good21)
<Defect> : N47 -> N48: [store i32* %data, i32** %dataPtr2, align 8]
N47 -> N48: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N10
On edge  : N10 -{store i32* %data, i32** %dataPtr1, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N71 of Function main
> Entering function: good21, On N74 -> N36 (call good21)
> Entering function: printIntLine, On N67 -> N89 (call printIntLine)
> Leaving function: printIntLine, On N88 -> N68 (Return edge from printIntLine to good21)
> Leaving function: good21, On N35 -> N75 (Return edge from good21 to main)
> Entering function: bad21, On N75 -> N1 (call bad21)
<Defect> : N10 -> N12: [store i32* %data, i32** %dataPtr1, align 8]
N10 -> N12: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N12
On edge  : N12 -{store i32* %data, i32** %dataPtr2, align 8}-> N13
Message  : use of uninitialized variable
> Start from entry function: main, At N71 of Function main
> Entering function: good21, On N74 -> N36 (call good21)
> Entering function: printIntLine, On N67 -> N89 (call printIntLine)
> Leaving function: printIntLine, On N88 -> N68 (Return edge from printIntLine to good21)
> Leaving function: good21, On N35 -> N75 (Return edge from good21 to main)
> Entering function: bad21, On N75 -> N1 (call bad21)
<Defect> : N12 -> N13: [store i32* %data, i32** %dataPtr2, align 8]
N12 -> N13: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N29
On edge  : N29 -{%mul = mul i32 %6, %7}-> N30
Message  : integer overflow
> Start from entry function: main, At N71 of Function main
> Entering function: good21, On N74 -> N36 (call good21)
> Entering function: printIntLine, On N67 -> N89 (call printIntLine)
> Leaving function: printIntLine, On N88 -> N68 (Return edge from printIntLine to good21)
> Leaving function: good21, On N35 -> N75 (Return edge from good21 to main)
> Entering function: bad21, On N75 -> N1 (call bad21)
<Defect> : N29 -> N30: [%mul = mul i32 %6, %7]
N29 -> N30: [%mul = mul i32 %6, %7] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 4
	[./190_21.c 60] good21 		[N45 -{store i32* %data, i32** %dataPtr1, align 8}-> N47]	(use of uninitialized variable)
	[./190_21.c 61] good21 		[N47 -{store i32* %data, i32** %dataPtr2, align 8}-> N48]	(use of uninitialized variable)
	[./190_21.c 37] bad21 		[N10 -{store i32* %data, i32** %dataPtr1, align 8}-> N12]	(use of uninitialized variable)
	[./190_21.c 38] bad21 		[N12 -{store i32* %data, i32** %dataPtr2, align 8}-> N13]	(use of uninitialized variable)

CWE_190(Integer Overflow): 1
	[./190_21.c 51] bad21 		[N29 -{%mul = mul i32 %6, %7}-> N30]	(integer overflow)

Found 5 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.156s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N116): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N32
On edge  : N32 -{%mul = mul i32 %5, 2}-> N33
Message  : integer overflow
> Start from entry function: main, At N116 of Function main
> Entering function: good17, On N119 -> N65 (call good17)
> takes the true branch, At N78 of Function good17
> takes the false branch, At N78 of Function good17
> takes the true branch, At N90 of Function good17
> takes the true branch, At N94 of Function good17
> Entering function: printIntLine, On N100 -> N134 (call printIntLine)
> Leaving function: printIntLine, On N133 -> N103 (Return edge from printIntLine to good17)
> takes the false branch, At N90 of Function good17
> Leaving function: good17, On N64 -> N120 (Return edge from good17 to main)
> Entering function: bad17, On N120 -> N1 (call bad17)
> takes the true branch, At N14 of Function bad17
> takes the false branch, At N14 of Function bad17
> takes the true branch, At N26 of Function bad17
> takes the true branch, At N29 of Function bad17
<Defect> : N32 -> N33: [%mul = mul i32 %5, 2]
N32 -> N33: [%mul = mul i32 %5, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_17.c 76] bad17 		[N32 -{%mul = mul i32 %5, 2}-> N33]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N93): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N20
On edge  : N20 -{%mul = mul i64 %2, 2}-> N21
Message  : integer overflow
> Start from entry function: main, At N93 of Function main
> Entering function: good11, On N96 -> N49 (call good11)
> Entering function: globalReturnsTrue, On N54 -> N39 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N38 -> N55 (Return edge from globalReturnsTrue to good11)
> takes the true branch, At N56 of Function good11
> Entering function: globalReturnsFalse, On N60 -> N35 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N34 -> N61 (Return edge from globalReturnsFalse to good11)
> takes the false branch, At N62 of Function good11
> takes the false branch, At N67 of Function good11
> Leaving function: good11, On N48 -> N97 (Return edge from good11 to main)
> Entering function: bad11, On N97 -> N1 (call bad11)
> Entering function: globalReturnsTrue, On N6 -> N39 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N38 -> N7 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N8 of Function bad11
> Entering function: globalReturnsTrue, On N12 -> N39 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N38 -> N13 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N14 of Function bad11
> takes the true branch, At N17 of Function bad11
<Defect> : N20 -> N21: [%mul = mul i64 %2, 2]
N20 -> N21: [%mul = mul i64 %2, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_11.c 74] bad11 		[N20 -{%mul = mul i64 %2, 2}-> N21]	(integer overflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [bad29]
 +bad29
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [good29]
 +good29
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N79): +oo]
> [1/1] entry: main ()
java.lang.NullPointerException
	at cn.edu.thu.tsmart.cpa.checker.instance.ApBasedChecker.preCheckInstructionEdge(ApBasedChecker.java:249)
	at cn.edu.thu.tsmart.cpa.checker.instance.ApBasedChecker.preCheckEdge(ApBasedChecker.java:112)
	at cn.edu.thu.tsmart.cpa.checker.instance.ApBasedChecker.preEdge(ApBasedChecker.java:84)
	at cn.edu.thu.tsmart.cpa.checker.CheckerTransferRelation.getAbstractSuccessorsForEdge(CheckerTransferRelation.java:50)
	at cn.edu.thu.tsmart.cpa.composite.CompositeTransferRelation.callTransferRelation(CompositeTransferRelation.java:181)
	at cn.edu.thu.tsmart.cpa.composite.CompositeTransferRelation.getAbstractSuccessorForSimpleEdge(CompositeTransferRelation.java:147)
	at cn.edu.thu.tsmart.cpa.composite.CompositeTransferRelation.getAbstractSuccessorForEdge(CompositeTransferRelation.java:120)
	at cn.edu.thu.tsmart.cpa.composite.CompositeTransferRelation.getAbstractSuccessors(CompositeTransferRelation.java:87)
	at cn.edu.thu.tsmart.cpa.arg.ARGTransferRelation.getAbstractSuccessors(ARGTransferRelation.java:80)
	at cn.edu.thu.tsmart.core.algorithm.CPAAlgorithm.handleState(CPAAlgorithm.java:151)
	at cn.edu.thu.tsmart.core.algorithm.CPAAlgorithm.run0(CPAAlgorithm.java:124)
	at cn.edu.thu.tsmart.core.algorithm.CPAAlgorithm.run(CPAAlgorithm.java:111)
	at cn.edu.thu.tsmart.core.phase.MultiEntryAlgorithmRunPhase.runPhase(MultiEntryAlgorithmRunPhase.java:220)
	at cn.edu.thu.tsmart.core.phase.framework.CPAPhase.run(CPAPhase.java:153)
	at cn.edu.thu.tsmart.core.phase.framework.SequentialExecStrategy.runPhase(SequentialExecStrategy.java:129)
	at cn.edu.thu.tsmart.core.phase.framework.SequentialExecStrategy.exec(SequentialExecStrategy.java:93)
	at cn.edu.thu.tsmart.core.phase.framework.PhaseManager.execute(PhaseManager.java:176)
	at cn.edu.thu.tsmart.core.TsmartCPAChecker.run(TsmartCPAChecker.java:87)
	at cn.edu.thu.tsmart.TsmartCheckerMain.main(TsmartCheckerMain.java:77)
Phase status: FAIL

Fail to execute 'basic' phase. Pending [result]. Completed [cfa,summary] (SequentialExecStrategy.exec, SEVERE)

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad3]
 +bad3
SCC(1): [printLine]
 +printLine
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N14
On edge  : N14 -{%conv2 = trunc i32 %mul to i8}-> N15
Message  : integer overflow
> Start from entry function: main, At N53 of Function main
> Entering function: good3, On N56 -> N21 (call good3)
> takes the false branch, At N34 of Function good3
> Entering function: printLine, On N51 -> N80 (call printLine)
> takes the true branch, At N86 of Function printLine
> Leaving function: printLine, On N79 -> N48 (Return edge from printLine to good3)
> Leaving function: good3, On N20 -> N57 (Return edge from good3 to main)
> Entering function: bad3, On N57 -> N1 (call bad3)
<Defect> : N14 -> N15: [%conv2 = trunc i32 %mul to i8]
N14 -> N15: [%conv2 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_3.c 47] bad3 		[N14 -{%conv2 = trunc i32 %mul to i8}-> N15]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [bad41]
 +bad41
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N109): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N33
On edge  : N33 -{%mul = mul i32 %5, 2}-> N34
Message  : integer overflow
> Start from entry function: main, At N109 of Function main
> Entering function: good41, On N112 -> N50 (call good41)
> takes the true branch, At N58 of Function good41
> takes the true branch, At N66 of Function good41
> takes the false branch, At N76 of Function good41
> takes the false branch, At N81 of Function good41
> Leaving function: good41, On N49 -> N113 (Return edge from good41 to main)
> Entering function: bad41, On N113 -> N1 (call bad41)
> takes the true branch, At N9 of Function bad41
> takes the true branch, At N17 of Function bad41
> takes the true branch, At N27 of Function bad41
> takes the true branch, At N30 of Function bad41
<Defect> : N33 -> N34: [%mul = mul i32 %5, 2]
N33 -> N34: [%mul = mul i32 %5, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_41.c 76] bad41 		[N33 -{%mul = mul i32 %5, 2}-> N34]	(integer overflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%add = add i32 %1, 1}-> N18
Message  : integer overflow
> Start from entry function: main, At N81 of Function main
> Entering function: good38, On N84 -> N43 (call good38)
> Entering function: globalReturnsTrue, On N48 -> N33 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N32 -> N49 (Return edge from globalReturnsTrue to good38)
> takes the true branch, At N50 of Function good38
> Entering function: globalReturnsFalse, On N54 -> N29 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N28 -> N55 (Return edge from globalReturnsFalse to good38)
> takes the false branch, At N56 of Function good38
> takes the false branch, At N61 of Function good38
> Entering function: printLine, On N79 -> N108 (call printLine)
> takes the true branch, At N114 of Function printLine
> Leaving function: printLine, On N107 -> N72 (Return edge from printLine to good38)
> Leaving function: good38, On N42 -> N85 (Return edge from good38 to main)
> Entering function: bad38, On N85 -> N1 (call bad38)
> Entering function: globalReturnsTrue, On N6 -> N33 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N32 -> N7 (Return edge from globalReturnsTrue to bad38)
> takes the true branch, At N8 of Function bad38
> Entering function: globalReturnsTrue, On N12 -> N33 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N32 -> N13 (Return edge from globalReturnsTrue to bad38)
> takes the true branch, At N14 of Function bad38
<Defect> : N17 -> N18: [%add = add i32 %1, 1]
N17 -> N18: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_38.c 72] bad38 		[N17 -{%add = add i32 %1, 1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad25]
 +bad25
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N74): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N25
On edge  : N25 -{%conv1 = trunc i32 %add to i16}-> N26
Message  : integer overflow
> Start from entry function: main, At N74 of Function main
> Entering function: good25, On N77 -> N33 (call good25)
> Entering function: goodSink, On N39 -> N43 (call goodSink)
> takes the false branch, At N56 of Function goodSink
> Entering function: printLine, On N72 -> N101 (call printLine)
> takes the true branch, At N107 of Function printLine
> Leaving function: printLine, On N100 -> N69 (Return edge from printLine to goodSink)
> Leaving function: goodSink, On N42 -> N40 (Return edge from goodSink to good25)
> Leaving function: good25, On N32 -> N78 (Return edge from good25 to main)
> Entering function: bad25, On N78 -> N1 (call bad25)
> Entering function: badSink, On N7 -> N11 (call badSink)
<Defect> : N25 -> N26: [%conv1 = trunc i32 %add to i16]
N25 -> N26: [%conv1 = trunc i32 %add to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_25.c 39] badSink 		[N25 -{%conv1 = trunc i32 %add to i16}-> N26]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N10
On edge  : N10 -{%add = add i32 %1, 1}-> N11
Message  : integer overflow
> Start from entry function: main, At N55 of Function main
> Entering function: good40, On N58 -> N31 (call good40)
> takes the false branch, At N40 of Function good40
> Entering function: printLine, On N53 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good40)
> Leaving function: good40, On N30 -> N59 (Return edge from good40 to main)
> Entering function: bad40, On N59 -> N1 (call bad40)
<Defect> : N10 -> N11: [%add = add i32 %1, 1]
N10 -> N11: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_40.c 72] bad40 		[N10 -{%add = add i32 %1, 1}-> N11]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N116): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N20
On edge  : N20 -{%add = add i32 %1, 1}-> N21
Message  : integer overflow
> Start from entry function: main, At N116 of Function main
> Entering function: good39, On N119 -> N61 (call good39)
> Entering function: globalReturnsTrueOrFalse, On N67 -> N55 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N54 -> N68 (Return edge from globalReturnsTrueOrFalse to good39)
> takes the false branch, At N69 of Function good39
> Entering function: globalReturnsTrueOrFalse, On N76 -> N55 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N54 -> N77 (Return edge from globalReturnsTrueOrFalse to good39)
> takes the false branch, At N78 of Function good39
> takes the false branch, At N94 of Function good39
> Entering function: printLine, On N114 -> N143 (call printLine)
> takes the true branch, At N149 of Function printLine
> Leaving function: printLine, On N142 -> N105 (Return edge from printLine to good39)
> Leaving function: good39, On N60 -> N120 (Return edge from good39 to main)
> Entering function: bad39, On N120 -> N1 (call bad39)
> Entering function: globalReturnsTrueOrFalse, On N7 -> N55 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N54 -> N8 (Return edge from globalReturnsTrueOrFalse to bad39)
> takes the false branch, At N9 of Function bad39
> Entering function: globalReturnsTrueOrFalse, On N15 -> N55 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N54 -> N16 (Return edge from globalReturnsTrueOrFalse to bad39)
> takes the true branch, At N17 of Function bad39
<Defect> : N20 -> N21: [%add = add i32 %1, 1]
N20 -> N21: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_39.c 77] bad39 		[N20 -{%add = add i32 %1, 1}-> N21]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad26]
 +bad26
SCC(1): [goodSink]
 +goodSink
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N94): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N36
On edge  : N36 -{%conv3 = trunc i32 %mul to i16}-> N37
Message  : integer overflow
> Start from entry function: main, At N94 of Function main
> Entering function: good26, On N97 -> N47 (call good26)
> Entering function: goodSink, On N59 -> N63 (call goodSink)
> takes the true branch, At N78 of Function goodSink
> Entering function: printIntLine, On N87 -> N112 (call printIntLine)
> Leaving function: printIntLine, On N111 -> N89 (Return edge from printIntLine to goodSink)
> Leaving function: goodSink, On N62 -> N60 (Return edge from goodSink to good26)
> Leaving function: good26, On N46 -> N98 (Return edge from good26 to main)
> Entering function: bad26, On N98 -> N1 (call bad26)
> Entering function: badSink, On N13 -> N17 (call badSink)
> takes the true branch, At N31 of Function badSink
<Defect> : N36 -> N37: [%conv3 = trunc i32 %mul to i16]
N36 -> N37: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_26.c 46] badSink 		[N36 -{%conv3 = trunc i32 %mul to i16}-> N37]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad33]
 +bad33
SCC(1): [printLine]
 +printLine
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%add = add i32 %3, 1}-> N18
Message  : integer overflow
> Start from entry function: main, At N65 of Function main
> Entering function: good33, On N68 -> N29 (call good33)
> takes the true branch, At N36 of Function good33
> takes the true branch, At N42 of Function good33
> takes the false branch, At N45 of Function good33
> Entering function: printLine, On N63 -> N92 (call printLine)
> takes the true branch, At N98 of Function printLine
> Leaving function: printLine, On N91 -> N56 (Return edge from printLine to good33)
> Leaving function: good33, On N28 -> N69 (Return edge from good33 to main)
> Entering function: bad33, On N69 -> N1 (call bad33)
> takes the true branch, At N8 of Function bad33
> takes the true branch, At N14 of Function bad33
<Defect> : N17 -> N18: [%add = add i32 %3, 1]
N17 -> N18: [%add = add i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_33.c 51] bad33 		[N17 -{%add = add i32 %3, 1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.147s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N111): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N29
On edge  : N29 -{%add = add i32 %4, 1}-> N30
Message  : integer overflow
> Start from entry function: main, At N111 of Function main
> Entering function: good45, On N114 -> N59 (call good45)
> takes the true branch, At N72 of Function good45
> takes the false branch, At N72 of Function good45
> takes the true branch, At N84 of Function good45
> takes the true branch, At N87 of Function good45
> Entering function: printIntLine, On N93 -> N129 (call printIntLine)
> Leaving function: printIntLine, On N128 -> N98 (Return edge from printIntLine to good45)
> takes the false branch, At N84 of Function good45
> Leaving function: good45, On N58 -> N115 (Return edge from good45 to main)
> Entering function: bad45, On N115 -> N1 (call bad45)
> takes the true branch, At N14 of Function bad45
> takes the false branch, At N14 of Function bad45
> takes the true branch, At N26 of Function bad45
<Defect> : N29 -> N30: [%add = add i32 %4, 1]
N29 -> N30: [%add = add i32 %4, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_45.c 73] bad45 		[N29 -{%add = add i32 %4, 1}-> N30]	(integer overflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad31]
 +bad31
SCC(1): [goodG2B]
 +goodG2B
SCC(1): [printLine]
 +printLine
SCC(1): [goodB2G]
 +goodB2G
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N16
On edge  : N16 -{%conv3 = trunc i32 %mul to i8}-> N17
Message  : integer overflow
> Start from entry function: main, At N90 of Function main
> Entering function: good31, On N93 -> N26 (call good31)
> Entering function: goodG2B, On N26 -> N66 (call goodG2B)
> takes the true branch, At N75 of Function goodG2B
> Entering function: printHexCharLine, On N83 -> N98 (call printHexCharLine)
> Leaving function: printHexCharLine, On N97 -> N85 (Return edge from printHexCharLine to goodG2B)
> Leaving function: goodG2B, On N65 -> N28 (Return edge from goodG2B to good31)
> Entering function: goodB2G, On N28 -> N32 (call goodB2G)
> takes the false branch, At N42 of Function goodB2G
> Leaving function: goodB2G, On N31 -> N29 (Return edge from goodB2G to good31)
> Leaving function: good31, On N25 -> N94 (Return edge from good31 to main)
> Entering function: bad31, On N94 -> N1 (call bad31)
> takes the true branch, At N11 of Function bad31
<Defect> : N16 -> N17: [%conv3 = trunc i32 %mul to i8]
N16 -> N17: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_31.c 42] bad31 		[N16 -{%conv3 = trunc i32 %mul to i8}-> N17]	(integer overflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N87): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N22
On edge  : N22 -{%add = add i32 %1, 1}-> N23
Message  : integer overflow
> Start from entry function: main, At N87 of Function main
> Entering function: good19, On N90 -> N46 (call good19)
> Entering function: goodSink, On N53 -> N57 (call goodSink)
> takes the false branch, At N64 of Function goodSink
> takes the false branch, At N69 of Function goodSink
> Entering function: printLine, On N85 -> N114 (call printLine)
> takes the true branch, At N120 of Function printLine
> Leaving function: printLine, On N113 -> N80 (Return edge from printLine to goodSink)
> Leaving function: goodSink, On N56 -> N54 (Return edge from goodSink to good19)
> Leaving function: good19, On N45 -> N91 (Return edge from good19 to main)
> Entering function: bad19, On N91 -> N1 (call bad19)
> Entering function: badSink, On N8 -> N12 (call badSink)
> takes the true branch, At N19 of Function badSink
<Defect> : N22 -> N23: [%add = add i32 %1, 1]
N22 -> N23: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_19.c 69] badSink 		[N22 -{%add = add i32 %1, 1}-> N23]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad6]
 +bad6
SCC(1): [printLine]
 +printLine
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N51): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N13
On edge  : N13 -{%conv2 = trunc i32 %mul to i8}-> N14
Message  : integer overflow
> Start from entry function: main, At N51 of Function main
> Entering function: good6, On N54 -> N20 (call good6)
> takes the false branch, At N32 of Function good6
> Entering function: printLine, On N49 -> N78 (call printLine)
> takes the true branch, At N84 of Function printLine
> Leaving function: printLine, On N77 -> N46 (Return edge from printLine to good6)
> Leaving function: good6, On N19 -> N55 (Return edge from good6 to main)
> Entering function: bad6, On N55 -> N1 (call bad6)
<Defect> : N13 -> N14: [%conv2 = trunc i32 %mul to i8]
N13 -> N14: [%conv2 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_6.c 49] bad6 		[N13 -{%conv2 = trunc i32 %mul to i8}-> N14]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N13
On edge  : N13 -{%add = add i32 %1, 1}-> N14
Message  : integer overflow
> Start from entry function: main, At N63 of Function main
> Entering function: good16, On N66 -> N35 (call good16)
> takes the false branch, At N47 of Function good16
> Entering function: printLine, On N61 -> N90 (call printLine)
> takes the true branch, At N96 of Function printLine
> Leaving function: printLine, On N89 -> N58 (Return edge from printLine to good16)
> Leaving function: good16, On N34 -> N67 (Return edge from good16 to main)
> Entering function: bad16, On N67 -> N1 (call bad16)
<Defect> : N13 -> N14: [%add = add i32 %1, 1]
N13 -> N14: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_16.c 75] bad16 		[N13 -{%add = add i32 %1, 1}-> N14]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N10
On edge  : N10 -{%add = add i32 %1, 1}-> N11
Message  : integer overflow
> Start from entry function: main, At N55 of Function main
> Entering function: good43, On N58 -> N31 (call good43)
> takes the false branch, At N40 of Function good43
> Entering function: printLine, On N53 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good43)
> Leaving function: good43, On N30 -> N59 (Return edge from good43 to main)
> Entering function: bad43, On N59 -> N1 (call bad43)
<Defect> : N10 -> N11: [%add = add i32 %1, 1]
N10 -> N11: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_43.c 79] bad43 		[N10 -{%add = add i32 %1, 1}-> N11]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N53
On edge  : N53 -{%mul = mul i32 %2, %3}-> N54
Message  : integer overflow
> Start from entry function: main, At N65 of Function main
> Entering function: good18, On N68 -> N34 (call good18)
> takes the true branch, At N49 of Function good18
<Defect> : N53 -> N54: [%mul = mul i32 %2, %3]
N53 -> N54: [%mul = mul i32 %2, %3] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N13
On edge  : N13 -{%mul = mul i32 %1, %2}-> N14
Message  : integer overflow
> Start from entry function: main, At N65 of Function main
> Entering function: good18, On N68 -> N34 (call good18)
> takes the true branch, At N49 of Function good18
> Entering function: printIntLine, On N56 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N60 (Return edge from printIntLine to good18)
> Leaving function: good18, On N33 -> N69 (Return edge from good18 to main)
> Entering function: bad18, On N69 -> N1 (call bad18)
<Defect> : N13 -> N14: [%mul = mul i32 %1, %2]
N13 -> N14: [%mul = mul i32 %1, %2] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N53
On edge  : N53 -{%mul = mul i32 %2, %3}-> N54
Message  : integer underflow
> Start from entry function: main, At N65 of Function main
> Entering function: good18, On N68 -> N34 (call good18)
> takes the true branch, At N49 of Function good18
<Defect> : N53 -> N54: [%mul = mul i32 %2, %3]
N53 -> N54: [%mul = mul i32 %2, %3] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N13
On edge  : N13 -{%mul = mul i32 %1, %2}-> N14
Message  : integer underflow
> Start from entry function: main, At N65 of Function main
> Entering function: good18, On N68 -> N34 (call good18)
> takes the true branch, At N49 of Function good18
> Entering function: printIntLine, On N56 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N60 (Return edge from printIntLine to good18)
> Leaving function: good18, On N33 -> N69 (Return edge from good18 to main)
> Entering function: bad18, On N69 -> N1 (call bad18)
<Defect> : N13 -> N14: [%mul = mul i32 %1, %2]
N13 -> N14: [%mul = mul i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 2
	[./190_18.c 92] good18 		[N53 -{%mul = mul i32 %2, %3}-> N54]	(integer overflow)
	[./190_18.c 73] bad18 		[N13 -{%mul = mul i32 %1, %2}-> N14]	(integer overflow)

CWE_191(Integer Underflow): 2
	[./190_18.c 92] good18 		[N53 -{%mul = mul i32 %2, %3}-> N54]	(integer underflow)
	[./190_18.c 73] bad18 		[N13 -{%mul = mul i32 %1, %2}-> N14]	(integer underflow)

Found 4 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad36]
 +bad36
SCC(1): [printLine]
 +printLine
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N67): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%add = add i32 %3, 1}-> N18
Message  : integer overflow
> Start from entry function: main, At N67 of Function main
> Entering function: good36, On N70 -> N29 (call good36)
> takes the true branch, At N36 of Function good36
> takes the false branch, At N42 of Function good36
> takes the false branch, At N47 of Function good36
> Entering function: printLine, On N65 -> N94 (call printLine)
> takes the true branch, At N100 of Function printLine
> Leaving function: printLine, On N93 -> N58 (Return edge from printLine to good36)
> Leaving function: good36, On N28 -> N71 (Return edge from good36 to main)
> Entering function: bad36, On N71 -> N1 (call bad36)
> takes the true branch, At N8 of Function bad36
> takes the true branch, At N14 of Function bad36
<Defect> : N17 -> N18: [%add = add i32 %3, 1]
N17 -> N18: [%add = add i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_36.c 58] bad36 		[N17 -{%add = add i32 %3, 1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad34]
 +bad34
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N67): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%add = add i32 %1, 1}-> N18
Message  : integer overflow
> Start from entry function: main, At N67 of Function main
> Entering function: good34, On N70 -> N29 (call good34)
> Entering function: staticReturnsTrue, On N34 -> N122 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N121 -> N35 (Return edge from staticReturnsTrue to good34)
> takes the true branch, At N36 of Function good34
> Entering function: staticReturnsFalse, On N40 -> N118 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N117 -> N41 (Return edge from staticReturnsFalse to good34)
> takes the false branch, At N42 of Function good34
> takes the false branch, At N47 of Function good34
> Entering function: printLine, On N65 -> N94 (call printLine)
> takes the true branch, At N100 of Function printLine
> Leaving function: printLine, On N93 -> N58 (Return edge from printLine to good34)
> Leaving function: good34, On N28 -> N71 (Return edge from good34 to main)
> Entering function: bad34, On N71 -> N1 (call bad34)
> Entering function: staticReturnsTrue, On N6 -> N122 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N121 -> N7 (Return edge from staticReturnsTrue to bad34)
> takes the true branch, At N8 of Function bad34
> Entering function: staticReturnsTrue, On N12 -> N122 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N121 -> N13 (Return edge from staticReturnsTrue to bad34)
> takes the true branch, At N14 of Function bad34
<Defect> : N17 -> N18: [%add = add i32 %1, 1]
N17 -> N18: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_34.c 59] bad34 		[N17 -{%add = add i32 %1, 1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad28]
 +bad28
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N98): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N34
On edge  : N34 -{%conv3 = trunc i32 %mul to i16}-> N35
Message  : integer overflow
> Start from entry function: main, At N98 of Function main
> Entering function: good28, On N101 -> N45 (call good28)
> Entering function: goodSink, On N51 -> N55 (call goodSink)
> takes the true branch, At N73 of Function goodSink
> takes the false branch, At N77 of Function goodSink
> Entering function: printLine, On N96 -> N125 (call printLine)
> takes the true branch, At N131 of Function printLine
> Leaving function: printLine, On N124 -> N91 (Return edge from printLine to goodSink)
> Leaving function: goodSink, On N54 -> N52 (Return edge from goodSink to good28)
> Leaving function: good28, On N44 -> N102 (Return edge from good28 to main)
> Entering function: bad28, On N102 -> N1 (call bad28)
> Entering function: badSink, On N7 -> N11 (call badSink)
> takes the true branch, At N29 of Function badSink
<Defect> : N34 -> N35: [%conv3 = trunc i32 %mul to i16]
N34 -> N35: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_28.c 48] badSink 		[N34 -{%conv3 = trunc i32 %mul to i16}-> N35]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N13
On edge  : N13 -{%add = add i32 %1, 1}-> N14
Message  : integer overflow
> Start from entry function: main, At N63 of Function main
> Entering function: good44, On N66 -> N35 (call good44)
> takes the false branch, At N47 of Function good44
> Entering function: printLine, On N61 -> N90 (call printLine)
> takes the true branch, At N96 of Function printLine
> Leaving function: printLine, On N89 -> N58 (Return edge from printLine to good44)
> Leaving function: good44, On N34 -> N67 (Return edge from good44 to main)
> Entering function: bad44, On N67 -> N1 (call bad44)
<Defect> : N13 -> N14: [%add = add i32 %1, 1]
N13 -> N14: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_44.c 76] bad44 		[N13 -{%add = add i32 %1, 1}-> N14]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad2]
 +bad2
SCC(1): [printLine]
 +printLine
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N60): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N16
On edge  : N16 -{%conv3 = trunc i32 %mul to i8}-> N17
Message  : integer overflow
> Start from entry function: main, At N60 of Function main
> Entering function: good2, On N63 -> N26 (call good2)
> takes the false branch, At N36 of Function good2
> Leaving function: good2, On N25 -> N64 (Return edge from good2 to main)
> Entering function: bad2, On N64 -> N1 (call bad2)
> takes the true branch, At N11 of Function bad2
<Defect> : N16 -> N17: [%conv3 = trunc i32 %mul to i8]
N16 -> N17: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_2.c 48] bad2 		[N16 -{%conv3 = trunc i32 %mul to i8}-> N17]	(integer overflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad23]
 +bad23
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N71): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N22
On edge  : N22 -{%mul = mul i32 %1, 2}-> N23
Message  : integer overflow
> Start from entry function: main, At N71 of Function main
> Entering function: good23, On N74 -> N32 (call good23)
> Entering function: goodSink, On N39 -> N43 (call goodSink)
> takes the false branch, At N50 of Function goodSink
> Leaving function: goodSink, On N42 -> N40 (Return edge from goodSink to good23)
> Leaving function: good23, On N31 -> N75 (Return edge from good23 to main)
> Entering function: bad23, On N75 -> N1 (call bad23)
> Entering function: badSink, On N8 -> N12 (call badSink)
> takes the true branch, At N19 of Function badSink
<Defect> : N22 -> N23: [%mul = mul i32 %1, 2]
N22 -> N23: [%mul = mul i32 %1, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_23.c 39] badSink 		[N22 -{%mul = mul i32 %1, 2}-> N23]	(integer overflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [badSource]
 +badSource
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad24]
 +bad24
SCC(1): [printLine]
 +printLine
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.095s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N47
On edge  : N47 -{%mul = mul i32 %2, %3}-> N48
Message  : integer overflow
> Start from entry function: main, At N59 of Function main
> Entering function: good24, On N62 -> N29 (call good24)
> Entering function: badSource, On N35 -> N19 (call badSource)
> Leaving function: badSource, On N18 -> N36 (Return edge from badSource to good24)
> takes the true branch, At N43 of Function good24
<Defect> : N47 -> N48: [%mul = mul i32 %2, %3]
N47 -> N48: [%mul = mul i32 %2, %3] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N12
On edge  : N12 -{%mul = mul i32 %1, %2}-> N13
Message  : integer overflow
> Start from entry function: main, At N59 of Function main
> Entering function: good24, On N62 -> N29 (call good24)
> Entering function: badSource, On N35 -> N19 (call badSource)
> Leaving function: badSource, On N18 -> N36 (Return edge from badSource to good24)
> takes the true branch, At N43 of Function good24
> Entering function: printIntLine, On N50 -> N77 (call printIntLine)
> Leaving function: printIntLine, On N76 -> N54 (Return edge from printIntLine to good24)
> Leaving function: good24, On N28 -> N63 (Return edge from good24 to main)
> Entering function: bad24, On N63 -> N1 (call bad24)
> Entering function: badSource, On N7 -> N19 (call badSource)
> Leaving function: badSource, On N18 -> N8 (Return edge from badSource to bad24)
<Defect> : N12 -> N13: [%mul = mul i32 %1, %2]
N12 -> N13: [%mul = mul i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 2
	[./190_24.c 63] good24 		[N47 -{%mul = mul i32 %2, %3}-> N48]	(integer overflow)
	[./190_24.c 49] bad24 		[N12 -{%mul = mul i32 %1, %2}-> N13]	(integer overflow)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N112): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N34
On edge  : N34 -{%conv16 = trunc i32 %mul to i8}-> N35
Message  : integer overflow
> Start from entry function: main, At N112 of Function main
> Entering function: good8, On N115 -> N51 (call good8)
> Entering function: staticReturnsTrue, On N56 -> N167 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N166 -> N57 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N58 of Function good8
> takes the false branch, At N65 of Function good8
> Entering function: staticReturnsFalse, On N73 -> N163 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N162 -> N74 (Return edge from staticReturnsFalse to good8)
> takes the false branch, At N75 of Function good8
> takes the false branch, At N81 of Function good8
> Leaving function: good8, On N50 -> N116 (Return edge from good8 to main)
> Entering function: bad8, On N116 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N6 -> N167 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N166 -> N7 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N8 of Function bad8
> takes the false branch, At N15 of Function bad8
> Entering function: staticReturnsTrue, On N23 -> N167 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N166 -> N24 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N25 of Function bad8
> takes the true branch, At N29 of Function bad8
<Defect> : N34 -> N35: [%conv16 = trunc i32 %mul to i8]
N34 -> N35: [%conv16 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_8.c 62] bad8 		[N34 -{%conv16 = trunc i32 %mul to i8}-> N35]	(integer overflow)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad4]
 +bad4
SCC(1): [printLine]
 +printLine
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N11
On edge  : N11 -{%conv1 = trunc i32 %add to i8}-> N12
Message  : integer overflow
> Start from entry function: main, At N44 of Function main
> Entering function: good4, On N47 -> N18 (call good4)
> takes the false branch, At N27 of Function good4
> Entering function: printLine, On N42 -> N71 (call printLine)
> takes the true branch, At N77 of Function printLine
> Leaving function: printLine, On N70 -> N39 (Return edge from printLine to good4)
> Leaving function: good4, On N17 -> N48 (Return edge from good4 to main)
> Entering function: bad4, On N48 -> N1 (call bad4)
<Defect> : N11 -> N12: [%conv1 = trunc i32 %add to i8]
N11 -> N12: [%conv1 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_4.c 50] bad4 		[N11 -{%conv1 = trunc i32 %add to i8}-> N12]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad30]
 +bad30
SCC(1): [goodG2B]
 +goodG2B
SCC(1): [printLine]
 +printLine
SCC(1): [goodB2G]
 +goodB2G
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N12
On edge  : N12 -{%conv1 = trunc i32 %add to i8}-> N13
Message  : integer overflow
> Start from entry function: main, At N69 of Function main
> Entering function: good30, On N72 -> N19 (call good30)
> Entering function: goodG2B, On N19 -> N52 (call goodG2B)
> Entering function: printHexCharLine, On N65 -> N77 (call printHexCharLine)
> Leaving function: printHexCharLine, On N76 -> N66 (Return edge from printHexCharLine to goodG2B)
> Leaving function: goodG2B, On N51 -> N21 (Return edge from goodG2B to good30)
> Entering function: goodB2G, On N21 -> N25 (call goodB2G)
> takes the false branch, At N35 of Function goodB2G
> Entering function: printLine, On N50 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N47 (Return edge from printLine to goodB2G)
> Leaving function: goodB2G, On N24 -> N22 (Return edge from goodB2G to good30)
> Leaving function: good30, On N18 -> N73 (Return edge from good30 to main)
> Entering function: bad30, On N73 -> N1 (call bad30)
<Defect> : N12 -> N13: [%conv1 = trunc i32 %add to i8]
N12 -> N13: [%conv1 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_30.c 41] bad30 		[N12 -{%conv1 = trunc i32 %add to i8}-> N13]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad27]
 +bad27
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N88): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N32
On edge  : N32 -{%conv1 = trunc i32 %add to i16}-> N33
Message  : integer overflow
> Start from entry function: main, At N88 of Function main
> Entering function: good27, On N91 -> N40 (call good27)
> Entering function: goodSink, On N52 -> N56 (call goodSink)
> takes the false branch, At N70 of Function goodSink
> Entering function: printLine, On N86 -> N115 (call printLine)
> takes the true branch, At N121 of Function printLine
> Leaving function: printLine, On N114 -> N83 (Return edge from printLine to goodSink)
> Leaving function: goodSink, On N55 -> N53 (Return edge from goodSink to good27)
> Leaving function: good27, On N39 -> N92 (Return edge from good27 to main)
> Entering function: bad27, On N92 -> N1 (call bad27)
> Entering function: badSink, On N13 -> N17 (call badSink)
<Defect> : N32 -> N33: [%conv1 = trunc i32 %add to i16]
N32 -> N33: [%conv1 = trunc i32 %add to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_27.c 44] badSink 		[N32 -{%conv1 = trunc i32 %add to i16}-> N33]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad22]
 +bad22
SCC(1): [printLine]
 +printLine
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N61): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N20
On edge  : N20 -{%add = add i32 %2, 1}-> N21
Message  : integer overflow
> Start from entry function: main, At N61 of Function main
> Entering function: good22, On N64 -> N27 (call good22)
> takes the false branch, At N46 of Function good22
> Entering function: printLine, On N59 -> N88 (call printLine)
> takes the true branch, At N94 of Function printLine
> Leaving function: printLine, On N87 -> N56 (Return edge from printLine to good22)
> Leaving function: good22, On N26 -> N65 (Return edge from good22 to main)
> Entering function: bad22, On N65 -> N1 (call bad22)
<Defect> : N20 -> N21: [%add = add i32 %2, 1]
N20 -> N21: [%add = add i32 %2, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_22.c 53] bad22 		[N20 -{%add = add i32 %2, 1}-> N21]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N20
On edge  : N20 -{%mul = mul i32 %3, 2}-> N21
Message  : integer overflow
> Start from entry function: main, At N81 of Function main
> Entering function: good20, On N84 -> N44 (call good20)
> takes the true branch, At N60 of Function good20
> takes the false branch, At N63 of Function good20
> Entering function: printLine, On N79 -> N108 (call printLine)
> takes the true branch, At N114 of Function printLine
> Leaving function: printLine, On N107 -> N74 (Return edge from printLine to good20)
> Leaving function: good20, On N43 -> N85 (Return edge from good20 to main)
> Entering function: bad20, On N85 -> N1 (call bad20)
> takes the true branch, At N17 of Function bad20
<Defect> : N20 -> N21: [%mul = mul i32 %3, 2]
N20 -> N21: [%mul = mul i32 %3, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_20.c 73] bad20 		[N20 -{%mul = mul i32 %3, 2}-> N21]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N46
On edge  : N46 -{%mul = mul i64 %1, %2}-> N47
Message  : integer overflow
> Start from entry function: main, At N58 of Function main
> Entering function: good15, On N61 -> N31 (call good15)
> takes the true branch, At N42 of Function good15
<Defect> : N46 -> N47: [%mul = mul i64 %1, %2]
N46 -> N47: [%mul = mul i64 %1, %2] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N10
On edge  : N10 -{%mul = mul i64 %0, %1}-> N11
Message  : integer overflow
> Start from entry function: main, At N58 of Function main
> Entering function: good15, On N61 -> N31 (call good15)
> takes the true branch, At N42 of Function good15
> Entering function: printLongLine, On N49 -> N100 (call printLongLine)
> Leaving function: printLongLine, On N99 -> N53 (Return edge from printLongLine to good15)
> Leaving function: good15, On N30 -> N62 (Return edge from good15 to main)
> Entering function: bad15, On N62 -> N1 (call bad15)
<Defect> : N10 -> N11: [%mul = mul i64 %0, %1]
N10 -> N11: [%mul = mul i64 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 2
	[./190_15.c 116] good15 		[N46 -{%mul = mul i64 %1, %2}-> N47]	(integer overflow)
	[./190_15.c 80] bad15 		[N10 -{%mul = mul i64 %0, %1}-> N11]	(integer overflow)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N12
On edge  : N12 -{%add = add i32 %1, 1}-> N13
Message  : integer overflow
> Start from entry function: main, At N59 of Function main
> Entering function: good46, On N62 -> N33 (call good46)
> takes the false branch, At N44 of Function good46
> Entering function: printLine, On N57 -> N86 (call printLine)
> takes the true branch, At N92 of Function printLine
> Leaving function: printLine, On N85 -> N54 (Return edge from printLine to good46)
> Leaving function: good46, On N32 -> N63 (Return edge from good46 to main)
> Entering function: bad46, On N63 -> N1 (call bad46)
<Defect> : N12 -> N13: [%add = add i32 %1, 1]
N12 -> N13: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_46.c 71] bad46 		[N12 -{%add = add i32 %1, 1}-> N13]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad35]
 +bad35
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N79): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N20
On edge  : N20 -{%conv4 = trunc i32 %mul to i8}-> N21
Message  : integer overflow
> Start from entry function: main, At N79 of Function main
> Entering function: good35, On N82 -> N32 (call good35)
> takes the true branch, At N39 of Function good35
> takes the false branch, At N44 of Function good35
> takes the false branch, At N55 of Function good35
> Entering function: printLine, On N77 -> N106 (call printLine)
> takes the true branch, At N112 of Function printLine
> Leaving function: printLine, On N105 -> N70 (Return edge from printLine to good35)
> Leaving function: good35, On N31 -> N83 (Return edge from good35 to main)
> Entering function: bad35, On N83 -> N1 (call bad35)
> takes the true branch, At N8 of Function bad35
> takes the true branch, At N13 of Function bad35
<Defect> : N20 -> N21: [%conv4 = trunc i32 %mul to i8]
N20 -> N21: [%conv4 = trunc i32 %mul to i8] <--
-- end of trace --
-- start of trace --
Weakness : Signed to Unsigned Conversion Error
At node  : N49
On edge  : N49 -{%conv3 = trunc i64 %conv to i32}-> N50
Message  : Signed to Unsigned Conversion Error
> Start from entry function: main, At N79 of Function main
> Entering function: good35, On N82 -> N32 (call good35)
> takes the true branch, At N39 of Function good35
> takes the false branch, At N44 of Function good35
<Defect> : N49 -> N50: [%conv3 = trunc i64 %conv to i32]
N49 -> N50: [%conv3 = trunc i64 %conv to i32] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_35.c 60] bad35 		[N20 -{%conv4 = trunc i32 %mul to i8}-> N21]	(integer overflow)

CWE_195(Signed to Unsigned Conversion Error): 1
	[./190_35.c 87] good35 		[N49 -{%conv3 = trunc i64 %conv to i32}-> N50]	(Signed to Unsigned Conversion Error)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad10]
 +bad10
SCC(1): [printLine]
 +printLine
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N67): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%add = add i64 %3, 1}-> N18
Message  : integer overflow
> Start from entry function: main, At N67 of Function main
> Entering function: good10, On N70 -> N29 (call good10)
> takes the true branch, At N36 of Function good10
> takes the false branch, At N42 of Function good10
> takes the false branch, At N47 of Function good10
> Entering function: printLine, On N65 -> N75 (call printLine)
> takes the true branch, At N81 of Function printLine
> Leaving function: printLine, On N74 -> N58 (Return edge from printLine to good10)
> Leaving function: good10, On N28 -> N71 (Return edge from good10 to main)
> Entering function: bad10, On N71 -> N1 (call bad10)
> takes the true branch, At N8 of Function bad10
> takes the true branch, At N14 of Function bad10
<Defect> : N17 -> N18: [%add = add i64 %3, 1]
N17 -> N18: [%add = add i64 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_10.c 46] bad10 		[N17 -{%add = add i64 %3, 1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N84): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N29
On edge  : N29 -{%add = add i32 %7, 1}-> N30
Message  : integer overflow
> Start from entry function: main, At N84 of Function main
> Entering function: good50, On N87 -> N50 (call good50)
> Entering function: printIntLine, On N80 -> N102 (call printIntLine)
> Leaving function: printIntLine, On N101 -> N81 (Return edge from printIntLine to good50)
> Leaving function: good50, On N49 -> N88 (Return edge from good50 to main)
> Entering function: bad50, On N88 -> N1 (call bad50)
<Defect> : N29 -> N30: [%add = add i32 %7, 1]
N29 -> N30: [%add = add i32 %7, 1] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N59
On edge  : N59 -{store i32* %data, i32** %dataPtr1, align 8}-> N61
Message  : use of uninitialized variable
> Start from entry function: main, At N84 of Function main
> Entering function: good50, On N87 -> N50 (call good50)
<Defect> : N59 -> N61: [store i32* %data, i32** %dataPtr1, align 8]
N59 -> N61: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N61
On edge  : N61 -{store i32* %data, i32** %dataPtr2, align 8}-> N62
Message  : use of uninitialized variable
> Start from entry function: main, At N84 of Function main
> Entering function: good50, On N87 -> N50 (call good50)
<Defect> : N61 -> N62: [store i32* %data, i32** %dataPtr2, align 8]
N61 -> N62: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N10
On edge  : N10 -{store i32* %data, i32** %dataPtr1, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N84 of Function main
> Entering function: good50, On N87 -> N50 (call good50)
> Entering function: printIntLine, On N80 -> N102 (call printIntLine)
> Leaving function: printIntLine, On N101 -> N81 (Return edge from printIntLine to good50)
> Leaving function: good50, On N49 -> N88 (Return edge from good50 to main)
> Entering function: bad50, On N88 -> N1 (call bad50)
<Defect> : N10 -> N12: [store i32* %data, i32** %dataPtr1, align 8]
N10 -> N12: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N12
On edge  : N12 -{store i32* %data, i32** %dataPtr2, align 8}-> N13
Message  : use of uninitialized variable
> Start from entry function: main, At N84 of Function main
> Entering function: good50, On N87 -> N50 (call good50)
> Entering function: printIntLine, On N80 -> N102 (call printIntLine)
> Leaving function: printIntLine, On N101 -> N81 (Return edge from printIntLine to good50)
> Leaving function: good50, On N49 -> N88 (Return edge from good50 to main)
> Entering function: bad50, On N88 -> N1 (call bad50)
<Defect> : N12 -> N13: [store i32* %data, i32** %dataPtr2, align 8]
N12 -> N13: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_50.c 75] bad50 		[N29 -{%add = add i32 %7, 1}-> N30]	(integer overflow)

CWE_457(Use of Uninitialized Variable): 4
	[./190_50.c 88] good50 		[N59 -{store i32* %data, i32** %dataPtr1, align 8}-> N61]	(use of uninitialized variable)
	[./190_50.c 89] good50 		[N61 -{store i32* %data, i32** %dataPtr2, align 8}-> N62]	(use of uninitialized variable)
	[./190_50.c 61] bad50 		[N10 -{store i32* %data, i32** %dataPtr1, align 8}-> N12]	(use of uninitialized variable)
	[./190_50.c 62] bad50 		[N12 -{store i32* %data, i32** %dataPtr2, align 8}-> N13]	(use of uninitialized variable)

Found 5 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N129): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N110
On edge  : N110 -{%mul20 = mul i64 %7, %8}-> N111
Message  : integer overflow
> Start from entry function: main, At N129 of Function main
> Entering function: good12, On N132 -> N66 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N72 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N73 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N74 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N81 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N82 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N83 of Function good12
> takes the true branch, At N106 of Function good12
<Defect> : N110 -> N111: [%mul20 = mul i64 %7, %8]
N110 -> N111: [%mul20 = mul i64 %7, %8] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N93
On edge  : N93 -{%mul = mul i64 %3, %4}-> N94
Message  : integer overflow
> Start from entry function: main, At N129 of Function main
> Entering function: good12, On N132 -> N66 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N72 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N73 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N74 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N81 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N82 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the true branch, At N83 of Function good12
> takes the true branch, At N89 of Function good12
<Defect> : N93 -> N94: [%mul = mul i64 %3, %4]
N93 -> N94: [%mul = mul i64 %3, %4] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N35
On edge  : N35 -{%mul11 = mul i64 %5, %6}-> N36
Message  : integer overflow
> Start from entry function: main, At N129 of Function main
> Entering function: good12, On N132 -> N66 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N72 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N73 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N74 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N81 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N82 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N83 of Function good12
> takes the true branch, At N106 of Function good12
> Entering function: printLongLine, On N113 -> N171 (call printLongLine)
> Leaving function: printLongLine, On N170 -> N118 (Return edge from printLongLine to good12)
> Leaving function: good12, On N65 -> N133 (Return edge from good12 to main)
> Entering function: bad12, On N133 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N7 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N8 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N9 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N15 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N16 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N17 of Function bad12
> takes the true branch, At N31 of Function bad12
<Defect> : N35 -> N36: [%mul11 = mul i64 %5, %6]
N35 -> N36: [%mul11 = mul i64 %5, %6] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N21
On edge  : N21 -{%mul = mul i64 %1, %2}-> N22
Message  : integer overflow
> Start from entry function: main, At N129 of Function main
> Entering function: good12, On N132 -> N66 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N72 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N73 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N74 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N81 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N82 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N83 of Function good12
> takes the true branch, At N106 of Function good12
> Entering function: printLongLine, On N113 -> N171 (call printLongLine)
> Leaving function: printLongLine, On N170 -> N118 (Return edge from printLongLine to good12)
> Leaving function: good12, On N65 -> N133 (Return edge from good12 to main)
> Entering function: bad12, On N133 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N7 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N8 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N9 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N15 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N16 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N17 of Function bad12
<Defect> : N21 -> N22: [%mul = mul i64 %1, %2]
N21 -> N22: [%mul = mul i64 %1, %2] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N110
On edge  : N110 -{%mul20 = mul i64 %7, %8}-> N111
Message  : integer underflow
> Start from entry function: main, At N129 of Function main
> Entering function: good12, On N132 -> N66 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N72 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N73 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N74 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N81 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N82 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N83 of Function good12
> takes the true branch, At N106 of Function good12
<Defect> : N110 -> N111: [%mul20 = mul i64 %7, %8]
N110 -> N111: [%mul20 = mul i64 %7, %8] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N93
On edge  : N93 -{%mul = mul i64 %3, %4}-> N94
Message  : integer underflow
> Start from entry function: main, At N129 of Function main
> Entering function: good12, On N132 -> N66 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N72 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N73 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N74 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N81 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N82 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the true branch, At N83 of Function good12
> takes the true branch, At N89 of Function good12
<Defect> : N93 -> N94: [%mul = mul i64 %3, %4]
N93 -> N94: [%mul = mul i64 %3, %4] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N35
On edge  : N35 -{%mul11 = mul i64 %5, %6}-> N36
Message  : integer underflow
> Start from entry function: main, At N129 of Function main
> Entering function: good12, On N132 -> N66 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N72 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N73 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N74 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N81 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N82 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N83 of Function good12
> takes the true branch, At N106 of Function good12
> Entering function: printLongLine, On N113 -> N171 (call printLongLine)
> Leaving function: printLongLine, On N170 -> N118 (Return edge from printLongLine to good12)
> Leaving function: good12, On N65 -> N133 (Return edge from good12 to main)
> Entering function: bad12, On N133 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N7 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N8 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N9 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N15 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N16 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N17 of Function bad12
> takes the true branch, At N31 of Function bad12
<Defect> : N35 -> N36: [%mul11 = mul i64 %5, %6]
N35 -> N36: [%mul11 = mul i64 %5, %6] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N21
On edge  : N21 -{%mul = mul i64 %1, %2}-> N22
Message  : integer underflow
> Start from entry function: main, At N129 of Function main
> Entering function: good12, On N132 -> N66 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N72 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N73 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N74 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N81 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N82 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N83 of Function good12
> takes the true branch, At N106 of Function good12
> Entering function: printLongLine, On N113 -> N171 (call printLongLine)
> Leaving function: printLongLine, On N170 -> N118 (Return edge from printLongLine to good12)
> Leaving function: good12, On N65 -> N133 (Return edge from good12 to main)
> Entering function: bad12, On N133 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N7 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N8 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N9 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N15 -> N60 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N59 -> N16 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N17 of Function bad12
<Defect> : N21 -> N22: [%mul = mul i64 %1, %2]
N21 -> N22: [%mul = mul i64 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 4
	[./190_12.c 129] good12 		[N110 -{%mul20 = mul i64 %7, %8}-> N111]	(integer overflow)
	[./190_12.c 116] good12 		[N93 -{%mul = mul i64 %3, %4}-> N94]	(integer overflow)
	[./190_12.c 87] bad12 		[N35 -{%mul11 = mul i64 %5, %6}-> N36]	(integer overflow)
	[./190_12.c 78] bad12 		[N21 -{%mul = mul i64 %1, %2}-> N22]	(integer overflow)

CWE_191(Integer Underflow): 4
	[./190_12.c 129] good12 		[N110 -{%mul20 = mul i64 %7, %8}-> N111]	(integer underflow)
	[./190_12.c 116] good12 		[N93 -{%mul = mul i64 %3, %4}-> N94]	(integer underflow)
	[./190_12.c 87] bad12 		[N35 -{%mul11 = mul i64 %5, %6}-> N36]	(integer underflow)
	[./190_12.c 78] bad12 		[N21 -{%mul = mul i64 %1, %2}-> N22]	(integer underflow)

Found 8 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad7]
 +bad7
SCC(1): [printLine]
 +printLine
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N102): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N32
On edge  : N32 -{%conv12 = trunc i32 %add to i8}-> N33
Message  : integer overflow
> Start from entry function: main, At N102 of Function main
> Entering function: good7, On N105 -> N46 (call good7)
> takes the true branch, At N53 of Function good7
> takes the false branch, At N60 of Function good7
> Entering function: printHexCharLine, On N68 -> N110 (call printHexCharLine)
> Leaving function: printHexCharLine, On N109 -> N70 (Return edge from printHexCharLine to good7)
> takes the false branch, At N72 of Function good7
> takes the false branch, At N78 of Function good7
> Entering function: printLine, On N100 -> N129 (call printLine)
> takes the true branch, At N135 of Function printLine
> Leaving function: printLine, On N128 -> N91 (Return edge from printLine to good7)
> Leaving function: good7, On N45 -> N106 (Return edge from good7 to main)
> Entering function: bad7, On N106 -> N1 (call bad7)
> takes the true branch, At N8 of Function bad7
> takes the false branch, At N15 of Function bad7
> Entering function: printHexCharLine, On N23 -> N110 (call printHexCharLine)
> Leaving function: printHexCharLine, On N109 -> N25 (Return edge from printHexCharLine to bad7)
> takes the true branch, At N27 of Function bad7
<Defect> : N32 -> N33: [%conv12 = trunc i32 %add to i8]
N32 -> N33: [%conv12 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_7.c 54] bad7 		[N32 -{%conv12 = trunc i32 %add to i8}-> N33]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.147s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N23
On edge  : N23 -{%add = add i32 %1, 1}-> N24
Message  : integer overflow
> Start from entry function: main, At N77 of Function main
> Entering function: good48, On N80 -> N47 (call good48)
> takes the false branch, At N54 of Function good48
> takes the true branch, At N59 of Function good48
> Entering function: printIntLine, On N65 -> N95 (call printIntLine)
> Leaving function: printIntLine, On N94 -> N70 (Return edge from printIntLine to good48)
> Leaving function: good48, On N46 -> N81 (Return edge from good48 to main)
> Entering function: bad48, On N81 -> N1 (call bad48)
> Entering function: badSink, On N9 -> N13 (call badSink)
> takes the true branch, At N20 of Function badSink
<Defect> : N23 -> N24: [%add = add i32 %1, 1]
N23 -> N24: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_48.c 67] badSink 		[N23 -{%add = add i32 %1, 1}-> N24]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad1]
 +bad1
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N36): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N12
On edge  : N12 -{%conv1 = trunc i32 %add to i8}-> N13
Message  : integer overflow
> Start from entry function: main, At N36 of Function main
> Entering function: good1, On N39 -> N19 (call good1)
> Entering function: printHexCharLine, On N32 -> N44 (call printHexCharLine)
> Leaving function: printHexCharLine, On N43 -> N33 (Return edge from printHexCharLine to good1)
> Leaving function: good1, On N18 -> N40 (Return edge from good1 to main)
> Entering function: bad1, On N40 -> N1 (call bad1)
<Defect> : N12 -> N13: [%conv1 = trunc i32 %add to i8]
N12 -> N13: [%conv1 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_1.c 23] bad1 		[N12 -{%conv1 = trunc i32 %add to i8}-> N13]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad5]
 +bad5
SCC(1): [printLine]
 +printLine
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N84): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N22
On edge  : N22 -{%conv6 = trunc i32 %mul to i8}-> N23
Message  : integer overflow
> Start from entry function: main, At N84 of Function main
> Entering function: good5, On N87 -> N37 (call good5)
> takes the true branch, At N44 of Function good5
> takes the false branch, At N49 of Function good5
> takes the true branch, At N55 of Function good5
> takes the false branch, At N59 of Function good5
> Entering function: printLine, On N82 -> N111 (call printLine)
> takes the true branch, At N117 of Function printLine
> Leaving function: printLine, On N110 -> N73 (Return edge from printLine to good5)
> Leaving function: good5, On N36 -> N88 (Return edge from good5 to main)
> Entering function: bad5, On N88 -> N1 (call bad5)
> takes the true branch, At N8 of Function bad5
> takes the true branch, At N13 of Function bad5
> takes the true branch, At N17 of Function bad5
<Defect> : N22 -> N23: [%conv6 = trunc i32 %mul to i8]
N22 -> N23: [%conv6 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_5.c 51] bad5 		[N22 -{%conv6 = trunc i32 %mul to i8}-> N23]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad32]
 +bad32
SCC(1): [printLine]
 +printLine
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N14
On edge  : N14 -{%conv2 = trunc i32 %mul to i8}-> N15
Message  : integer overflow
> Start from entry function: main, At N55 of Function main
> Entering function: good32, On N58 -> N21 (call good32)
> takes the false branch, At N36 of Function good32
> Entering function: printLine, On N53 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good32)
> Leaving function: good32, On N20 -> N59 (Return edge from good32 to main)
> Entering function: bad32, On N59 -> N1 (call bad32)
<Defect> : N14 -> N15: [%conv2 = trunc i32 %mul to i8]
N14 -> N15: [%conv2 = trunc i32 %mul to i8] <--
-- end of trace --
-- start of trace --
Weakness : Signed to Unsigned Conversion Error
At node  : N30
On edge  : N30 -{%conv1 = trunc i64 %conv to i32}-> N31
Message  : Signed to Unsigned Conversion Error
> Start from entry function: main, At N55 of Function main
> Entering function: good32, On N58 -> N21 (call good32)
<Defect> : N30 -> N31: [%conv1 = trunc i64 %conv to i32]
N30 -> N31: [%conv1 = trunc i64 %conv to i32] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_32.c 41] bad32 		[N14 -{%conv2 = trunc i32 %mul to i8}-> N15]	(integer overflow)

CWE_195(Signed to Unsigned Conversion Error): 1
	[./190_32.c 53] good32 		[N30 -{%conv1 = trunc i64 %conv to i32}-> N31]	(Signed to Unsigned Conversion Error)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad9]
 +bad9
SCC(1): [printLine]
 +printLine
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N79): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N25
On edge  : N25 -{%conv7 = trunc i32 %mul to i8}-> N26
Message  : integer overflow
> Start from entry function: main, At N79 of Function main
> Entering function: good9, On N82 -> N34 (call good9)
> takes the false branch, At N45 of Function good9
> takes the false branch, At N58 of Function good9
> Entering function: printLine, On N77 -> N106 (call printLine)
> takes the true branch, At N112 of Function printLine
> Leaving function: printLine, On N105 -> N72 (Return edge from printLine to good9)
> Leaving function: good9, On N33 -> N83 (Return edge from good9 to main)
> Entering function: bad9, On N83 -> N1 (call bad9)
> takes the false branch, At N12 of Function bad9
<Defect> : N25 -> N26: [%conv7 = trunc i32 %mul to i8]
N25 -> N26: [%conv7 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_9.c 55] bad9 		[N25 -{%conv7 = trunc i32 %mul to i8}-> N26]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/190/190_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N18
On edge  : N18 -{%add = add i32 %3, 1}-> N19
Message  : integer overflow
> Start from entry function: main, At N62 of Function main
> Entering function: good49, On N65 -> N39 (call good49)
> Entering function: printIntLine, On N58 -> N80 (call printIntLine)
> Leaving function: printIntLine, On N79 -> N59 (Return edge from printIntLine to good49)
> Leaving function: good49, On N38 -> N66 (Return edge from good49 to main)
> Entering function: bad49, On N66 -> N1 (call bad49)
<Defect> : N18 -> N19: [%add = add i32 %3, 1]
N18 -> N19: [%add = add i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_49.c 70] bad49 		[N18 -{%add = add i32 %3, 1}-> N19]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad21]
 +bad21
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{store i32* %data, i32** %dataPtr1, align 8}-> N42
Message  : use of uninitialized variable
> Start from entry function: main, At N62 of Function main
> Entering function: good21, On N65 -> N32 (call good21)
<Defect> : N40 -> N42: [store i32* %data, i32** %dataPtr1, align 8]
N40 -> N42: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N42
On edge  : N42 -{store i32* %data, i32** %dataPtr2, align 8}-> N43
Message  : use of uninitialized variable
> Start from entry function: main, At N62 of Function main
> Entering function: good21, On N65 -> N32 (call good21)
<Defect> : N42 -> N43: [store i32* %data, i32** %dataPtr2, align 8]
N42 -> N43: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N9
On edge  : N9 -{store i32* %data, i32** %dataPtr1, align 8}-> N11
Message  : use of uninitialized variable
> Start from entry function: main, At N62 of Function main
> Entering function: good21, On N65 -> N32 (call good21)
> Entering function: printIntLine, On N58 -> N70 (call printIntLine)
> Leaving function: printIntLine, On N69 -> N59 (Return edge from printIntLine to good21)
> Leaving function: good21, On N31 -> N66 (Return edge from good21 to main)
> Entering function: bad21, On N66 -> N1 (call bad21)
<Defect> : N9 -> N11: [store i32* %data, i32** %dataPtr1, align 8]
N9 -> N11: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N11
On edge  : N11 -{store i32* %data, i32** %dataPtr2, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N62 of Function main
> Entering function: good21, On N65 -> N32 (call good21)
> Entering function: printIntLine, On N58 -> N70 (call printIntLine)
> Leaving function: printIntLine, On N69 -> N59 (Return edge from printIntLine to good21)
> Leaving function: good21, On N31 -> N66 (Return edge from good21 to main)
> Entering function: bad21, On N66 -> N1 (call bad21)
<Defect> : N11 -> N12: [store i32* %data, i32** %dataPtr2, align 8]
N11 -> N12: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Divide By Zero
At node  : N27
On edge  : N27 -{%div = sdiv i32 100, %7}-> N28
Message  : Divide By Zero
> Start from entry function: main, At N62 of Function main
> Entering function: good21, On N65 -> N32 (call good21)
> Entering function: printIntLine, On N58 -> N70 (call printIntLine)
> Leaving function: printIntLine, On N69 -> N59 (Return edge from printIntLine to good21)
> Leaving function: good21, On N31 -> N66 (Return edge from good21 to main)
> Entering function: bad21, On N66 -> N1 (call bad21)
<Defect> : N27 -> N28: [%div = sdiv i32 100, %7]
N27 -> N28: [%div = sdiv i32 100, %7] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 4
	[./369_21.c 53] good21 		[N40 -{store i32* %data, i32** %dataPtr1, align 8}-> N42]	(use of uninitialized variable)
	[./369_21.c 54] good21 		[N42 -{store i32* %data, i32** %dataPtr2, align 8}-> N43]	(use of uninitialized variable)
	[./369_21.c 28] bad21 		[N9 -{store i32* %data, i32** %dataPtr1, align 8}-> N11]	(use of uninitialized variable)
	[./369_21.c 29] bad21 		[N11 -{store i32* %data, i32** %dataPtr2, align 8}-> N12]	(use of uninitialized variable)

CWE_369(Divide By Zero): 1
	[./369_21.c 41] bad21 		[N27 -{%div = sdiv i32 100, %7}-> N28]	(Divide By Zero)

Found 5 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad12]
 +bad12
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N92): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N17
On edge  : N17 -{%div = sdiv i32 100, %1}-> N18
Message  : Divide By Zero
> Start from entry function: main, At N92 of Function main
> Entering function: good12, On N95 -> N45 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N49 -> N39 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N38 -> N50 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N51 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N58 -> N39 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N38 -> N59 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N60 of Function good12
> takes the false branch, At N73 of Function good12
> Entering function: printLine, On N90 -> N109 (call printLine)
> takes the true branch, At N115 of Function printLine
> Leaving function: printLine, On N108 -> N81 (Return edge from printLine to good12)
> Leaving function: good12, On N44 -> N96 (Return edge from good12 to main)
> Entering function: bad12, On N96 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N39 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N38 -> N6 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N7 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N13 -> N39 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N38 -> N14 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N15 of Function bad12
<Defect> : N17 -> N18: [%div = sdiv i32 100, %1]
N17 -> N18: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_12.c 57] bad12 		[N17 -{%div = sdiv i32 100, %1}-> N18]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N51): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N10
On edge  : N10 -{%div = sdiv i32 100, %1}-> N11
Message  : Divide By Zero
> Start from entry function: main, At N51 of Function main
> Entering function: good18, On N54 -> N29 (call good18)
> takes the false branch, At N39 of Function good18
> Entering function: printLine, On N49 -> N68 (call printLine)
> takes the true branch, At N74 of Function printLine
> Leaving function: printLine, On N67 -> N46 (Return edge from printLine to good18)
> Leaving function: good18, On N28 -> N55 (Return edge from good18 to main)
> Entering function: bad18, On N55 -> N1 (call bad18)
<Defect> : N10 -> N11: [%div = sdiv i32 100, %1]
N10 -> N11: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_18.c 63] bad18 		[N10 -{%div = sdiv i32 100, %1}-> N11]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.096s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N47): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%rem = srem i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N47 of Function main
> Entering function: good40, On N50 -> N27 (call good40)
> takes the false branch, At N35 of Function good40
> Entering function: printLine, On N45 -> N64 (call printLine)
> takes the true branch, At N70 of Function printLine
> Leaving function: printLine, On N63 -> N42 (Return edge from printLine to good40)
> Leaving function: good40, On N26 -> N51 (Return edge from good40 to main)
> Entering function: bad40, On N51 -> N1 (call bad40)
<Defect> : N8 -> N9: [%rem = srem i32 100, %1]
N8 -> N9: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_40.c 71] bad40 		[N8 -{%rem = srem i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad37]
 +bad37
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.095s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N92): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N17
On edge  : N17 -{%rem = srem i32 100, %1}-> N18
Message  : Divide By Zero
> Start from entry function: main, At N92 of Function main
> Entering function: good37, On N95 -> N45 (call good37)
> Entering function: globalReturnsTrueOrFalse, On N49 -> N39 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N38 -> N50 (Return edge from globalReturnsTrueOrFalse to good37)
> takes the false branch, At N51 of Function good37
> Entering function: globalReturnsTrueOrFalse, On N58 -> N39 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N38 -> N59 (Return edge from globalReturnsTrueOrFalse to good37)
> takes the false branch, At N60 of Function good37
> takes the false branch, At N73 of Function good37
> Entering function: printLine, On N90 -> N109 (call printLine)
> takes the true branch, At N115 of Function printLine
> Leaving function: printLine, On N108 -> N81 (Return edge from printLine to good37)
> Leaving function: good37, On N44 -> N96 (Return edge from good37 to main)
> Entering function: bad37, On N96 -> N1 (call bad37)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N39 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N38 -> N6 (Return edge from globalReturnsTrueOrFalse to bad37)
> takes the false branch, At N7 of Function bad37
> Entering function: globalReturnsTrueOrFalse, On N13 -> N39 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N38 -> N14 (Return edge from globalReturnsTrueOrFalse to bad37)
> takes the true branch, At N15 of Function bad37
<Defect> : N17 -> N18: [%rem = srem i32 100, %1]
N17 -> N18: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_37.c 58] bad37 		[N17 -{%rem = srem i32 100, %1}-> N18]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N54): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N16
On edge  : N16 -{%div = sdiv i32 100, %3}-> N17
Message  : Divide By Zero
> Start from entry function: main, At N54 of Function main
> Entering function: good20, On N57 -> N35 (call good20)
> Entering function: printIntLine, On N50 -> N62 (call printIntLine)
> Leaving function: printIntLine, On N61 -> N51 (Return edge from printIntLine to good20)
> Leaving function: good20, On N34 -> N58 (Return edge from good20 to main)
> Entering function: bad20, On N58 -> N1 (call bad20)
<Defect> : N16 -> N17: [%div = sdiv i32 100, %3]
N16 -> N17: [%div = sdiv i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_20.c 64] bad20 		[N16 -{%div = sdiv i32 100, %3}-> N17]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad25]
 +bad25
SCC(1): [goodG2BSink]
 +goodG2BSink
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N46): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N19
On edge  : N19 -{%div = sdiv i32 100, %1}-> N20
Message  : Divide By Zero
> Start from entry function: main, At N46 of Function main
> Entering function: good25, On N49 -> N24 (call good25)
> Entering function: goodG2BSink, On N31 -> N35 (call goodG2BSink)
> Entering function: printIntLine, On N42 -> N54 (call printIntLine)
> Leaving function: printIntLine, On N53 -> N43 (Return edge from printIntLine to goodG2BSink)
> Leaving function: goodG2BSink, On N34 -> N32 (Return edge from goodG2BSink to good25)
> Leaving function: good25, On N23 -> N50 (Return edge from good25 to main)
> Entering function: bad25, On N50 -> N1 (call bad25)
> Entering function: badSink, On N9 -> N13 (call badSink)
<Defect> : N19 -> N20: [%div = sdiv i32 100, %1]
N19 -> N20: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_25.c 33] badSink 		[N19 -{%div = sdiv i32 100, %1}-> N20]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.132s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N54): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N16
On edge  : N16 -{%rem = srem i32 100, %3}-> N17
Message  : Divide By Zero
> Start from entry function: main, At N54 of Function main
> Entering function: good45, On N57 -> N35 (call good45)
> Entering function: printIntLine, On N50 -> N62 (call printIntLine)
> Leaving function: printIntLine, On N61 -> N51 (Return edge from printIntLine to good45)
> Leaving function: good45, On N34 -> N58 (Return edge from good45 to main)
> Entering function: bad45, On N58 -> N1 (call bad45)
<Defect> : N16 -> N17: [%rem = srem i32 100, %3]
N16 -> N17: [%rem = srem i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_45.c 69] bad45 		[N16 -{%rem = srem i32 100, %3}-> N17]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad34]
 +bad34
SCC(1): [printLine]
 +printLine
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%rem = srem i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N33 of Function main
> Entering function: good34, On N36 -> N13 (call good34)
> takes the false branch, At N21 of Function good34
> Entering function: printLine, On N31 -> N50 (call printLine)
> takes the true branch, At N56 of Function printLine
> Leaving function: printLine, On N49 -> N28 (Return edge from printLine to good34)
> Leaving function: good34, On N12 -> N37 (Return edge from good34 to main)
> Entering function: bad34, On N37 -> N1 (call bad34)
<Defect> : N8 -> N9: [%rem = srem i32 100, %1]
N8 -> N9: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_34.c 47] bad34 		[N8 -{%rem = srem i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad7]
 +bad7
SCC(1): [printLine]
 +printLine
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%div = sdiv i32 100, %3}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N59 of Function main
> Entering function: bad7, On N62 -> N1 (call bad7)
> takes the true branch, At N7 of Function bad7
> takes the true branch, At N13 of Function bad7
<Defect> : N15 -> N16: [%div = sdiv i32 100, %3]
N15 -> N16: [%div = sdiv i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_7.c 40] bad7 		[N15 -{%div = sdiv i32 100, %3}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad6]
 +bad6
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.09s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N24): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%div = sdiv i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N24 of Function main
> Entering function: bad6, On N27 -> N1 (call bad6)
<Defect> : N8 -> N9: [%div = sdiv i32 100, %1]
N8 -> N9: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_6.c 40] bad6 		[N8 -{%div = sdiv i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N73): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%rem = srem i32 100, %3}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N73 of Function main
> Entering function: good39, On N76 -> N39 (call good39)
> takes the true branch, At N45 of Function good39
> takes the false branch, At N51 of Function good39
> takes the false branch, At N56 of Function good39
> Entering function: printLine, On N71 -> N90 (call printLine)
> takes the true branch, At N96 of Function printLine
> Leaving function: printLine, On N89 -> N64 (Return edge from printLine to good39)
> Leaving function: good39, On N38 -> N77 (Return edge from good39 to main)
> Entering function: bad39, On N77 -> N1 (call bad39)
> takes the true branch, At N7 of Function bad39
> takes the true branch, At N13 of Function bad39
<Defect> : N15 -> N16: [%rem = srem i32 100, %3]
N15 -> N16: [%rem = srem i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_39.c 64] bad39 		[N15 -{%rem = srem i32 100, %3}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad47]
 +bad47
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N18
On edge  : N18 -{%rem = srem i32 100, %3}-> N19
Message  : Divide By Zero
> Start from entry function: main, At N44 of Function main
> Entering function: good47, On N47 -> N23 (call good47)
> Entering function: printIntLine, On N40 -> N52 (call printIntLine)
> Leaving function: printIntLine, On N51 -> N41 (Return edge from printIntLine to good47)
> Leaving function: good47, On N22 -> N48 (Return edge from good47 to main)
> Entering function: bad47, On N48 -> N1 (call bad47)
<Defect> : N18 -> N19: [%rem = srem i32 100, %3]
N18 -> N19: [%rem = srem i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_47.c 44] bad47 		[N18 -{%rem = srem i32 100, %3}-> N19]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [goodB2G1Sink]
 +goodB2G1Sink
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N21
On edge  : N21 -{%rem = srem i32 100, %1}-> N22
Message  : Divide By Zero
> Start from entry function: main, At N81 of Function main
> Entering function: good44, On N84 -> N43 (call good44)
> Entering function: goodB2G1Sink, On N51 -> N55 (call goodB2G1Sink)
> takes the false branch, At N61 of Function goodB2G1Sink
> takes the false branch, At N66 of Function goodB2G1Sink
> Entering function: printLine, On N79 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N74 (Return edge from printLine to goodB2G1Sink)
> Leaving function: goodB2G1Sink, On N54 -> N52 (Return edge from goodB2G1Sink to good44)
> Leaving function: good44, On N42 -> N85 (Return edge from good44 to main)
> Entering function: bad44, On N85 -> N1 (call bad44)
> Entering function: badSink, On N9 -> N13 (call badSink)
> takes the true branch, At N19 of Function badSink
<Defect> : N21 -> N22: [%rem = srem i32 100, %1]
N21 -> N22: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_44.c 56] badSink 		[N21 -{%rem = srem i32 100, %1}-> N22]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N38): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%rem = srem i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N38 of Function main
> Entering function: good29, On N41 -> N27 (call good29)
> Entering function: printIntLine, On N34 -> N46 (call printIntLine)
> Leaving function: printIntLine, On N45 -> N35 (Return edge from printIntLine to good29)
> Leaving function: good29, On N26 -> N42 (Return edge from good29 to main)
> Entering function: bad29, On N42 -> N1 (call bad29)
<Defect> : N8 -> N9: [%rem = srem i32 100, %1]
N8 -> N9: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_29.c 63] bad29 		[N8 -{%rem = srem i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N103): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N27
On edge  : N27 -{%rem = srem i32 100, %4}-> N28
Message  : Divide By Zero
> Start from entry function: main, At N103 of Function main
> Entering function: good42, On N106 -> N55 (call good42)
> takes the true branch, At N67 of Function good42
> takes the false branch, At N67 of Function good42
> takes the true branch, At N79 of Function good42
> takes the true branch, At N82 of Function good42
> Entering function: printIntLine, On N85 -> N111 (call printIntLine)
> Leaving function: printIntLine, On N110 -> N90 (Return edge from printIntLine to good42)
> takes the false branch, At N79 of Function good42
> Leaving function: good42, On N54 -> N107 (Return edge from good42 to main)
> Entering function: bad42, On N107 -> N1 (call bad42)
> takes the true branch, At N13 of Function bad42
> takes the false branch, At N13 of Function bad42
> takes the true branch, At N25 of Function bad42
<Defect> : N27 -> N28: [%rem = srem i32 100, %4]
N27 -> N28: [%rem = srem i32 100, %4] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_42.c 65] bad42 		[N27 -{%rem = srem i32 100, %4}-> N28]	(Divide By Zero)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [badSource]
 +badSource
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad49]
 +bad49
SCC(1): [goodG2BSource]
 +goodG2BSource
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N46): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N9
On edge  : N9 -{%rem = srem i32 100, %1}-> N10
Message  : Divide By Zero
> Start from entry function: main, At N46 of Function main
> Entering function: good49, On N49 -> N24 (call good49)
> Entering function: goodG2BSource, On N29 -> N37 (call goodG2BSource)
> Leaving function: goodG2BSource, On N36 -> N30 (Return edge from goodG2BSource to good49)
> Entering function: printIntLine, On N33 -> N54 (call printIntLine)
> Leaving function: printIntLine, On N53 -> N34 (Return edge from printIntLine to good49)
> Leaving function: good49, On N23 -> N50 (Return edge from good49 to main)
> Entering function: bad49, On N50 -> N1 (call bad49)
> Entering function: badSource, On N6 -> N14 (call badSource)
> Leaving function: badSource, On N13 -> N7 (Return edge from badSource to bad49)
<Defect> : N9 -> N10: [%rem = srem i32 100, %1]
N9 -> N10: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_49.c 40] bad49 		[N9 -{%rem = srem i32 100, %1}-> N10]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad2]
 +bad2
SCC(1): [printLine]
 +printLine
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%div = sdiv i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N33 of Function main
> Entering function: good2, On N36 -> N13 (call good2)
> takes the false branch, At N21 of Function good2
> Entering function: printLine, On N31 -> N50 (call printLine)
> takes the true branch, At N56 of Function printLine
> Leaving function: printLine, On N49 -> N28 (Return edge from printLine to good2)
> Leaving function: good2, On N12 -> N37 (Return edge from good2 to main)
> Entering function: bad2, On N37 -> N1 (call bad2)
<Defect> : N8 -> N9: [%div = sdiv i32 100, %1]
N8 -> N9: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_2.c 36] bad2 		[N8 -{%div = sdiv i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N47): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%rem = srem i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N47 of Function main
> Entering function: good38, On N50 -> N27 (call good38)
> takes the false branch, At N35 of Function good38
> Entering function: printLine, On N45 -> N64 (call printLine)
> takes the true branch, At N70 of Function printLine
> Leaving function: printLine, On N63 -> N42 (Return edge from printLine to good38)
> Leaving function: good38, On N26 -> N51 (Return edge from good38 to main)
> Entering function: bad38, On N51 -> N1 (call bad38)
<Defect> : N8 -> N9: [%rem = srem i32 100, %1]
N8 -> N9: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_38.c 64] bad38 		[N8 -{%rem = srem i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N39): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%div = sdiv i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N39 of Function main
> Entering function: good13, On N42 -> N19 (call good13)
> takes the false branch, At N27 of Function good13
> Entering function: printLine, On N37 -> N56 (call printLine)
> takes the true branch, At N62 of Function printLine
> Leaving function: printLine, On N55 -> N34 (Return edge from printLine to good13)
> Leaving function: good13, On N18 -> N43 (Return edge from good13 to main)
> Entering function: bad13, On N43 -> N1 (call bad13)
<Defect> : N8 -> N9: [%div = sdiv i32 100, %1]
N8 -> N9: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_13.c 52] bad13 		[N8 -{%div = sdiv i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad27]
 +bad27
SCC(1): [printLine]
 +printLine
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.092s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%rem = srem i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N33 of Function main
> Entering function: good27, On N36 -> N13 (call good27)
> takes the false branch, At N21 of Function good27
> Entering function: printLine, On N31 -> N50 (call printLine)
> takes the true branch, At N56 of Function printLine
> Leaving function: printLine, On N49 -> N28 (Return edge from printLine to good27)
> Leaving function: good27, On N12 -> N37 (Return edge from good27 to main)
> Entering function: bad27, On N37 -> N1 (call bad27)
<Defect> : N8 -> N9: [%rem = srem i32 100, %1]
N8 -> N9: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_27.c 40] bad27 		[N8 -{%rem = srem i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad35]
 +bad35
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%rem = srem i32 100, %3}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N59 of Function main
> Entering function: good35, On N62 -> N25 (call good35)
> takes the true branch, At N31 of Function good35
> takes the false branch, At N37 of Function good35
> takes the false branch, At N42 of Function good35
> Entering function: printLine, On N57 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N50 (Return edge from printLine to good35)
> Leaving function: good35, On N24 -> N63 (Return edge from good35 to main)
> Entering function: bad35, On N63 -> N1 (call bad35)
> takes the true branch, At N7 of Function bad35
> takes the true branch, At N13 of Function bad35
<Defect> : N15 -> N16: [%rem = srem i32 100, %3]
N15 -> N16: [%rem = srem i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_35.c 58] bad35 		[N15 -{%rem = srem i32 100, %3}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad33]
 +bad33
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.123s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%rem = srem i32 100, %1}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N59 of Function main
> Entering function: good33, On N62 -> N25 (call good33)
> Entering function: staticReturnsTrue, On N29 -> N95 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N94 -> N30 (Return edge from staticReturnsTrue to good33)
> takes the true branch, At N31 of Function good33
> Entering function: staticReturnsFalse, On N35 -> N91 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N90 -> N36 (Return edge from staticReturnsFalse to good33)
> takes the false branch, At N37 of Function good33
> takes the false branch, At N42 of Function good33
> Entering function: printLine, On N57 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N50 (Return edge from printLine to good33)
> Leaving function: good33, On N24 -> N63 (Return edge from good33 to main)
> Entering function: bad33, On N63 -> N1 (call bad33)
> Entering function: staticReturnsTrue, On N5 -> N95 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N94 -> N6 (Return edge from staticReturnsTrue to bad33)
> takes the true branch, At N7 of Function bad33
> Entering function: staticReturnsTrue, On N11 -> N95 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N94 -> N12 (Return edge from staticReturnsTrue to bad33)
> takes the true branch, At N13 of Function bad33
<Defect> : N15 -> N16: [%rem = srem i32 100, %1]
N15 -> N16: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_33.c 46] bad33 		[N15 -{%rem = srem i32 100, %1}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad50]
 +bad50
SCC(1): [goodG2BSink]
 +goodG2BSink
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.14s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N46): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N19
On edge  : N19 -{%rem = srem i32 100, %1}-> N20
Message  : Divide By Zero
> Start from entry function: main, At N46 of Function main
> Entering function: good50, On N49 -> N24 (call good50)
> Entering function: goodG2BSink, On N31 -> N35 (call goodG2BSink)
> Entering function: printIntLine, On N42 -> N54 (call printIntLine)
> Leaving function: printIntLine, On N53 -> N43 (Return edge from printIntLine to goodG2BSink)
> Leaving function: goodG2BSink, On N34 -> N32 (Return edge from goodG2BSink to good50)
> Leaving function: good50, On N23 -> N50 (Return edge from good50 to main)
> Entering function: bad50, On N50 -> N1 (call bad50)
> Entering function: badSink, On N9 -> N13 (call badSink)
<Defect> : N19 -> N20: [%rem = srem i32 100, %1]
N19 -> N20: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_50.c 33] badSink 		[N19 -{%rem = srem i32 100, %1}-> N20]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad30]
 +bad30
SCC(1): [printLine]
 +printLine
SCC(1): [goodG2B]
 +goodG2B
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%rem = srem i32 100, %3}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N55 of Function main
> Entering function: good30, On N58 -> N25 (call good30)
> Entering function: goodG2B, On N25 -> N30 (call goodG2B)
> takes the false branch, At N36 of Function goodG2B
> takes the true branch, At N43 of Function goodG2B
> Entering function: printIntLine, On N46 -> N63 (call printIntLine)
> Leaving function: printIntLine, On N62 -> N48 (Return edge from printIntLine to goodG2B)
> Leaving function: goodG2B, On N29 -> N27 (Return edge from goodG2B to good30)
> Leaving function: good30, On N24 -> N59 (Return edge from good30 to main)
> Entering function: bad30, On N59 -> N1 (call bad30)
> takes the true branch, At N7 of Function bad30
> takes the true branch, At N13 of Function bad30
<Defect> : N15 -> N16: [%rem = srem i32 100, %3]
N15 -> N16: [%rem = srem i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_30.c 41] bad30 		[N15 -{%rem = srem i32 100, %3}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad4]
 +bad4
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N24): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%div = sdiv i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N24 of Function main
> Entering function: good4, On N27 -> N13 (call good4)
> Entering function: printIntLine, On N20 -> N32 (call printIntLine)
> Leaving function: printIntLine, On N31 -> N21 (Return edge from printIntLine to good4)
> Leaving function: good4, On N12 -> N28 (Return edge from good4 to main)
> Entering function: bad4, On N28 -> N1 (call bad4)
<Defect> : N8 -> N9: [%div = sdiv i32 100, %1]
N8 -> N9: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_4.c 42] bad4 		[N8 -{%div = sdiv i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [badSource]
 +badSource
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad24]
 +bad24
SCC(1): [goodG2BSource]
 +goodG2BSource
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N46): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N9
On edge  : N9 -{%div = sdiv i32 100, %1}-> N10
Message  : Divide By Zero
> Start from entry function: main, At N46 of Function main
> Entering function: good24, On N49 -> N24 (call good24)
> Entering function: goodG2BSource, On N29 -> N37 (call goodG2BSource)
> Leaving function: goodG2BSource, On N36 -> N30 (Return edge from goodG2BSource to good24)
> Entering function: printIntLine, On N33 -> N54 (call printIntLine)
> Leaving function: printIntLine, On N53 -> N34 (Return edge from printIntLine to good24)
> Leaving function: good24, On N23 -> N50 (Return edge from good24 to main)
> Entering function: bad24, On N50 -> N1 (call bad24)
> Entering function: badSource, On N6 -> N14 (call badSource)
> Leaving function: badSource, On N13 -> N7 (Return edge from badSource to bad24)
<Defect> : N9 -> N10: [%div = sdiv i32 100, %1]
N9 -> N10: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_24.c 40] bad24 		[N9 -{%div = sdiv i32 100, %1}-> N10]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad31]
 +bad31
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.089s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N24): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%rem = srem i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N24 of Function main
> Entering function: good31, On N27 -> N13 (call good31)
> Entering function: printIntLine, On N20 -> N32 (call printIntLine)
> Leaving function: printIntLine, On N31 -> N21 (Return edge from printIntLine to good31)
> Leaving function: good31, On N12 -> N28 (Return edge from good31 to main)
> Entering function: bad31, On N28 -> N1 (call bad31)
<Defect> : N8 -> N9: [%rem = srem i32 100, %1]
N8 -> N9: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_31.c 45] bad31 		[N8 -{%rem = srem i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%div = sdiv i32 100, %3}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N65 of Function main
> Entering function: good14, On N68 -> N31 (call good14)
> takes the true branch, At N37 of Function good14
> takes the false branch, At N43 of Function good14
> takes the false branch, At N48 of Function good14
> Entering function: printLine, On N63 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N56 (Return edge from printLine to good14)
> Leaving function: good14, On N30 -> N69 (Return edge from good14 to main)
> Entering function: bad14, On N69 -> N1 (call bad14)
> takes the true branch, At N7 of Function bad14
> takes the true branch, At N13 of Function bad14
<Defect> : N15 -> N16: [%div = sdiv i32 100, %3]
N15 -> N16: [%div = sdiv i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_14.c 53] bad14 		[N15 -{%div = sdiv i32 100, %3}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N11
On edge  : N11 -{%rem = srem i32 100, %1}-> N12
Message  : Divide By Zero
> Start from entry function: main, At N55 of Function main
> Entering function: good41, On N58 -> N31 (call good41)
> takes the false branch, At N42 of Function good41
> Entering function: printLine, On N53 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N50 (Return edge from printLine to good41)
> Leaving function: good41, On N30 -> N59 (Return edge from good41 to main)
> Entering function: bad41, On N59 -> N1 (call bad41)
<Defect> : N11 -> N12: [%rem = srem i32 100, %1]
N11 -> N12: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_41.c 65] bad41 		[N11 -{%rem = srem i32 100, %1}-> N12]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%div = sdiv i32 100, %1}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N59 of Function main
> Entering function: bad8, On N62 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N95 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N94 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N7 of Function bad8
> Entering function: staticReturnsTrue, On N11 -> N95 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N94 -> N12 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N13 of Function bad8
<Defect> : N15 -> N16: [%div = sdiv i32 100, %1]
N15 -> N16: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_8.c 53] bad8 		[N15 -{%div = sdiv i32 100, %1}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad28]
 +bad28
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N24): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%rem = srem i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N24 of Function main
> Entering function: good28, On N27 -> N13 (call good28)
> Entering function: printIntLine, On N20 -> N32 (call printIntLine)
> Leaving function: printIntLine, On N31 -> N21 (Return edge from printIntLine to good28)
> Leaving function: good28, On N12 -> N28 (Return edge from good28 to main)
> Entering function: bad28, On N28 -> N1 (call bad28)
<Defect> : N8 -> N9: [%rem = srem i32 100, %1]
N8 -> N9: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_28.c 43] bad28 		[N8 -{%rem = srem i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.165s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N51): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N10
On edge  : N10 -{%rem = srem i32 100, %1}-> N11
Message  : Divide By Zero
> Start from entry function: main, At N51 of Function main
> Entering function: good43, On N54 -> N29 (call good43)
> takes the false branch, At N39 of Function good43
> Entering function: printLine, On N49 -> N68 (call printLine)
> takes the true branch, At N74 of Function printLine
> Leaving function: printLine, On N67 -> N46 (Return edge from printLine to good43)
> Leaving function: good43, On N28 -> N55 (Return edge from good43 to main)
> Entering function: bad43, On N55 -> N1 (call bad43)
<Defect> : N10 -> N11: [%rem = srem i32 100, %1]
N10 -> N11: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_43.c 63] bad43 		[N10 -{%rem = srem i32 100, %1}-> N11]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad10]
 +bad10
SCC(1): [printLine]
 +printLine
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%div = sdiv i32 100, %3}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N59 of Function main
> Entering function: good10, On N62 -> N25 (call good10)
> takes the true branch, At N31 of Function good10
> takes the false branch, At N37 of Function good10
> takes the false branch, At N42 of Function good10
> Entering function: printLine, On N57 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N50 (Return edge from printLine to good10)
> Leaving function: good10, On N24 -> N63 (Return edge from good10 to main)
> Entering function: bad10, On N63 -> N1 (call bad10)
> takes the true branch, At N7 of Function bad10
> takes the true branch, At N13 of Function bad10
<Defect> : N15 -> N16: [%div = sdiv i32 100, %3]
N15 -> N16: [%div = sdiv i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_10.c 55] bad10 		[N15 -{%div = sdiv i32 100, %3}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad5]
 +bad5
SCC(1): [printLine]
 +printLine
SCC(1): [goodG2B]
 +goodG2B
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%div = sdiv i32 100, %3}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N55 of Function main
> Entering function: bad5, On N58 -> N1 (call bad5)
> takes the true branch, At N7 of Function bad5
> takes the true branch, At N13 of Function bad5
<Defect> : N15 -> N16: [%div = sdiv i32 100, %3]
N15 -> N16: [%div = sdiv i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_5.c 41] bad5 		[N15 -{%div = sdiv i32 100, %3}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad26]
 +bad26
SCC(1): [printLine]
 +printLine
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%rem = srem i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N33 of Function main
> Entering function: good26, On N36 -> N13 (call good26)
> takes the false branch, At N21 of Function good26
> Entering function: printLine, On N31 -> N50 (call printLine)
> takes the true branch, At N56 of Function printLine
> Leaving function: printLine, On N49 -> N28 (Return edge from printLine to good26)
> Leaving function: good26, On N12 -> N37 (Return edge from good26 to main)
> Entering function: bad26, On N37 -> N1 (call bad26)
<Defect> : N8 -> N9: [%rem = srem i32 100, %1]
N8 -> N9: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_26.c 35] bad26 		[N8 -{%rem = srem i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N103): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N27
On edge  : N27 -{%div = sdiv i32 100, %4}-> N28
Message  : Divide By Zero
> Start from entry function: main, At N103 of Function main
> Entering function: good17, On N106 -> N55 (call good17)
> takes the true branch, At N67 of Function good17
> takes the false branch, At N67 of Function good17
> takes the true branch, At N79 of Function good17
> takes the true branch, At N82 of Function good17
> Entering function: printIntLine, On N85 -> N111 (call printIntLine)
> Leaving function: printIntLine, On N110 -> N90 (Return edge from printIntLine to good17)
> takes the false branch, At N79 of Function good17
> Leaving function: good17, On N54 -> N107 (Return edge from good17 to main)
> Entering function: bad17, On N107 -> N1 (call bad17)
> takes the true branch, At N13 of Function bad17
> takes the false branch, At N13 of Function bad17
> takes the true branch, At N25 of Function bad17
<Defect> : N27 -> N28: [%div = sdiv i32 100, %4]
N27 -> N28: [%div = sdiv i32 100, %4] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_17.c 65] bad17 		[N27 -{%div = sdiv i32 100, %4}-> N28]	(Divide By Zero)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad1]
 +bad1
SCC(1): [printLine]
 +printLine
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%div = sdiv i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N33 of Function main
> Entering function: good1, On N36 -> N13 (call good1)
> takes the false branch, At N21 of Function good1
> Entering function: printLine, On N31 -> N50 (call printLine)
> takes the true branch, At N56 of Function printLine
> Leaving function: printLine, On N49 -> N28 (Return edge from printLine to good1)
> Leaving function: good1, On N12 -> N37 (Return edge from good1 to main)
> Entering function: bad1, On N37 -> N1 (call bad1)
<Defect> : N8 -> N9: [%div = sdiv i32 100, %1]
N8 -> N9: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_1.c 31] bad1 		[N8 -{%div = sdiv i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N67): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%rem = srem i32 100, %1}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N67 of Function main
> Entering function: good36, On N70 -> N33 (call good36)
> Entering function: globalReturnsTrue, On N37 -> N29 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N28 -> N38 (Return edge from globalReturnsTrue to good36)
> takes the true branch, At N39 of Function good36
> Entering function: globalReturnsFalse, On N43 -> N25 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N24 -> N44 (Return edge from globalReturnsFalse to good36)
> takes the false branch, At N45 of Function good36
> takes the false branch, At N50 of Function good36
> Entering function: printLine, On N65 -> N84 (call printLine)
> takes the true branch, At N90 of Function printLine
> Leaving function: printLine, On N83 -> N58 (Return edge from printLine to good36)
> Leaving function: good36, On N32 -> N71 (Return edge from good36 to main)
> Entering function: bad36, On N71 -> N1 (call bad36)
> Entering function: globalReturnsTrue, On N5 -> N29 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N28 -> N6 (Return edge from globalReturnsTrue to bad36)
> takes the true branch, At N7 of Function bad36
> Entering function: globalReturnsTrue, On N11 -> N29 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N28 -> N12 (Return edge from globalReturnsTrue to bad36)
> takes the true branch, At N13 of Function bad36
<Defect> : N15 -> N16: [%rem = srem i32 100, %1]
N15 -> N16: [%rem = srem i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_36.c 55] bad36 		[N15 -{%rem = srem i32 100, %1}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
2 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.085s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad48]
 +bad48
SCC(1): [goodG2BSink]
 +goodG2BSink
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N42): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N17
On edge  : N17 -{%rem = srem i32 100, %0}-> N18
Message  : Divide By Zero
> Start from entry function: main, At N42 of Function main
> Entering function: good48, On N45 -> N22 (call good48)
> Entering function: goodG2BSink, On N28 -> N32 (call goodG2BSink)
> Entering function: printIntLine, On N38 -> N50 (call printIntLine)
> Leaving function: printIntLine, On N49 -> N39 (Return edge from printIntLine to goodG2BSink)
> Leaving function: goodG2BSink, On N31 -> N29 (Return edge from goodG2BSink to good48)
> Leaving function: good48, On N21 -> N46 (Return edge from good48 to main)
> Entering function: bad48, On N46 -> N1 (call bad48)
> Entering function: badSink, On N8 -> N12 (call badSink)
<Defect> : N17 -> N18: [%rem = srem i32 100, %0]
N17 -> N18: [%rem = srem i32 100, %0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_48.c 27] badSink 		[N17 -{%rem = srem i32 100, %0}-> N18]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.096s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N67): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%div = sdiv i32 100, %1}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N67 of Function main
> Entering function: good11, On N70 -> N33 (call good11)
> Entering function: globalReturnsTrue, On N37 -> N29 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N28 -> N38 (Return edge from globalReturnsTrue to good11)
> takes the true branch, At N39 of Function good11
> Entering function: globalReturnsFalse, On N43 -> N25 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N24 -> N44 (Return edge from globalReturnsFalse to good11)
> takes the false branch, At N45 of Function good11
> takes the false branch, At N50 of Function good11
> Entering function: printLine, On N65 -> N84 (call printLine)
> takes the true branch, At N90 of Function printLine
> Leaving function: printLine, On N83 -> N58 (Return edge from printLine to good11)
> Leaving function: good11, On N32 -> N71 (Return edge from good11 to main)
> Entering function: bad11, On N71 -> N1 (call bad11)
> Entering function: globalReturnsTrue, On N5 -> N29 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N28 -> N6 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N7 of Function bad11
> Entering function: globalReturnsTrue, On N11 -> N29 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N28 -> N12 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N13 of Function bad11
<Defect> : N15 -> N16: [%div = sdiv i32 100, %1]
N15 -> N16: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_11.c 57] bad11 		[N15 -{%div = sdiv i32 100, %1}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad32]
 +bad32
SCC(1): [printLine]
 +printLine
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N15
On edge  : N15 -{%rem = srem i32 100, %3}-> N16
Message  : Divide By Zero
> Start from entry function: main, At N59 of Function main
> Entering function: good32, On N62 -> N25 (call good32)
> takes the true branch, At N31 of Function good32
> takes the false branch, At N37 of Function good32
> takes the false branch, At N42 of Function good32
> Entering function: printLine, On N57 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N50 (Return edge from printLine to good32)
> Leaving function: good32, On N24 -> N63 (Return edge from good32 to main)
> Entering function: bad32, On N63 -> N1 (call bad32)
> takes the true branch, At N7 of Function bad32
> takes the true branch, At N13 of Function bad32
<Defect> : N15 -> N16: [%rem = srem i32 100, %3]
N15 -> N16: [%rem = srem i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_32.c 46] bad32 		[N15 -{%rem = srem i32 100, %3}-> N16]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N47): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N11
On edge  : N11 -{%div = sdiv i32 100, %1}-> N12
Message  : Divide By Zero
> Start from entry function: main, At N47 of Function main
> Entering function: good16, On N50 -> N23 (call good16)
> takes the false branch, At N34 of Function good16
> Entering function: printLine, On N45 -> N64 (call printLine)
> takes the true branch, At N70 of Function printLine
> Leaving function: printLine, On N63 -> N42 (Return edge from printLine to good16)
> Leaving function: good16, On N22 -> N51 (Return edge from good16 to main)
> Entering function: bad16, On N51 -> N1 (call bad16)
<Defect> : N11 -> N12: [%div = sdiv i32 100, %1]
N11 -> N12: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_16.c 53] bad16 		[N11 -{%div = sdiv i32 100, %1}-> N12]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{store i32* %data, i32** %dataPtr1, align 8}-> N42
Message  : use of uninitialized variable
> Start from entry function: main, At N62 of Function main
> Entering function: good46, On N65 -> N32 (call good46)
<Defect> : N40 -> N42: [store i32* %data, i32** %dataPtr1, align 8]
N40 -> N42: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N42
On edge  : N42 -{store i32* %data, i32** %dataPtr2, align 8}-> N43
Message  : use of uninitialized variable
> Start from entry function: main, At N62 of Function main
> Entering function: good46, On N65 -> N32 (call good46)
<Defect> : N42 -> N43: [store i32* %data, i32** %dataPtr2, align 8]
N42 -> N43: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N9
On edge  : N9 -{store i32* %data, i32** %dataPtr1, align 8}-> N11
Message  : use of uninitialized variable
> Start from entry function: main, At N62 of Function main
> Entering function: good46, On N65 -> N32 (call good46)
> Entering function: printIntLine, On N58 -> N70 (call printIntLine)
> Leaving function: printIntLine, On N69 -> N59 (Return edge from printIntLine to good46)
> Leaving function: good46, On N31 -> N66 (Return edge from good46 to main)
> Entering function: bad46, On N66 -> N1 (call bad46)
<Defect> : N9 -> N11: [store i32* %data, i32** %dataPtr1, align 8]
N9 -> N11: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N11
On edge  : N11 -{store i32* %data, i32** %dataPtr2, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N62 of Function main
> Entering function: good46, On N65 -> N32 (call good46)
> Entering function: printIntLine, On N58 -> N70 (call printIntLine)
> Leaving function: printIntLine, On N69 -> N59 (Return edge from printIntLine to good46)
> Leaving function: good46, On N31 -> N66 (Return edge from good46 to main)
> Entering function: bad46, On N66 -> N1 (call bad46)
<Defect> : N11 -> N12: [store i32* %data, i32** %dataPtr2, align 8]
N11 -> N12: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Divide By Zero
At node  : N27
On edge  : N27 -{%rem = srem i32 100, %7}-> N28
Message  : Divide By Zero
> Start from entry function: main, At N62 of Function main
> Entering function: good46, On N65 -> N32 (call good46)
> Entering function: printIntLine, On N58 -> N70 (call printIntLine)
> Leaving function: printIntLine, On N69 -> N59 (Return edge from printIntLine to good46)
> Leaving function: good46, On N31 -> N66 (Return edge from good46 to main)
> Entering function: bad46, On N66 -> N1 (call bad46)
<Defect> : N27 -> N28: [%rem = srem i32 100, %7]
N27 -> N28: [%rem = srem i32 100, %7] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 4
	[./369_46.c 53] good46 		[N40 -{store i32* %data, i32** %dataPtr1, align 8}-> N42]	(use of uninitialized variable)
	[./369_46.c 54] good46 		[N42 -{store i32* %data, i32** %dataPtr2, align 8}-> N43]	(use of uninitialized variable)
	[./369_46.c 28] bad46 		[N9 -{store i32* %data, i32** %dataPtr1, align 8}-> N11]	(use of uninitialized variable)
	[./369_46.c 29] bad46 		[N11 -{store i32* %data, i32** %dataPtr2, align 8}-> N12]	(use of uninitialized variable)

CWE_369(Divide By Zero): 1
	[./369_46.c 41] bad46 		[N27 -{%rem = srem i32 100, %7}-> N28]	(Divide By Zero)

Found 5 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad22]
 +bad22
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.092s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N18
On edge  : N18 -{%div = sdiv i32 100, %3}-> N19
Message  : Divide By Zero
> Start from entry function: main, At N44 of Function main
> Entering function: good22, On N47 -> N23 (call good22)
> Entering function: printIntLine, On N40 -> N52 (call printIntLine)
> Leaving function: printIntLine, On N51 -> N41 (Return edge from printIntLine to good22)
> Leaving function: good22, On N22 -> N48 (Return edge from good22 to main)
> Entering function: bad22, On N48 -> N1 (call bad22)
<Defect> : N18 -> N19: [%div = sdiv i32 100, %3]
N18 -> N19: [%div = sdiv i32 100, %3] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_22.c 44] bad22 		[N18 -{%div = sdiv i32 100, %3}-> N19]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad23]
 +bad23
SCC(1): [goodG2BSink]
 +goodG2BSink
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.089s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N42): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N17
On edge  : N17 -{%div = sdiv i32 100, %0}-> N18
Message  : Divide By Zero
> Start from entry function: main, At N42 of Function main
> Entering function: good23, On N45 -> N22 (call good23)
> Entering function: goodG2BSink, On N28 -> N32 (call goodG2BSink)
> Entering function: printIntLine, On N38 -> N50 (call printIntLine)
> Leaving function: printIntLine, On N49 -> N39 (Return edge from printIntLine to goodG2BSink)
> Leaving function: goodG2BSink, On N31 -> N29 (Return edge from goodG2BSink to good23)
> Leaving function: good23, On N21 -> N46 (Return edge from good23 to main)
> Entering function: bad23, On N46 -> N1 (call bad23)
> Entering function: badSink, On N8 -> N12 (call badSink)
<Defect> : N17 -> N18: [%div = sdiv i32 100, %0]
N17 -> N18: [%div = sdiv i32 100, %0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_23.c 27] badSink 		[N17 -{%div = sdiv i32 100, %0}-> N18]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N39): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%div = sdiv i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N39 of Function main
> Entering function: good15, On N42 -> N19 (call good15)
> takes the false branch, At N27 of Function good15
> Entering function: printLine, On N37 -> N56 (call printLine)
> takes the true branch, At N62 of Function printLine
> Leaving function: printLine, On N55 -> N34 (Return edge from printLine to good15)
> Leaving function: good15, On N18 -> N43 (Return edge from good15 to main)
> Entering function: bad15, On N43 -> N1 (call bad15)
<Defect> : N8 -> N9: [%div = sdiv i32 100, %1]
N8 -> N9: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_15.c 61] bad15 		[N8 -{%div = sdiv i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
6 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad3]
 +bad3
SCC(1): [goodG2B]
 +goodG2B
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.096s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N29): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%div = sdiv i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N29 of Function main
> Entering function: good3, On N32 -> N13 (call good3)
> Entering function: goodG2B, On N13 -> N18 (call goodG2B)
> Entering function: printIntLine, On N25 -> N37 (call printIntLine)
> Leaving function: printIntLine, On N36 -> N26 (Return edge from printIntLine to goodG2B)
> Leaving function: goodG2B, On N17 -> N15 (Return edge from goodG2B to good3)
> Leaving function: good3, On N12 -> N33 (Return edge from good3 to main)
> Entering function: bad3, On N33 -> N1 (call bad3)
<Defect> : N8 -> N9: [%div = sdiv i32 100, %1]
N8 -> N9: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_3.c 39] bad3 		[N8 -{%div = sdiv i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad9]
 +bad9
SCC(1): [printLine]
 +printLine
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N8
On edge  : N8 -{%div = sdiv i32 100, %1}-> N9
Message  : Divide By Zero
> Start from entry function: main, At N33 of Function main
> Entering function: bad9, On N36 -> N1 (call bad9)
<Defect> : N8 -> N9: [%div = sdiv i32 100, %1]
N8 -> N9: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_9.c 42] bad9 		[N8 -{%div = sdiv i32 100, %1}-> N9]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/369/369_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [goodB2G1Sink]
 +goodB2G1Sink
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N21
On edge  : N21 -{%div = sdiv i32 100, %1}-> N22
Message  : Divide By Zero
> Start from entry function: main, At N81 of Function main
> Entering function: good19, On N84 -> N43 (call good19)
> Entering function: goodB2G1Sink, On N51 -> N55 (call goodB2G1Sink)
> takes the false branch, At N61 of Function goodB2G1Sink
> takes the false branch, At N66 of Function goodB2G1Sink
> Entering function: printLine, On N79 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N74 (Return edge from printLine to goodB2G1Sink)
> Leaving function: goodB2G1Sink, On N54 -> N52 (Return edge from goodB2G1Sink to good19)
> Leaving function: good19, On N42 -> N85 (Return edge from good19 to main)
> Entering function: bad19, On N85 -> N1 (call bad19)
> Entering function: badSink, On N9 -> N13 (call badSink)
> takes the true branch, At N19 of Function badSink
<Defect> : N21 -> N22: [%div = sdiv i32 100, %1]
N21 -> N22: [%div = sdiv i32 100, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_19.c 56] badSink 		[N21 -{%div = sdiv i32 100, %1}-> N22]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i8*, i8** %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good7, On N61 -> N35 (call good7)
> takes the true branch, At N40 of Function good7
> takes the false branch, At N44 of Function good7
> Entering function: printLine, On N49 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good7)
> Leaving function: good7, On N34 -> N62 (Return edge from good7 to main)
> Entering function: bad7, On N62 -> N1 (call bad7)
> takes the true branch, At N6 of Function bad7
> takes the true branch, At N10 of Function bad7
<Defect> : N18 -> N12: [%2 = load i8*, i8** %data, align 8]
N18 -> N12: [%2 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_7.c 72] bad7 		[N18 -{%2 = load i8*, i8** %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i32, i32* %data, align 4}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good31, On N35 -> N23 (call good31)
> Entering function: printIntLine, On N28 -> N59 (call printIntLine)
> Leaving function: printIntLine, On N58 -> N29 (Return edge from printIntLine to good31)
> Leaving function: good31, On N22 -> N36 (Return edge from good31 to main)
> Entering function: bad31, On N36 -> N1 (call bad31)
<Defect> : N4 -> N5: [%0 = load i32, i32* %data, align 4]
N4 -> N5: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_31.c 74] bad31 		[N4 -{%0 = load i32, i32* %data, align 4}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%0 = load i8*, i8** %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good11, On N61 -> N35 (call good11)
> Entering function: globalReturnsTrue, On N38 -> N25 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N24 -> N39 (Return edge from globalReturnsTrue to good11)
> takes the true branch, At N40 of Function good11
> Entering function: globalReturnsFalse, On N42 -> N21 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N20 -> N43 (Return edge from globalReturnsFalse to good11)
> takes the false branch, At N44 of Function good11
> Entering function: printLine, On N49 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good11)
> Leaving function: good11, On N34 -> N62 (Return edge from good11 to main)
> Entering function: bad11, On N62 -> N1 (call bad11)
> Entering function: globalReturnsTrue, On N4 -> N25 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N24 -> N5 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N6 of Function bad11
> Entering function: globalReturnsTrue, On N8 -> N25 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N24 -> N9 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N10 of Function bad11
<Defect> : N18 -> N12: [%0 = load i8*, i8** %data, align 8]
N18 -> N12: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_11.c 70] bad11 		[N18 -{%0 = load i8*, i8** %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%0 = load i64, i64* %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good47, On N61 -> N35 (call good47)
> Entering function: globalReturnsTrue, On N38 -> N25 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N24 -> N39 (Return edge from globalReturnsTrue to good47)
> takes the true branch, At N40 of Function good47
> Entering function: globalReturnsFalse, On N42 -> N21 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N20 -> N43 (Return edge from globalReturnsFalse to good47)
> takes the false branch, At N44 of Function good47
> Entering function: printLongLine, On N49 -> N100 (call printLongLine)
> Leaving function: printLongLine, On N99 -> N51 (Return edge from printLongLine to good47)
> Leaving function: good47, On N34 -> N62 (Return edge from good47 to main)
> Entering function: bad47, On N62 -> N1 (call bad47)
> Entering function: globalReturnsTrue, On N4 -> N25 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N24 -> N5 (Return edge from globalReturnsTrue to bad47)
> takes the true branch, At N6 of Function bad47
> Entering function: globalReturnsTrue, On N8 -> N25 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N24 -> N9 (Return edge from globalReturnsTrue to bad47)
> takes the true branch, At N10 of Function bad47
<Defect> : N18 -> N12: [%0 = load i64, i64* %data, align 8]
N18 -> N12: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_47.c 70] bad47 		[N18 -{%0 = load i64, i64* %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.155s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N89): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i64, i64* %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good39, On N35 -> N23 (call good39)
> Entering function: printLongLine, On N28 -> N74 (call printLongLine)
> Leaving function: printLongLine, On N73 -> N29 (Return edge from printLongLine to good39)
> Leaving function: good39, On N22 -> N36 (Return edge from good39 to main)
> Entering function: bad39, On N36 -> N1 (call bad39)
<Defect> : N4 -> N5: [%0 = load i64, i64* %data, align 8]
N4 -> N5: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_39.c 70] bad39 		[N4 -{%0 = load i64, i64* %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i64, i64* %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good38, On N35 -> N23 (call good38)
> Entering function: printLongLine, On N28 -> N74 (call printLongLine)
> Leaving function: printLongLine, On N73 -> N29 (Return edge from printLongLine to good38)
> Leaving function: good38, On N22 -> N36 (Return edge from good38 to main)
> Entering function: bad38, On N36 -> N1 (call bad38)
<Defect> : N4 -> N5: [%0 = load i64, i64* %data, align 8]
N4 -> N5: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_38.c 70] bad38 		[N4 -{%0 = load i64, i64* %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N36): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N6
On edge  : N6 -{%0 = load i8*, i8** %data, align 8}-> N7
Message  : use of uninitialized variable
> Start from entry function: main, At N36 of Function main
> Entering function: good18, On N39 -> N25 (call good18)
> Entering function: printLine, On N32 -> N63 (call printLine)
> takes the true branch, At N69 of Function printLine
> Leaving function: printLine, On N62 -> N33 (Return edge from printLine to good18)
> Leaving function: good18, On N24 -> N40 (Return edge from good18 to main)
> Entering function: bad18, On N40 -> N1 (call bad18)
<Defect> : N6 -> N7: [%0 = load i8*, i8** %data, align 8]
N6 -> N7: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_18.c 69] bad18 		[N6 -{%0 = load i8*, i8** %data, align 8}-> N7]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i8*, i8** %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good9, On N35 -> N23 (call good9)
> Entering function: printLine, On N28 -> N59 (call printLine)
> takes the true branch, At N65 of Function printLine
> Leaving function: printLine, On N58 -> N29 (Return edge from printLine to good9)
> Leaving function: good9, On N22 -> N36 (Return edge from good9 to main)
> Entering function: bad9, On N36 -> N1 (call bad9)
<Defect> : N4 -> N5: [%0 = load i8*, i8** %data, align 8]
N4 -> N5: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_9.c 70] bad9 		[N4 -{%0 = load i8*, i8** %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.147s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i64, i64* %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good45, On N35 -> N23 (call good45)
> Entering function: printLongLine, On N28 -> N74 (call printLongLine)
> Leaving function: printLongLine, On N73 -> N29 (Return edge from printLongLine to good45)
> Leaving function: good45, On N22 -> N36 (Return edge from good45 to main)
> Entering function: bad45, On N36 -> N1 (call bad45)
<Defect> : N4 -> N5: [%0 = load i64, i64* %data, align 8]
N4 -> N5: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_45.c 70] bad45 		[N4 -{%0 = load i64, i64* %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N40): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N7
On edge  : N7 -{%0 = load i32, i32* %data, align 4}-> N8
Message  : use of uninitialized variable
> Start from entry function: main, At N40 of Function main
> Entering function: good34, On N43 -> N27 (call good34)
> Entering function: printIntLine, On N35 -> N67 (call printIntLine)
> Leaving function: printIntLine, On N66 -> N37 (Return edge from printIntLine to good34)
> Leaving function: good34, On N26 -> N44 (Return edge from good34 to main)
> Entering function: bad34, On N44 -> N1 (call bad34)
<Defect> : N7 -> N8: [%0 = load i32, i32* %data, align 4]
N7 -> N8: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_34.c 75] bad34 		[N7 -{%0 = load i32, i32* %data, align 4}-> N8]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i8*, i8** %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good4, On N35 -> N23 (call good4)
> Entering function: printLine, On N28 -> N59 (call printLine)
> takes the true branch, At N65 of Function printLine
> Leaving function: printLine, On N58 -> N29 (Return edge from printLine to good4)
> Leaving function: good4, On N22 -> N36 (Return edge from good4 to main)
> Entering function: bad4, On N36 -> N1 (call bad4)
<Defect> : N4 -> N5: [%0 = load i8*, i8** %data, align 8]
N4 -> N5: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_4.c 73] bad4 		[N4 -{%0 = load i8*, i8** %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i32, i32* %data, align 4}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good23, On N61 -> N35 (call good23)
> takes the true branch, At N40 of Function good23
> takes the false branch, At N44 of Function good23
> Entering function: printIntLine, On N49 -> N85 (call printIntLine)
> Leaving function: printIntLine, On N84 -> N51 (Return edge from printIntLine to good23)
> Leaving function: good23, On N34 -> N62 (Return edge from good23 to main)
> Entering function: bad23, On N62 -> N1 (call bad23)
> takes the true branch, At N6 of Function bad23
> takes the true branch, At N10 of Function bad23
<Defect> : N18 -> N12: [%2 = load i32, i32* %data, align 4]
N18 -> N12: [%2 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_23.c 77] bad23 		[N18 -{%2 = load i32, i32* %data, align 4}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.141s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i8*, i8** %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good1, On N35 -> N23 (call good1)
> Entering function: printLine, On N28 -> N59 (call printLine)
> takes the true branch, At N65 of Function printLine
> Leaving function: printLine, On N58 -> N29 (Return edge from printLine to good1)
> Leaving function: good1, On N22 -> N36 (Return edge from good1 to main)
> Entering function: bad1, On N36 -> N1 (call bad1)
<Defect> : N4 -> N5: [%0 = load i8*, i8** %data, align 8]
N4 -> N5: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_1.c 65] bad1 		[N4 -{%0 = load i8*, i8** %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N60): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N19
On edge  : N19 -{%2 = load i32, i32* %data, align 4}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N60 of Function main
> Entering function: good46, On N63 -> N36 (call good46)
> takes the true branch, At N41 of Function good46
> takes the false branch, At N45 of Function good46
> Entering function: printLongLine, On N51 -> N102 (call printLongLine)
> Leaving function: printLongLine, On N101 -> N53 (Return edge from printLongLine to good46)
> Leaving function: good46, On N35 -> N64 (Return edge from good46 to main)
> Entering function: bad46, On N64 -> N1 (call bad46)
> takes the true branch, At N6 of Function bad46
> takes the true branch, At N10 of Function bad46
<Defect> : N19 -> N12: [%2 = load i32, i32* %data, align 4]
N19 -> N12: [%2 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_46.c 70] bad46 		[N19 -{%2 = load i32, i32* %data, align 4}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N67): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N24
On edge  : N24 -{%0 = load i64, i64* %data, align 8}-> N14
Message  : use of uninitialized variable
> Start from entry function: main, At N67 of Function main
> Entering function: good48, On N70 -> N41 (call good48)
> Entering function: globalReturnsTrueOrFalse, On N44 -> N35 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N34 -> N45 (Return edge from globalReturnsTrueOrFalse to good48)
> takes the true branch, At N46 of Function good48
> Entering function: globalReturnsTrueOrFalse, On N49 -> N35 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N34 -> N50 (Return edge from globalReturnsTrueOrFalse to good48)
> takes the false branch, At N51 of Function good48
> Entering function: printLongLine, On N58 -> N109 (call printLongLine)
> Leaving function: printLongLine, On N108 -> N60 (Return edge from printLongLine to good48)
> Leaving function: good48, On N40 -> N71 (Return edge from good48 to main)
> Entering function: bad48, On N71 -> N1 (call bad48)
> Entering function: globalReturnsTrueOrFalse, On N4 -> N35 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N34 -> N5 (Return edge from globalReturnsTrueOrFalse to bad48)
> takes the true branch, At N6 of Function bad48
> Entering function: globalReturnsTrueOrFalse, On N10 -> N35 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N34 -> N11 (Return edge from globalReturnsTrueOrFalse to bad48)
> takes the true branch, At N12 of Function bad48
<Defect> : N24 -> N14: [%0 = load i64, i64* %data, align 8]
N24 -> N14: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_48.c 75] bad48 		[N24 -{%0 = load i64, i64* %data, align 8}-> N14]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i64, i64* %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good49, On N35 -> N23 (call good49)
> Entering function: printLongLine, On N28 -> N74 (call printLongLine)
> Leaving function: printLongLine, On N73 -> N29 (Return edge from printLongLine to good49)
> Leaving function: good49, On N22 -> N36 (Return edge from good49 to main)
> Entering function: bad49, On N36 -> N1 (call bad49)
<Defect> : N4 -> N5: [%0 = load i64, i64* %data, align 8]
N4 -> N5: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_49.c 70] bad49 		[N4 -{%0 = load i64, i64* %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i64, i64* %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good42, On N35 -> N23 (call good42)
> Entering function: printLongLine, On N28 -> N74 (call printLongLine)
> Leaving function: printLongLine, On N73 -> N29 (Return edge from printLongLine to good42)
> Leaving function: good42, On N22 -> N36 (Return edge from good42 to main)
> Entering function: bad42, On N36 -> N1 (call bad42)
<Defect> : N4 -> N5: [%0 = load i64, i64* %data, align 8]
N4 -> N5: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_42.c 72] bad42 		[N4 -{%0 = load i64, i64* %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i8*, i8** %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good5, On N61 -> N35 (call good5)
> takes the true branch, At N40 of Function good5
> takes the false branch, At N44 of Function good5
> Entering function: printLine, On N49 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good5)
> Leaving function: good5, On N34 -> N62 (Return edge from good5 to main)
> Entering function: bad5, On N62 -> N1 (call bad5)
> takes the true branch, At N6 of Function bad5
> takes the true branch, At N10 of Function bad5
<Defect> : N18 -> N12: [%2 = load i8*, i8** %data, align 8]
N18 -> N12: [%2 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_5.c 73] bad5 		[N18 -{%2 = load i8*, i8** %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i64, i64* %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good50, On N61 -> N35 (call good50)
> takes the true branch, At N40 of Function good50
> takes the false branch, At N44 of Function good50
> Entering function: printLongLine, On N49 -> N100 (call printLongLine)
> Leaving function: printLongLine, On N99 -> N51 (Return edge from printLongLine to good50)
> Leaving function: good50, On N34 -> N62 (Return edge from good50 to main)
> Entering function: bad50, On N62 -> N1 (call bad50)
> takes the true branch, At N6 of Function bad50
> takes the true branch, At N10 of Function bad50
<Defect> : N18 -> N12: [%2 = load i64, i64* %data, align 8]
N18 -> N12: [%2 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_50.c 70] bad50 		[N18 -{%2 = load i64, i64* %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i32, i32* %data, align 4}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good28, On N61 -> N35 (call good28)
> takes the true branch, At N40 of Function good28
> takes the false branch, At N44 of Function good28
> Entering function: printIntLine, On N49 -> N85 (call printIntLine)
> Leaving function: printIntLine, On N84 -> N51 (Return edge from printIntLine to good28)
> Leaving function: good28, On N34 -> N62 (Return edge from good28 to main)
> Entering function: bad28, On N62 -> N1 (call bad28)
> takes the true branch, At N6 of Function bad28
> takes the true branch, At N10 of Function bad28
<Defect> : N18 -> N12: [%2 = load i32, i32* %data, align 4]
N18 -> N12: [%2 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_28.c 74] bad28 		[N18 -{%2 = load i32, i32* %data, align 4}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N67): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%0 = load i32, i32* %data, align 4}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: bad29, On N61 -> N1 (call bad29)
> Entering function: globalReturnsTrue, On N4 -> N25 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N24 -> N5 (Return edge from globalReturnsTrue to bad29)
> takes the true branch, At N6 of Function bad29
> Entering function: globalReturnsTrue, On N8 -> N25 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N24 -> N9 (Return edge from globalReturnsTrue to bad29)
> takes the true branch, At N10 of Function bad29
<Defect> : N18 -> N12: [%0 = load i32, i32* %data, align 4]
N18 -> N12: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_29.c 74] bad29 		[N18 -{%0 = load i32, i32* %data, align 4}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i32, i32* %data, align 4}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good27, On N35 -> N23 (call good27)
> Entering function: printIntLine, On N28 -> N59 (call printIntLine)
> Leaving function: printIntLine, On N58 -> N29 (Return edge from printIntLine to good27)
> Leaving function: good27, On N22 -> N36 (Return edge from good27 to main)
> Entering function: bad27, On N36 -> N1 (call bad27)
<Defect> : N4 -> N5: [%0 = load i32, i32* %data, align 4]
N4 -> N5: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_27.c 74] bad27 		[N4 -{%0 = load i32, i32* %data, align 4}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.145s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i8*, i8** %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good15, On N35 -> N23 (call good15)
> Entering function: printLine, On N28 -> N59 (call printLine)
> takes the true branch, At N65 of Function printLine
> Leaving function: printLine, On N58 -> N29 (Return edge from printLine to good15)
> Leaving function: good15, On N22 -> N36 (Return edge from good15 to main)
> Entering function: bad15, On N36 -> N1 (call bad15)
<Defect> : N4 -> N5: [%0 = load i8*, i8** %data, align 8]
N4 -> N5: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_15.c 77] bad15 		[N4 -{%0 = load i8*, i8** %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.14s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%0 = load i8*, i8** %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good8, On N61 -> N35 (call good8)
> Entering function: staticReturnsTrue, On N38 -> N113 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N112 -> N39 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N40 of Function good8
> Entering function: staticReturnsFalse, On N42 -> N109 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N108 -> N43 (Return edge from staticReturnsFalse to good8)
> takes the false branch, At N44 of Function good8
> Entering function: printLine, On N49 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good8)
> Leaving function: good8, On N34 -> N62 (Return edge from good8 to main)
> Entering function: bad8, On N62 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N4 -> N113 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N112 -> N5 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N6 of Function bad8
> Entering function: staticReturnsTrue, On N8 -> N113 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N112 -> N9 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N10 of Function bad8
<Defect> : N18 -> N12: [%0 = load i8*, i8** %data, align 8]
N18 -> N12: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_8.c 80] bad8 		[N18 -{%0 = load i8*, i8** %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
13 SCCs to deal with
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N19
On edge  : N19 -{%0 = load i32, i32* %data, align 4}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N59 of Function main
> Entering function: good26, On N62 -> N36 (call good26)
> Entering function: staticReturnsTrue, On N39 -> N123 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N122 -> N40 (Return edge from staticReturnsTrue to good26)
> takes the true branch, At N41 of Function good26
> Entering function: staticReturnsFalse, On N43 -> N119 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N118 -> N44 (Return edge from staticReturnsFalse to good26)
> takes the false branch, At N45 of Function good26
> Entering function: printIntLine, On N50 -> N86 (call printIntLine)
> Leaving function: printIntLine, On N85 -> N52 (Return edge from printIntLine to good26)
> Leaving function: good26, On N35 -> N63 (Return edge from good26 to main)
> Entering function: bad26, On N63 -> N1 (call bad26)
> Entering function: staticReturnsTrue, On N4 -> N123 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N122 -> N5 (Return edge from staticReturnsTrue to bad26)
> takes the true branch, At N6 of Function bad26
> Entering function: staticReturnsTrue, On N8 -> N123 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N122 -> N9 (Return edge from staticReturnsTrue to bad26)
> takes the true branch, At N10 of Function bad26
<Defect> : N19 -> N12: [%0 = load i32, i32* %data, align 4]
N19 -> N12: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_26.c 84] bad26 		[N19 -{%0 = load i32, i32* %data, align 4}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i8*, i8** %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good3, On N35 -> N23 (call good3)
> Entering function: printLine, On N28 -> N59 (call printLine)
> takes the true branch, At N65 of Function printLine
> Leaving function: printLine, On N58 -> N29 (Return edge from printLine to good3)
> Leaving function: good3, On N22 -> N36 (Return edge from good3 to main)
> Entering function: bad3, On N36 -> N1 (call bad3)
<Defect> : N4 -> N5: [%0 = load i8*, i8** %data, align 8]
N4 -> N5: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_3.c 70] bad3 		[N4 -{%0 = load i8*, i8** %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i32, i32* %data, align 4}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good33, On N35 -> N23 (call good33)
> Entering function: printIntLine, On N28 -> N59 (call printIntLine)
> Leaving function: printIntLine, On N58 -> N29 (Return edge from printIntLine to good33)
> Leaving function: good33, On N22 -> N36 (Return edge from good33 to main)
> Entering function: bad33, On N36 -> N1 (call bad33)
<Defect> : N4 -> N5: [%0 = load i32, i32* %data, align 4]
N4 -> N5: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_33.c 81] bad33 		[N4 -{%0 = load i32, i32* %data, align 4}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i8*, i8** %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good6, On N35 -> N23 (call good6)
> Entering function: printLine, On N28 -> N59 (call printLine)
> takes the true branch, At N65 of Function printLine
> Leaving function: printLine, On N58 -> N29 (Return edge from printLine to good6)
> Leaving function: good6, On N22 -> N36 (Return edge from good6 to main)
> Entering function: bad6, On N36 -> N1 (call bad6)
<Defect> : N4 -> N5: [%0 = load i8*, i8** %data, align 8]
N4 -> N5: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_6.c 72] bad6 		[N4 -{%0 = load i8*, i8** %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i8*, i8** %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good10, On N61 -> N35 (call good10)
> takes the true branch, At N40 of Function good10
> takes the false branch, At N44 of Function good10
> Entering function: printLine, On N49 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good10)
> Leaving function: good10, On N34 -> N62 (Return edge from good10 to main)
> Entering function: bad10, On N62 -> N1 (call bad10)
> takes the true branch, At N6 of Function bad10
> takes the true branch, At N10 of Function bad10
<Defect> : N18 -> N12: [%2 = load i8*, i8** %data, align 8]
N18 -> N12: [%2 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_10.c 71] bad10 		[N18 -{%2 = load i8*, i8** %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i8*, i8** %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good13, On N35 -> N23 (call good13)
> Entering function: printLine, On N28 -> N59 (call printLine)
> takes the true branch, At N65 of Function printLine
> Leaving function: printLine, On N58 -> N29 (Return edge from printLine to good13)
> Leaving function: good13, On N22 -> N36 (Return edge from good13 to main)
> Entering function: bad13, On N36 -> N1 (call bad13)
<Defect> : N4 -> N5: [%0 = load i8*, i8** %data, align 8]
N4 -> N5: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_13.c 70] bad13 		[N4 -{%0 = load i8*, i8** %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i32, i32* %data, align 4}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good22, On N35 -> N23 (call good22)
> Entering function: printIntLine, On N28 -> N59 (call printIntLine)
> Leaving function: printIntLine, On N58 -> N29 (Return edge from printIntLine to good22)
> Leaving function: good22, On N22 -> N36 (Return edge from good22 to main)
> Entering function: bad22, On N36 -> N1 (call bad22)
<Defect> : N4 -> N5: [%0 = load i32, i32* %data, align 4]
N4 -> N5: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_22.c 77] bad22 		[N4 -{%0 = load i32, i32* %data, align 4}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i32, i32* %data, align 4}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good21, On N35 -> N23 (call good21)
> Entering function: printIntLine, On N28 -> N50 (call printIntLine)
> Leaving function: printIntLine, On N49 -> N29 (Return edge from printIntLine to good21)
> Leaving function: good21, On N22 -> N36 (Return edge from good21 to main)
> Entering function: bad21, On N36 -> N1 (call bad21)
<Defect> : N4 -> N5: [%0 = load i32, i32* %data, align 4]
N4 -> N5: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_21.c 70] bad21 		[N4 -{%0 = load i32, i32* %data, align 4}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i64, i64* %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good41, On N61 -> N35 (call good41)
> takes the true branch, At N40 of Function good41
> takes the false branch, At N44 of Function good41
> Entering function: printLongLine, On N49 -> N100 (call printLongLine)
> Leaving function: printLongLine, On N99 -> N51 (Return edge from printLongLine to good41)
> Leaving function: good41, On N34 -> N62 (Return edge from good41 to main)
> Entering function: bad41, On N62 -> N1 (call bad41)
> takes the true branch, At N6 of Function bad41
> takes the true branch, At N10 of Function bad41
<Defect> : N18 -> N12: [%2 = load i64, i64* %data, align 8]
N18 -> N12: [%2 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_41.c 73] bad41 		[N18 -{%2 = load i64, i64* %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.15s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N88): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N34
On edge  : N34 -{%3 = load i8*, i8** %data, align 8}-> N24
Message  : use of uninitialized variable
> Start from entry function: main, At N88 of Function main
> Entering function: good17, On N91 -> N51 (call good17)
> takes the true branch, At N62 of Function good17
> takes the false branch, At N62 of Function good17
> takes the true branch, At N72 of Function good17
> Entering function: printLine, On N75 -> N115 (call printLine)
> takes the true branch, At N121 of Function printLine
> Leaving function: printLine, On N114 -> N77 (Return edge from printLine to good17)
> takes the false branch, At N72 of Function good17
> Leaving function: good17, On N50 -> N92 (Return edge from good17 to main)
> Entering function: bad17, On N92 -> N1 (call bad17)
> takes the true branch, At N12 of Function bad17
> takes the false branch, At N12 of Function bad17
> takes the true branch, At N22 of Function bad17
<Defect> : N34 -> N24: [%3 = load i8*, i8** %data, align 8]
N34 -> N24: [%3 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_17.c 71] bad17 		[N34 -{%3 = load i8*, i8** %data, align 8}-> N24]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i64, i64* %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good43, On N61 -> N35 (call good43)
> takes the true branch, At N40 of Function good43
> takes the false branch, At N44 of Function good43
> Entering function: printLongLine, On N49 -> N100 (call printLongLine)
> Leaving function: printLongLine, On N99 -> N51 (Return edge from printLongLine to good43)
> Leaving function: good43, On N34 -> N62 (Return edge from good43 to main)
> Entering function: bad43, On N62 -> N1 (call bad43)
> takes the true branch, At N6 of Function bad43
> takes the true branch, At N10 of Function bad43
<Defect> : N18 -> N12: [%2 = load i64, i64* %data, align 8]
N18 -> N12: [%2 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_43.c 72] bad43 		[N18 -{%2 = load i64, i64* %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.152s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%0 = load i64, i64* %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good44, On N61 -> N35 (call good44)
> Entering function: staticReturnsTrue, On N38 -> N113 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N112 -> N39 (Return edge from staticReturnsTrue to good44)
> takes the true branch, At N40 of Function good44
> Entering function: staticReturnsFalse, On N42 -> N109 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N108 -> N43 (Return edge from staticReturnsFalse to good44)
> takes the false branch, At N44 of Function good44
> Entering function: printLongLine, On N49 -> N100 (call printLongLine)
> Leaving function: printLongLine, On N99 -> N51 (Return edge from printLongLine to good44)
> Leaving function: good44, On N34 -> N62 (Return edge from good44 to main)
> Entering function: bad44, On N62 -> N1 (call bad44)
> Entering function: staticReturnsTrue, On N4 -> N113 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N112 -> N5 (Return edge from staticReturnsTrue to bad44)
> takes the true branch, At N6 of Function bad44
> Entering function: staticReturnsTrue, On N8 -> N113 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N112 -> N9 (Return edge from staticReturnsTrue to bad44)
> takes the true branch, At N10 of Function bad44
<Defect> : N18 -> N12: [%0 = load i64, i64* %data, align 8]
N18 -> N12: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_44.c 80] bad44 		[N18 -{%0 = load i64, i64* %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i64, i64* %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good40, On N35 -> N23 (call good40)
> Entering function: printLongLine, On N28 -> N74 (call printLongLine)
> Leaving function: printLongLine, On N73 -> N29 (Return edge from printLongLine to good40)
> Leaving function: good40, On N22 -> N36 (Return edge from good40 to main)
> Entering function: bad40, On N36 -> N1 (call bad40)
<Defect> : N4 -> N5: [%0 = load i64, i64* %data, align 8]
N4 -> N5: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_40.c 73] bad40 		[N4 -{%0 = load i64, i64* %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i8*, i8** %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good2, On N35 -> N23 (call good2)
> Entering function: printLine, On N28 -> N59 (call printLine)
> takes the true branch, At N65 of Function printLine
> Leaving function: printLine, On N58 -> N29 (Return edge from printLine to good2)
> Leaving function: good2, On N22 -> N36 (Return edge from good2 to main)
> Entering function: bad2, On N36 -> N1 (call bad2)
<Defect> : N4 -> N5: [%0 = load i8*, i8** %data, align 8]
N4 -> N5: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_2.c 70] bad2 		[N4 -{%0 = load i8*, i8** %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.139s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i8*, i8** %data, align 8}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good14, On N61 -> N35 (call good14)
> takes the true branch, At N40 of Function good14
> takes the false branch, At N44 of Function good14
> Entering function: printLine, On N49 -> N85 (call printLine)
> takes the true branch, At N91 of Function printLine
> Leaving function: printLine, On N84 -> N51 (Return edge from printLine to good14)
> Leaving function: good14, On N34 -> N62 (Return edge from good14 to main)
> Entering function: bad14, On N62 -> N1 (call bad14)
> takes the true branch, At N6 of Function bad14
> takes the true branch, At N10 of Function bad14
<Defect> : N18 -> N12: [%2 = load i8*, i8** %data, align 8]
N18 -> N12: [%2 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_14.c 70] bad14 		[N18 -{%2 = load i8*, i8** %data, align 8}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [goodG2B]
 +goodG2B
SCC(1): [goodB2G]
 +goodB2G
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N47): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i64, i64* %data, align 8}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N47 of Function main
> Entering function: good37, On N50 -> N23 (call good37)
> Entering function: goodG2B, On N23 -> N38 (call goodG2B)
> Entering function: printLongLine, On N43 -> N89 (call printLongLine)
> Leaving function: printLongLine, On N88 -> N44 (Return edge from printLongLine to goodG2B)
> Leaving function: goodG2B, On N37 -> N25 (Return edge from goodG2B to good37)
> Entering function: goodB2G, On N25 -> N29 (call goodB2G)
> Entering function: printLongLine, On N34 -> N89 (call printLongLine)
> Leaving function: printLongLine, On N88 -> N35 (Return edge from printLongLine to goodB2G)
> Leaving function: goodB2G, On N28 -> N26 (Return edge from goodB2G to good37)
> Leaving function: good37, On N22 -> N51 (Return edge from good37 to main)
> Entering function: bad37, On N51 -> N1 (call bad37)
<Defect> : N4 -> N5: [%0 = load i64, i64* %data, align 8]
N4 -> N5: [%0 = load i64, i64* %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_37.c 65] bad37 		[N4 -{%0 = load i64, i64* %data, align 8}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N40): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N7
On edge  : N7 -{%0 = load i8*, i8** %data, align 8}-> N8
Message  : use of uninitialized variable
> Start from entry function: main, At N40 of Function main
> Entering function: good16, On N43 -> N27 (call good16)
> Entering function: printLine, On N35 -> N67 (call printLine)
> takes the true branch, At N73 of Function printLine
> Leaving function: printLine, On N66 -> N37 (Return edge from printLine to good16)
> Leaving function: good16, On N26 -> N44 (Return edge from good16 to main)
> Entering function: bad16, On N44 -> N1 (call bad16)
<Defect> : N7 -> N8: [%0 = load i8*, i8** %data, align 8]
N7 -> N8: [%0 = load i8*, i8** %data, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_16.c 71] bad16 		[N7 -{%0 = load i8*, i8** %data, align 8}-> N8]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i32, i32* %data, align 4}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N35 (call good32)
> takes the true branch, At N40 of Function good32
> takes the false branch, At N44 of Function good32
> Entering function: printIntLine, On N49 -> N85 (call printIntLine)
> Leaving function: printIntLine, On N84 -> N51 (Return edge from printIntLine to good32)
> Leaving function: good32, On N34 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the true branch, At N6 of Function bad32
> takes the true branch, At N10 of Function bad32
<Defect> : N18 -> N12: [%2 = load i32, i32* %data, align 4]
N18 -> N12: [%2 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_32.c 74] bad32 		[N18 -{%2 = load i32, i32* %data, align 4}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N67): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N24
On edge  : N24 -{%0 = load i32, i32* %data, align 4}-> N14
Message  : use of uninitialized variable
> Start from entry function: main, At N67 of Function main
> Entering function: good30, On N70 -> N41 (call good30)
> Entering function: globalReturnsTrueOrFalse, On N44 -> N35 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N34 -> N45 (Return edge from globalReturnsTrueOrFalse to good30)
> takes the true branch, At N46 of Function good30
> Entering function: globalReturnsTrueOrFalse, On N49 -> N35 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N34 -> N50 (Return edge from globalReturnsTrueOrFalse to good30)
> takes the false branch, At N51 of Function good30
> Entering function: printIntLine, On N58 -> N94 (call printIntLine)
> Leaving function: printIntLine, On N93 -> N60 (Return edge from printIntLine to good30)
> Leaving function: good30, On N40 -> N71 (Return edge from good30 to main)
> Entering function: bad30, On N71 -> N1 (call bad30)
> Entering function: globalReturnsTrueOrFalse, On N4 -> N35 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N34 -> N5 (Return edge from globalReturnsTrueOrFalse to bad30)
> takes the true branch, At N6 of Function bad30
> Entering function: globalReturnsTrueOrFalse, On N10 -> N35 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N34 -> N11 (Return edge from globalReturnsTrueOrFalse to bad30)
> takes the true branch, At N12 of Function bad30
<Defect> : N24 -> N14: [%0 = load i32, i32* %data, align 4]
N24 -> N14: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_30.c 79] bad30 		[N24 -{%0 = load i32, i32* %data, align 4}-> N14]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N36): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N6
On edge  : N6 -{%0 = load i32, i32* %data, align 4}-> N7
Message  : use of uninitialized variable
> Start from entry function: main, At N36 of Function main
> Entering function: good36, On N39 -> N25 (call good36)
> Entering function: printIntLine, On N32 -> N63 (call printIntLine)
> Leaving function: printIntLine, On N62 -> N33 (Return edge from printIntLine to good36)
> Leaving function: good36, On N24 -> N40 (Return edge from good36 to main)
> Entering function: bad36, On N40 -> N1 (call bad36)
<Defect> : N6 -> N7: [%0 = load i32, i32* %data, align 4]
N6 -> N7: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_36.c 73] bad36 		[N6 -{%0 = load i32, i32* %data, align 4}-> N7]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i32, i32* %data, align 4}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good19, On N35 -> N23 (call good19)
> Entering function: printIntLine, On N28 -> N50 (call printIntLine)
> Leaving function: printIntLine, On N49 -> N29 (Return edge from printIntLine to good19)
> Leaving function: good19, On N22 -> N36 (Return edge from good19 to main)
> Entering function: bad19, On N36 -> N1 (call bad19)
<Defect> : N4 -> N5: [%0 = load i32, i32* %data, align 4]
N4 -> N5: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_19.c 65] bad19 		[N4 -{%0 = load i32, i32* %data, align 4}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.092s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i32, i32* %data, align 4}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good20, On N35 -> N23 (call good20)
> Entering function: printIntLine, On N28 -> N50 (call printIntLine)
> Leaving function: printIntLine, On N49 -> N29 (Return edge from printIntLine to good20)
> Leaving function: good20, On N22 -> N36 (Return edge from good20 to main)
> Entering function: bad20, On N36 -> N1 (call bad20)
<Defect> : N4 -> N5: [%0 = load i32, i32* %data, align 4]
N4 -> N5: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_20.c 70] bad20 		[N4 -{%0 = load i32, i32* %data, align 4}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N32): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4
On edge  : N4 -{%0 = load i32, i32* %data, align 4}-> N5
Message  : use of uninitialized variable
> Start from entry function: main, At N32 of Function main
> Entering function: good24, On N35 -> N23 (call good24)
> Entering function: printIntLine, On N28 -> N59 (call printIntLine)
> Leaving function: printIntLine, On N58 -> N29 (Return edge from printIntLine to good24)
> Leaving function: good24, On N22 -> N36 (Return edge from good24 to main)
> Entering function: bad24, On N36 -> N1 (call bad24)
<Defect> : N4 -> N5: [%0 = load i32, i32* %data, align 4]
N4 -> N5: [%0 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_24.c 76] bad24 		[N4 -{%0 = load i32, i32* %data, align 4}-> N5]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/457/457_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printDoubleLine]
 +printDoubleLine
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N18
On edge  : N18 -{%2 = load i32, i32* %data, align 4}-> N12
Message  : use of uninitialized variable
> Start from entry function: main, At N58 of Function main
> Entering function: good25, On N61 -> N35 (call good25)
> takes the true branch, At N40 of Function good25
> takes the false branch, At N44 of Function good25
> Entering function: printIntLine, On N49 -> N85 (call printIntLine)
> Leaving function: printIntLine, On N84 -> N51 (Return edge from printIntLine to good25)
> Leaving function: good25, On N34 -> N62 (Return edge from good25 to main)
> Entering function: bad25, On N62 -> N1 (call bad25)
> takes the true branch, At N6 of Function bad25
> takes the true branch, At N10 of Function bad25
<Defect> : N18 -> N12: [%2 = load i32, i32* %data, align 4]
N18 -> N12: [%2 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_25.c 76] bad25 		[N18 -{%2 = load i32, i32* %data, align 4}-> N12]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good9, On N56 -> N35 (call good9)
> takes the true branch, At N43 of Function good9
> Leaving function: good9, On N34 -> N57 (Return edge from good9 to main)
> Entering function: bad9, On N57 -> N1 (call bad9)
> takes the false branch, At N9 of Function bad9
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good9, On N56 -> N35 (call good9)
> takes the true branch, At N43 of Function good9
> Leaving function: good9, On N34 -> N57 (Return edge from good9 to main)
> Entering function: bad9, On N57 -> N1 (call bad9)
> takes the false branch, At N9 of Function bad9
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_9.c 74] bad9 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_9.c 74] bad9 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good7, On N80 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the true branch, At N57 of Function good7
> Leaving function: good7, On N45 -> N81 (Return edge from good7 to main)
> Entering function: bad7, On N81 -> N1 (call bad7)
> takes the true branch, At N7 of Function bad7
> takes the false branch, At N12 of Function bad7
> takes the true branch, At N19 of Function bad7
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good7, On N80 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the true branch, At N57 of Function good7
> Leaving function: good7, On N45 -> N81 (Return edge from good7 to main)
> Entering function: bad7, On N81 -> N1 (call bad7)
> takes the true branch, At N7 of Function bad7
> takes the false branch, At N12 of Function bad7
> takes the true branch, At N19 of Function bad7
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_7.c 76] bad7 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_7.c 76] bad7 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good22, On N61 -> N38 (call good22)
> takes the true branch, At N47 of Function good22
> Leaving function: good22, On N37 -> N62 (Return edge from good22 to main)
> Entering function: bad22, On N62 -> N1 (call bad22)
> takes the false branch, At N10 of Function bad22
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good22, On N61 -> N38 (call good22)
> takes the true branch, At N47 of Function good22
> Leaving function: good22, On N37 -> N62 (Return edge from good22 to main)
> Entering function: bad22, On N62 -> N1 (call bad22)
> takes the false branch, At N10 of Function bad22
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_22.c 74] bad22 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_22.c 74] bad22 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good4, On N56 -> N35 (call good4)
> takes the true branch, At N43 of Function good4
> Leaving function: good4, On N34 -> N57 (Return edge from good4 to main)
> Entering function: bad4, On N57 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good4, On N56 -> N35 (call good4)
> takes the true branch, At N43 of Function good4
> Leaving function: good4, On N34 -> N57 (Return edge from good4 to main)
> Entering function: bad4, On N57 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_4.c 77] bad4 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_4.c 77] bad4 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good41, On N61 -> N38 (call good41)
> takes the true branch, At N47 of Function good41
> Leaving function: good41, On N37 -> N62 (Return edge from good41 to main)
> Entering function: bad41, On N62 -> N1 (call bad41)
> takes the false branch, At N10 of Function bad41
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good41, On N61 -> N38 (call good41)
> takes the true branch, At N47 of Function good41
> Leaving function: good41, On N37 -> N62 (Return edge from good41 to main)
> Entering function: bad41, On N62 -> N1 (call bad41)
> takes the false branch, At N10 of Function bad41
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_41.c 69] bad41 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_41.c 69] bad41 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good21, On N61 -> N38 (call good21)
> takes the true branch, At N47 of Function good21
> Leaving function: good21, On N37 -> N62 (Return edge from good21 to main)
> Entering function: bad21, On N62 -> N1 (call bad21)
> takes the false branch, At N10 of Function bad21
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good21, On N61 -> N38 (call good21)
> takes the true branch, At N47 of Function good21
> Leaving function: good21, On N37 -> N62 (Return edge from good21 to main)
> Entering function: bad21, On N62 -> N1 (call bad21)
> takes the false branch, At N10 of Function bad21
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_21.c 69] bad21 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_21.c 69] bad21 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good20, On N85 -> N49 (call good20)
> takes the true branch, At N55 of Function good20
> takes the true branch, At N61 of Function good20
> Leaving function: good20, On N48 -> N86 (Return edge from good20 to main)
> Entering function: bad20, On N86 -> N1 (call bad20)
> takes the true branch, At N7 of Function bad20
> takes the false branch, At N13 of Function bad20
> takes the true branch, At N21 of Function bad20
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good20, On N85 -> N49 (call good20)
> takes the true branch, At N55 of Function good20
> takes the true branch, At N61 of Function good20
> Leaving function: good20, On N48 -> N86 (Return edge from good20 to main)
> Entering function: bad20, On N86 -> N1 (call bad20)
> takes the true branch, At N7 of Function bad20
> takes the false branch, At N13 of Function bad20
> takes the true branch, At N21 of Function bad20
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_20.c 74] bad20 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_20.c 74] bad20 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good45, On N85 -> N49 (call good45)
> takes the true branch, At N55 of Function good45
> takes the true branch, At N61 of Function good45
> Leaving function: good45, On N48 -> N86 (Return edge from good45 to main)
> Entering function: bad45, On N86 -> N1 (call bad45)
> takes the true branch, At N7 of Function bad45
> takes the false branch, At N13 of Function bad45
> takes the true branch, At N21 of Function bad45
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good45, On N85 -> N49 (call good45)
> takes the true branch, At N55 of Function good45
> takes the true branch, At N61 of Function good45
> Leaving function: good45, On N48 -> N86 (Return edge from good45 to main)
> Entering function: bad45, On N86 -> N1 (call bad45)
> takes the true branch, At N7 of Function bad45
> takes the false branch, At N13 of Function bad45
> takes the true branch, At N21 of Function bad45
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_45.c 77] bad45 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_45.c 77] bad45 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good39, On N61 -> N38 (call good39)
> takes the true branch, At N47 of Function good39
> Leaving function: good39, On N37 -> N62 (Return edge from good39 to main)
> Entering function: bad39, On N62 -> N1 (call bad39)
> takes the false branch, At N10 of Function bad39
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good39, On N61 -> N38 (call good39)
> takes the true branch, At N47 of Function good39
> Leaving function: good39, On N37 -> N62 (Return edge from good39 to main)
> Entering function: bad39, On N62 -> N1 (call bad39)
> takes the false branch, At N10 of Function bad39
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_39.c 74] bad39 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_39.c 74] bad39 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good26, On N61 -> N38 (call good26)
> takes the true branch, At N47 of Function good26
> Leaving function: good26, On N37 -> N62 (Return edge from good26 to main)
> Entering function: bad26, On N62 -> N1 (call bad26)
> takes the false branch, At N10 of Function bad26
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good26, On N61 -> N38 (call good26)
> takes the true branch, At N47 of Function good26
> Leaving function: good26, On N37 -> N62 (Return edge from good26 to main)
> Entering function: bad26, On N62 -> N1 (call bad26)
> takes the false branch, At N10 of Function bad26
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_26.c 76] bad26 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_26.c 76] bad26 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good17, On N85 -> N49 (call good17)
> takes the true branch, At N55 of Function good17
> takes the true branch, At N61 of Function good17
> Leaving function: good17, On N48 -> N86 (Return edge from good17 to main)
> Entering function: bad17, On N86 -> N1 (call bad17)
> takes the true branch, At N7 of Function bad17
> takes the false branch, At N13 of Function bad17
> takes the true branch, At N21 of Function bad17
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good17, On N85 -> N49 (call good17)
> takes the true branch, At N55 of Function good17
> takes the true branch, At N61 of Function good17
> Leaving function: good17, On N48 -> N86 (Return edge from good17 to main)
> Entering function: bad17, On N86 -> N1 (call bad17)
> takes the true branch, At N7 of Function bad17
> takes the false branch, At N13 of Function bad17
> takes the true branch, At N21 of Function bad17
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_17.c 76] bad17 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_17.c 76] bad17 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good29, On N61 -> N38 (call good29)
> takes the true branch, At N47 of Function good29
> Leaving function: good29, On N37 -> N62 (Return edge from good29 to main)
> Entering function: bad29, On N62 -> N1 (call bad29)
> takes the false branch, At N10 of Function bad29
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good29, On N61 -> N38 (call good29)
> takes the true branch, At N47 of Function good29
> Leaving function: good29, On N37 -> N62 (Return edge from good29 to main)
> Entering function: bad29, On N62 -> N1 (call bad29)
> takes the false branch, At N10 of Function bad29
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_29.c 74] bad29 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_29.c 74] bad29 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good5, On N80 -> N46 (call good5)
> takes the true branch, At N52 of Function good5
> takes the true branch, At N57 of Function good5
> Leaving function: good5, On N45 -> N81 (Return edge from good5 to main)
> Entering function: bad5, On N81 -> N1 (call bad5)
> takes the true branch, At N7 of Function bad5
> takes the false branch, At N12 of Function bad5
> takes the true branch, At N19 of Function bad5
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good5, On N80 -> N46 (call good5)
> takes the true branch, At N52 of Function good5
> takes the true branch, At N57 of Function good5
> Leaving function: good5, On N45 -> N81 (Return edge from good5 to main)
> Entering function: bad5, On N81 -> N1 (call bad5)
> takes the true branch, At N7 of Function bad5
> takes the false branch, At N12 of Function bad5
> takes the true branch, At N19 of Function bad5
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_5.c 77] bad5 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_5.c 77] bad5 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good15, On N85 -> N49 (call good15)
> takes the true branch, At N55 of Function good15
> takes the true branch, At N61 of Function good15
> Leaving function: good15, On N48 -> N86 (Return edge from good15 to main)
> Entering function: bad15, On N86 -> N1 (call bad15)
> takes the true branch, At N7 of Function bad15
> takes the false branch, At N13 of Function bad15
> takes the true branch, At N21 of Function bad15
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good15, On N85 -> N49 (call good15)
> takes the true branch, At N55 of Function good15
> takes the true branch, At N61 of Function good15
> Leaving function: good15, On N48 -> N86 (Return edge from good15 to main)
> Entering function: bad15, On N86 -> N1 (call bad15)
> takes the true branch, At N7 of Function bad15
> takes the false branch, At N13 of Function bad15
> takes the true branch, At N21 of Function bad15
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_15.c 77] bad15 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_15.c 77] bad15 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good3, On N56 -> N35 (call good3)
> takes the true branch, At N43 of Function good3
> Leaving function: good3, On N34 -> N57 (Return edge from good3 to main)
> Entering function: bad3, On N57 -> N1 (call bad3)
> takes the false branch, At N9 of Function bad3
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good3, On N56 -> N35 (call good3)
> takes the true branch, At N43 of Function good3
> Leaving function: good3, On N34 -> N57 (Return edge from good3 to main)
> Entering function: bad3, On N57 -> N1 (call bad3)
> takes the false branch, At N9 of Function bad3
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_3.c 74] bad3 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_3.c 74] bad3 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good2, On N56 -> N35 (call good2)
> takes the true branch, At N43 of Function good2
> Leaving function: good2, On N34 -> N57 (Return edge from good2 to main)
> Entering function: bad2, On N57 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good2, On N56 -> N35 (call good2)
> takes the true branch, At N43 of Function good2
> Leaving function: good2, On N34 -> N57 (Return edge from good2 to main)
> Entering function: bad2, On N57 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_2.c 74] bad2 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_2.c 74] bad2 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good25, On N85 -> N49 (call good25)
> takes the true branch, At N55 of Function good25
> takes the true branch, At N61 of Function good25
> Leaving function: good25, On N48 -> N86 (Return edge from good25 to main)
> Entering function: bad25, On N86 -> N1 (call bad25)
> takes the true branch, At N7 of Function bad25
> takes the false branch, At N13 of Function bad25
> takes the true branch, At N21 of Function bad25
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good25, On N85 -> N49 (call good25)
> takes the true branch, At N55 of Function good25
> takes the true branch, At N61 of Function good25
> Leaving function: good25, On N48 -> N86 (Return edge from good25 to main)
> Entering function: bad25, On N86 -> N1 (call bad25)
> takes the true branch, At N7 of Function bad25
> takes the false branch, At N13 of Function bad25
> takes the true branch, At N21 of Function bad25
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_25.c 77] bad25 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_25.c 77] bad25 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good27, On N85 -> N49 (call good27)
> takes the true branch, At N55 of Function good27
> takes the true branch, At N61 of Function good27
> Leaving function: good27, On N48 -> N86 (Return edge from good27 to main)
> Entering function: bad27, On N86 -> N1 (call bad27)
> takes the true branch, At N7 of Function bad27
> takes the false branch, At N13 of Function bad27
> takes the true branch, At N21 of Function bad27
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good27, On N85 -> N49 (call good27)
> takes the true branch, At N55 of Function good27
> takes the true branch, At N61 of Function good27
> Leaving function: good27, On N48 -> N86 (Return edge from good27 to main)
> Entering function: bad27, On N86 -> N1 (call bad27)
> takes the true branch, At N7 of Function bad27
> takes the false branch, At N13 of Function bad27
> takes the true branch, At N21 of Function bad27
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_27.c 76] bad27 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_27.c 76] bad27 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good33, On N61 -> N38 (call good33)
> takes the true branch, At N47 of Function good33
> Leaving function: good33, On N37 -> N62 (Return edge from good33 to main)
> Entering function: bad33, On N62 -> N1 (call bad33)
> takes the false branch, At N10 of Function bad33
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good33, On N61 -> N38 (call good33)
> takes the true branch, At N47 of Function good33
> Leaving function: good33, On N37 -> N62 (Return edge from good33 to main)
> Entering function: bad33, On N62 -> N1 (call bad33)
> takes the false branch, At N10 of Function bad33
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_33.c 74] bad33 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_33.c 74] bad33 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good42, On N61 -> N38 (call good42)
> takes the true branch, At N47 of Function good42
> Leaving function: good42, On N37 -> N62 (Return edge from good42 to main)
> Entering function: bad42, On N62 -> N1 (call bad42)
> takes the false branch, At N10 of Function bad42
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good42, On N61 -> N38 (call good42)
> takes the true branch, At N47 of Function good42
> Leaving function: good42, On N37 -> N62 (Return edge from good42 to main)
> Entering function: bad42, On N62 -> N1 (call bad42)
> takes the false branch, At N10 of Function bad42
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_42.c 74] bad42 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_42.c 74] bad42 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.098s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good16, On N61 -> N38 (call good16)
> takes the true branch, At N47 of Function good16
> Leaving function: good16, On N37 -> N62 (Return edge from good16 to main)
> Entering function: bad16, On N62 -> N1 (call bad16)
> takes the false branch, At N10 of Function bad16
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good16, On N61 -> N38 (call good16)
> takes the true branch, At N47 of Function good16
> Leaving function: good16, On N37 -> N62 (Return edge from good16 to main)
> Entering function: bad16, On N62 -> N1 (call bad16)
> takes the false branch, At N10 of Function bad16
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_16.c 76] bad16 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_16.c 76] bad16 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N38 (call good32)
> takes the true branch, At N47 of Function good32
> Leaving function: good32, On N37 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N38 (call good32)
> takes the true branch, At N47 of Function good32
> Leaving function: good32, On N37 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_31.c 74] bad32 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_31.c 74] bad32 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{call void @free(i8* %2, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good8, On N80 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the true branch, At N57 of Function good8
> Leaving function: good8, On N45 -> N81 (Return edge from good8 to main)
> Entering function: bad8, On N81 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N7 of Function bad8
> takes the false branch, At N12 of Function bad8
> Entering function: staticReturnsTrue, On N17 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N18 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N19 of Function bad8
<Defect> : N21 -> N23: [call void @free(i8* %2, i8* @free)]
N21 -> N23: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N21
On edge  : N21 -{call void @free(i8* %2, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good8, On N80 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the true branch, At N57 of Function good8
> Leaving function: good8, On N45 -> N81 (Return edge from good8 to main)
> Entering function: bad8, On N81 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N7 of Function bad8
> takes the false branch, At N12 of Function bad8
> Entering function: staticReturnsTrue, On N17 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N18 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N19 of Function bad8
<Defect> : N21 -> N23: [call void @free(i8* %2, i8* @free)]
N21 -> N23: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_8.c 84] bad8 		[N21 -{call void @free(i8* %2, i8* @free)}-> N23]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_8.c 84] bad8 		[N21 -{call void @free(i8* %2, i8* @free)}-> N23]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good19, On N61 -> N38 (call good19)
> takes the true branch, At N47 of Function good19
> Leaving function: good19, On N37 -> N62 (Return edge from good19 to main)
> Entering function: bad19, On N62 -> N1 (call bad19)
> takes the false branch, At N10 of Function bad19
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good19, On N61 -> N38 (call good19)
> takes the true branch, At N47 of Function good19
> Leaving function: good19, On N37 -> N62 (Return edge from good19 to main)
> Entering function: bad19, On N62 -> N1 (call bad19)
> takes the false branch, At N10 of Function bad19
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_19.c 74] bad19 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_19.c 74] bad19 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good1, On N56 -> N35 (call good1)
> takes the true branch, At N43 of Function good1
> Leaving function: good1, On N34 -> N57 (Return edge from good1 to main)
> Entering function: bad1, On N57 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good1, On N56 -> N35 (call good1)
> takes the true branch, At N43 of Function good1
> Leaving function: good1, On N34 -> N57 (Return edge from good1 to main)
> Entering function: bad1, On N57 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_1.c 68] bad1 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_1.c 68] bad1 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good40, On N85 -> N49 (call good40)
> takes the true branch, At N55 of Function good40
> takes the true branch, At N61 of Function good40
> Leaving function: good40, On N48 -> N86 (Return edge from good40 to main)
> Entering function: bad40, On N86 -> N1 (call bad40)
> takes the true branch, At N7 of Function bad40
> takes the false branch, At N13 of Function bad40
> takes the true branch, At N21 of Function bad40
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good40, On N85 -> N49 (call good40)
> takes the true branch, At N55 of Function good40
> takes the true branch, At N61 of Function good40
> Leaving function: good40, On N48 -> N86 (Return edge from good40 to main)
> Entering function: bad40, On N86 -> N1 (call bad40)
> takes the true branch, At N7 of Function bad40
> takes the false branch, At N13 of Function bad40
> takes the true branch, At N21 of Function bad40
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_40.c 74] bad40 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_40.c 74] bad40 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good47, On N85 -> N49 (call good47)
> takes the true branch, At N55 of Function good47
> takes the true branch, At N61 of Function good47
> Leaving function: good47, On N48 -> N86 (Return edge from good47 to main)
> Entering function: bad47, On N86 -> N1 (call bad47)
> takes the true branch, At N7 of Function bad47
> takes the false branch, At N13 of Function bad47
> takes the true branch, At N21 of Function bad47
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good47, On N85 -> N49 (call good47)
> takes the true branch, At N55 of Function good47
> takes the true branch, At N61 of Function good47
> Leaving function: good47, On N48 -> N86 (Return edge from good47 to main)
> Entering function: bad47, On N86 -> N1 (call bad47)
> takes the true branch, At N7 of Function bad47
> takes the false branch, At N13 of Function bad47
> takes the true branch, At N21 of Function bad47
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_47.c 76] bad47 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_47.c 76] bad47 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good36, On N61 -> N38 (call good36)
> takes the true branch, At N47 of Function good36
> Leaving function: good36, On N37 -> N62 (Return edge from good36 to main)
> Entering function: bad36, On N62 -> N1 (call bad36)
> takes the false branch, At N10 of Function bad36
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good36, On N61 -> N38 (call good36)
> takes the true branch, At N47 of Function good36
> Leaving function: good36, On N37 -> N62 (Return edge from good36 to main)
> Entering function: bad36, On N62 -> N1 (call bad36)
> takes the false branch, At N10 of Function bad36
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_36.c 76] bad36 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_36.c 76] bad36 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.132s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good35, On N85 -> N49 (call good35)
> takes the true branch, At N55 of Function good35
> takes the true branch, At N61 of Function good35
> Leaving function: good35, On N48 -> N86 (Return edge from good35 to main)
> Entering function: bad35, On N86 -> N1 (call bad35)
> takes the true branch, At N7 of Function bad35
> takes the false branch, At N13 of Function bad35
> takes the true branch, At N21 of Function bad35
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good35, On N85 -> N49 (call good35)
> takes the true branch, At N55 of Function good35
> takes the true branch, At N61 of Function good35
> Leaving function: good35, On N48 -> N86 (Return edge from good35 to main)
> Entering function: bad35, On N86 -> N1 (call bad35)
> takes the true branch, At N7 of Function bad35
> takes the false branch, At N13 of Function bad35
> takes the true branch, At N21 of Function bad35
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_35.c 77] bad35 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_35.c 77] bad35 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good44, On N61 -> N38 (call good44)
> takes the true branch, At N47 of Function good44
> Leaving function: good44, On N37 -> N62 (Return edge from good44 to main)
> Entering function: bad44, On N62 -> N1 (call bad44)
> takes the false branch, At N10 of Function bad44
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good44, On N61 -> N38 (call good44)
> takes the true branch, At N47 of Function good44
> Leaving function: good44, On N37 -> N62 (Return edge from good44 to main)
> Entering function: bad44, On N62 -> N1 (call bad44)
> takes the false branch, At N10 of Function bad44
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_44.c 77] bad44 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_44.c 77] bad44 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.139s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good48, On N85 -> N49 (call good48)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good48)
> takes the true branch, At N55 of Function good48
> takes the true branch, At N61 of Function good48
> Leaving function: good48, On N48 -> N86 (Return edge from good48 to main)
> Entering function: bad48, On N86 -> N1 (call bad48)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N7 of Function bad48
> takes the false branch, At N13 of Function bad48
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N21 of Function bad48
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good48, On N85 -> N49 (call good48)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good48)
> takes the true branch, At N55 of Function good48
> takes the true branch, At N61 of Function good48
> Leaving function: good48, On N48 -> N86 (Return edge from good48 to main)
> Entering function: bad48, On N86 -> N1 (call bad48)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N7 of Function bad48
> takes the false branch, At N13 of Function bad48
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N21 of Function bad48
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_48.c 84] bad48 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_48.c 84] bad48 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good10, On N80 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the true branch, At N57 of Function good10
> Leaving function: good10, On N45 -> N81 (Return edge from good10 to main)
> Entering function: bad10, On N81 -> N1 (call bad10)
> takes the true branch, At N7 of Function bad10
> takes the false branch, At N12 of Function bad10
> takes the true branch, At N19 of Function bad10
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good10, On N80 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the true branch, At N57 of Function good10
> Leaving function: good10, On N45 -> N81 (Return edge from good10 to main)
> Entering function: bad10, On N81 -> N1 (call bad10)
> takes the true branch, At N7 of Function bad10
> takes the false branch, At N12 of Function bad10
> takes the true branch, At N19 of Function bad10
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_10.c 74] bad10 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_10.c 74] bad10 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.133s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good30, On N85 -> N49 (call good30)
> takes the true branch, At N55 of Function good30
> takes the true branch, At N61 of Function good30
> Leaving function: good30, On N48 -> N86 (Return edge from good30 to main)
> Entering function: bad30, On N86 -> N1 (call bad30)
> takes the true branch, At N7 of Function bad30
> takes the false branch, At N13 of Function bad30
> takes the true branch, At N21 of Function bad30
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good30, On N85 -> N49 (call good30)
> takes the true branch, At N55 of Function good30
> takes the true branch, At N61 of Function good30
> Leaving function: good30, On N48 -> N86 (Return edge from good30 to main)
> Entering function: bad30, On N86 -> N1 (call bad30)
> takes the true branch, At N7 of Function bad30
> takes the false branch, At N13 of Function bad30
> takes the true branch, At N21 of Function bad30
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_30.c 74] bad30 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_30.c 74] bad30 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good13, On N61 -> N38 (call good13)
> takes the true branch, At N47 of Function good13
> Leaving function: good13, On N37 -> N62 (Return edge from good13 to main)
> Entering function: bad13, On N62 -> N1 (call bad13)
> takes the false branch, At N10 of Function bad13
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good13, On N61 -> N38 (call good13)
> takes the true branch, At N47 of Function good13
> Leaving function: good13, On N37 -> N62 (Return edge from good13 to main)
> Entering function: bad13, On N62 -> N1 (call bad13)
> takes the false branch, At N10 of Function bad13
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_13.c 74] bad13 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_13.c 74] bad13 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.145s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good49, On N61 -> N38 (call good49)
> takes the true branch, At N47 of Function good49
> Leaving function: good49, On N37 -> N62 (Return edge from good49 to main)
> Entering function: bad49, On N62 -> N1 (call bad49)
> takes the false branch, At N10 of Function bad49
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good49, On N61 -> N38 (call good49)
> takes the true branch, At N47 of Function good49
> Leaving function: good49, On N37 -> N62 (Return edge from good49 to main)
> Entering function: bad49, On N62 -> N1 (call bad49)
> takes the false branch, At N10 of Function bad49
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_49.c 74] bad49 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_49.c 74] bad49 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good34, On N61 -> N38 (call good34)
> takes the true branch, At N47 of Function good34
> Leaving function: good34, On N37 -> N62 (Return edge from good34 to main)
> Entering function: bad34, On N62 -> N1 (call bad34)
> takes the false branch, At N10 of Function bad34
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good34, On N61 -> N38 (call good34)
> takes the true branch, At N47 of Function good34
> Leaving function: good34, On N37 -> N62 (Return edge from good34 to main)
> Entering function: bad34, On N62 -> N1 (call bad34)
> takes the false branch, At N10 of Function bad34
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_34.c 77] bad34 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_34.c 77] bad34 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good38, On N85 -> N49 (call good38)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N55 of Function good38
> takes the true branch, At N61 of Function good38
> Leaving function: good38, On N48 -> N86 (Return edge from good38 to main)
> Entering function: bad38, On N86 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N7 of Function bad38
> takes the false branch, At N13 of Function bad38
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N21 of Function bad38
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good38, On N85 -> N49 (call good38)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N55 of Function good38
> takes the true branch, At N61 of Function good38
> Leaving function: good38, On N48 -> N86 (Return edge from good38 to main)
> Entering function: bad38, On N86 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N7 of Function bad38
> takes the false branch, At N13 of Function bad38
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N21 of Function bad38
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_38.c 84] bad38 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_38.c 84] bad38 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good28, On N85 -> N49 (call good28)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good28)
> takes the true branch, At N55 of Function good28
> takes the true branch, At N61 of Function good28
> Leaving function: good28, On N48 -> N86 (Return edge from good28 to main)
> Entering function: bad28, On N86 -> N1 (call bad28)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N7 of Function bad28
> takes the false branch, At N13 of Function bad28
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N21 of Function bad28
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good28, On N85 -> N49 (call good28)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good28)
> takes the true branch, At N55 of Function good28
> takes the true branch, At N61 of Function good28
> Leaving function: good28, On N48 -> N86 (Return edge from good28 to main)
> Entering function: bad28, On N86 -> N1 (call bad28)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N7 of Function bad28
> takes the false branch, At N13 of Function bad28
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N21 of Function bad28
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_28.c 84] bad28 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_28.c 84] bad28 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good18, On N85 -> N49 (call good18)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good18)
> takes the true branch, At N55 of Function good18
> takes the true branch, At N61 of Function good18
> Leaving function: good18, On N48 -> N86 (Return edge from good18 to main)
> Entering function: bad18, On N86 -> N1 (call bad18)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N7 of Function bad18
> takes the false branch, At N13 of Function bad18
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N21 of Function bad18
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good18, On N85 -> N49 (call good18)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good18)
> takes the true branch, At N55 of Function good18
> takes the true branch, At N61 of Function good18
> Leaving function: good18, On N48 -> N86 (Return edge from good18 to main)
> Entering function: bad18, On N86 -> N1 (call bad18)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N7 of Function bad18
> takes the false branch, At N13 of Function bad18
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N21 of Function bad18
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_18.c 84] bad18 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_18.c 84] bad18 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good50, On N85 -> N49 (call good50)
> takes the true branch, At N55 of Function good50
> takes the true branch, At N61 of Function good50
> Leaving function: good50, On N48 -> N86 (Return edge from good50 to main)
> Entering function: bad50, On N86 -> N1 (call bad50)
> takes the true branch, At N7 of Function bad50
> takes the false branch, At N13 of Function bad50
> takes the true branch, At N21 of Function bad50
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good50, On N85 -> N49 (call good50)
> takes the true branch, At N55 of Function good50
> takes the true branch, At N61 of Function good50
> Leaving function: good50, On N48 -> N86 (Return edge from good50 to main)
> Entering function: bad50, On N86 -> N1 (call bad50)
> takes the true branch, At N7 of Function bad50
> takes the false branch, At N13 of Function bad50
> takes the true branch, At N21 of Function bad50
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_50.c 74] bad50 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_50.c 74] bad50 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.207s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good23, On N61 -> N38 (call good23)
> takes the true branch, At N47 of Function good23
> Leaving function: good23, On N37 -> N62 (Return edge from good23 to main)
> Entering function: bad23, On N62 -> N1 (call bad23)
> takes the false branch, At N10 of Function bad23
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good23, On N61 -> N38 (call good23)
> takes the true branch, At N47 of Function good23
> Leaving function: good23, On N37 -> N62 (Return edge from good23 to main)
> Entering function: bad23, On N62 -> N1 (call bad23)
> takes the false branch, At N10 of Function bad23
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_23.c 74] bad23 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_23.c 74] bad23 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.432s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good46, On N61 -> N38 (call good46)
> takes the true branch, At N47 of Function good46
> Leaving function: good46, On N37 -> N62 (Return edge from good46 to main)
> Entering function: bad46, On N62 -> N1 (call bad46)
> takes the false branch, At N10 of Function bad46
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good46, On N61 -> N38 (call good46)
> takes the true branch, At N47 of Function good46
> Leaving function: good46, On N37 -> N62 (Return edge from good46 to main)
> Entering function: bad46, On N62 -> N1 (call bad46)
> takes the false branch, At N10 of Function bad46
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_46.c 76] bad46 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_46.c 76] bad46 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.284s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good12, On N61 -> N38 (call good12)
> takes the true branch, At N47 of Function good12
> Leaving function: good12, On N37 -> N62 (Return edge from good12 to main)
> Entering function: bad12, On N62 -> N1 (call bad12)
> takes the false branch, At N10 of Function bad12
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good12, On N61 -> N38 (call good12)
> takes the true branch, At N47 of Function good12
> Leaving function: good12, On N37 -> N62 (Return edge from good12 to main)
> Entering function: bad12, On N62 -> N1 (call bad12)
> takes the false branch, At N10 of Function bad12
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_12.c 74] bad12 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_12.c 74] bad12 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good14, On N61 -> N38 (call good14)
> takes the true branch, At N47 of Function good14
> Leaving function: good14, On N37 -> N62 (Return edge from good14 to main)
> Entering function: bad14, On N62 -> N1 (call bad14)
> takes the false branch, At N10 of Function bad14
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good14, On N61 -> N38 (call good14)
> takes the true branch, At N47 of Function good14
> Leaving function: good14, On N37 -> N62 (Return edge from good14 to main)
> Entering function: bad14, On N62 -> N1 (call bad14)
> takes the false branch, At N10 of Function bad14
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_14.c 77] bad14 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_14.c 77] bad14 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good43, On N61 -> N38 (call good43)
> takes the true branch, At N47 of Function good43
> Leaving function: good43, On N37 -> N62 (Return edge from good43 to main)
> Entering function: bad43, On N62 -> N1 (call bad43)
> takes the false branch, At N10 of Function bad43
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good43, On N61 -> N38 (call good43)
> takes the true branch, At N47 of Function good43
> Leaving function: good43, On N37 -> N62 (Return edge from good43 to main)
> Entering function: bad43, On N62 -> N1 (call bad43)
> takes the false branch, At N10 of Function bad43
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_43.c 74] bad43 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_43.c 74] bad43 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good24, On N61 -> N38 (call good24)
> takes the true branch, At N47 of Function good24
> Leaving function: good24, On N37 -> N62 (Return edge from good24 to main)
> Entering function: bad24, On N62 -> N1 (call bad24)
> takes the false branch, At N10 of Function bad24
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good24, On N61 -> N38 (call good24)
> takes the true branch, At N47 of Function good24
> Leaving function: good24, On N37 -> N62 (Return edge from good24 to main)
> Entering function: bad24, On N62 -> N1 (call bad24)
> takes the false branch, At N10 of Function bad24
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_24.c 77] bad24 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_24.c 77] bad24 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N38 (call good32)
> takes the true branch, At N47 of Function good32
> Leaving function: good32, On N37 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N38 (call good32)
> takes the true branch, At N47 of Function good32
> Leaving function: good32, On N37 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_32.c 74] bad32 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_32.c 74] bad32 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good37, On N85 -> N49 (call good37)
> takes the true branch, At N55 of Function good37
> takes the true branch, At N61 of Function good37
> Leaving function: good37, On N48 -> N86 (Return edge from good37 to main)
> Entering function: bad37, On N86 -> N1 (call bad37)
> takes the true branch, At N7 of Function bad37
> takes the false branch, At N13 of Function bad37
> takes the true branch, At N21 of Function bad37
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good37, On N85 -> N49 (call good37)
> takes the true branch, At N55 of Function good37
> takes the true branch, At N61 of Function good37
> Leaving function: good37, On N48 -> N86 (Return edge from good37 to main)
> Entering function: bad37, On N86 -> N1 (call bad37)
> takes the true branch, At N7 of Function bad37
> takes the false branch, At N13 of Function bad37
> takes the true branch, At N21 of Function bad37
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_37.c 76] bad37 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_37.c 76] bad37 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good11, On N61 -> N38 (call good11)
> takes the true branch, At N47 of Function good11
> Leaving function: good11, On N37 -> N62 (Return edge from good11 to main)
> Entering function: bad11, On N62 -> N1 (call bad11)
> takes the false branch, At N10 of Function bad11
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good11, On N61 -> N38 (call good11)
> takes the true branch, At N47 of Function good11
> Leaving function: good11, On N37 -> N62 (Return edge from good11 to main)
> Entering function: bad11, On N62 -> N1 (call bad11)
> takes the false branch, At N10 of Function bad11
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_11.c 69] bad11 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_11.c 69] bad11 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/415/415_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good6, On N56 -> N35 (call good6)
> takes the true branch, At N43 of Function good6
> Leaving function: good6, On N34 -> N57 (Return edge from good6 to main)
> Entering function: bad6, On N57 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good6, On N56 -> N35 (call good6)
> takes the true branch, At N43 of Function good6
> Leaving function: good6, On N34 -> N57 (Return edge from good6 to main)
> Entering function: bad6, On N57 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_6.c 76] bad6 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_6.c 76] bad6 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good2, On N66 -> N40 (call good2)
> takes the true branch, At N48 of Function good2
> Leaving function: good2, On N39 -> N67 (Return edge from good2 to main)
> Entering function: bad2, On N67 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_2.c 76] bad2 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N101): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N36
On edge  : N36 -{%9 = load i64, i64* %arrayidx3, align 8}-> N37
Message  : use of uninitialized variable
> Start from entry function: main, At N101 of Function main
> Entering function: good46, On N104 -> N60 (call good46)
> takes the true branch, At N71 of Function good46
> Leaving function: good46, On N59 -> N105 (Return edge from good46 to main)
> Entering function: bad46, On N105 -> N1 (call bad46)
> takes the false branch, At N12 of Function bad46
> takes the false branch, At N19 of Function bad46
<Defect> : N36 -> N37: [%9 = load i64, i64* %arrayidx3, align 8]
N36 -> N37: [%9 = load i64, i64* %arrayidx3, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N36
On edge  : N36 -{%9 = load i64, i64* %arrayidx3, align 8}-> N37
Message  : the memory is already freed
> Start from entry function: main, At N101 of Function main
> Entering function: good46, On N104 -> N60 (call good46)
> takes the true branch, At N71 of Function good46
> Leaving function: good46, On N59 -> N105 (Return edge from good46 to main)
> Entering function: bad46, On N105 -> N1 (call bad46)
> takes the false branch, At N12 of Function bad46
> takes the false branch, At N19 of Function bad46
<Defect> : N36 -> N37: [%9 = load i64, i64* %arrayidx3, align 8]
N36 -> N37: [%9 = load i64, i64* %arrayidx3, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_46.c 82] bad46 		[N36 -{%9 = load i64, i64* %arrayidx3, align 8}-> N37]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_46.c 82] bad46 		[N36 -{%9 = load i64, i64* %arrayidx3, align 8}-> N37]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.178s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good32, On N194 -> N32 (call good32)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good32)
> takes the true branch, At N39 of Function good32
> Leaving function: good32, On N31 -> N195 (Return edge from good32 to main)
> Entering function: bad32, On N195 -> N1 (call bad32)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the false branch, At N76 of Function helperBad
> takes the false branch, At N84 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad32)
> takes the false branch, At N8 of Function bad32
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_32.c 116] bad32 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.161s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N130): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N187
On edge  : N187 -{%1 = load i32, i32* %intOne, align 4}-> N188
Message  : use of uninitialized variable
> Start from entry function: main, At N130 of Function main
> Entering function: good28, On N133 -> N73 (call good28)
> takes the true branch, At N80 of Function good28
> takes the true branch, At N86 of Function good28
> Leaving function: good28, On N72 -> N134 (Return edge from good28 to main)
> Entering function: bad28, On N134 -> N1 (call bad28)
> takes the true branch, At N8 of Function bad28
> takes the false branch, At N14 of Function bad28
> takes the false branch, At N21 of Function bad28
> takes the true branch, At N43 of Function bad28
> Entering function: printStructLine, On N46 -> N181 (call printStructLine)
<Defect> : N187 -> N188: [%1 = load i32, i32* %intOne, align 4]
N187 -> N188: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N190
On edge  : N190 -{%3 = load i32, i32* %intTwo, align 4}-> N191
Message  : use of uninitialized variable
> Start from entry function: main, At N130 of Function main
> Entering function: good28, On N133 -> N73 (call good28)
> takes the true branch, At N80 of Function good28
> takes the true branch, At N86 of Function good28
> Leaving function: good28, On N72 -> N134 (Return edge from good28 to main)
> Entering function: bad28, On N134 -> N1 (call bad28)
> takes the true branch, At N8 of Function bad28
> takes the false branch, At N14 of Function bad28
> takes the false branch, At N21 of Function bad28
> takes the true branch, At N43 of Function bad28
> Entering function: printStructLine, On N46 -> N181 (call printStructLine)
<Defect> : N190 -> N191: [%3 = load i32, i32* %intTwo, align 4]
N190 -> N191: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N46
On edge  : N46 -{call printStructLine}-> N181
Message  : the memory is already freed
> Start from entry function: main, At N130 of Function main
> Entering function: good28, On N133 -> N73 (call good28)
> takes the true branch, At N80 of Function good28
> takes the true branch, At N86 of Function good28
> Leaving function: good28, On N72 -> N134 (Return edge from good28 to main)
> Entering function: bad28, On N134 -> N1 (call bad28)
> takes the true branch, At N8 of Function bad28
> takes the false branch, At N14 of Function bad28
> takes the false branch, At N21 of Function bad28
> takes the true branch, At N43 of Function bad28
<Defect> : N46 -> N181: [call printStructLine]
N46 -> N181: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_28.c 58] printStructLine 		[N187 -{%1 = load i32, i32* %intOne, align 4}-> N188]	(use of uninitialized variable)
	[./416_28.c 58] printStructLine 		[N190 -{%3 = load i32, i32* %intTwo, align 4}-> N191]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_28.c 88] bad28 		[N46 -{call printStructLine}-> N181]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.144s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N99): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N99 of Function main
> Entering function: good13, On N102 -> N57 (call good13)
> takes the true branch, At N67 of Function good13
> Leaving function: good13, On N56 -> N103 (Return edge from good13 to main)
> Entering function: bad13, On N103 -> N1 (call bad13)
> takes the false branch, At N11 of Function bad13
> takes the false branch, At N18 of Function bad13
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N99 of Function main
> Entering function: good13, On N102 -> N57 (call good13)
> takes the true branch, At N67 of Function good13
> Leaving function: good13, On N56 -> N103 (Return edge from good13 to main)
> Entering function: bad13, On N103 -> N1 (call bad13)
> takes the false branch, At N11 of Function bad13
> takes the false branch, At N18 of Function bad13
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_13.c 76] bad13 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_13.c 76] bad13 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N163
On edge  : N163 -{%1 = load i32, i32* %intOne, align 4}-> N164
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good23, On N109 -> N62 (call good23)
> takes the true branch, At N72 of Function good23
> Leaving function: good23, On N61 -> N110 (Return edge from good23 to main)
> Entering function: bad23, On N110 -> N1 (call bad23)
> takes the false branch, At N11 of Function bad23
> takes the false branch, At N18 of Function bad23
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N163 -> N164: [%1 = load i32, i32* %intOne, align 4]
N163 -> N164: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N166
On edge  : N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good23, On N109 -> N62 (call good23)
> takes the true branch, At N72 of Function good23
> Leaving function: good23, On N61 -> N110 (Return edge from good23 to main)
> Entering function: bad23, On N110 -> N1 (call bad23)
> takes the false branch, At N11 of Function bad23
> takes the false branch, At N18 of Function bad23
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N166 -> N167: [%3 = load i32, i32* %intTwo, align 4]
N166 -> N167: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good23, On N109 -> N62 (call good23)
> takes the true branch, At N72 of Function good23
> Leaving function: good23, On N61 -> N110 (Return edge from good23 to main)
> Entering function: bad23, On N110 -> N1 (call bad23)
> takes the false branch, At N11 of Function bad23
> takes the false branch, At N18 of Function bad23
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_23.c 58] printStructLine 		[N163 -{%1 = load i32, i32* %intOne, align 4}-> N164]	(use of uninitialized variable)
	[./416_23.c 58] printStructLine 		[N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_23.c 86] bad23 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.138s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N163
On edge  : N163 -{%1 = load i32, i32* %intOne, align 4}-> N164
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good25, On N109 -> N62 (call good25)
> takes the true branch, At N72 of Function good25
> Leaving function: good25, On N61 -> N110 (Return edge from good25 to main)
> Entering function: bad25, On N110 -> N1 (call bad25)
> takes the false branch, At N11 of Function bad25
> takes the false branch, At N18 of Function bad25
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N163 -> N164: [%1 = load i32, i32* %intOne, align 4]
N163 -> N164: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N166
On edge  : N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good25, On N109 -> N62 (call good25)
> takes the true branch, At N72 of Function good25
> Leaving function: good25, On N61 -> N110 (Return edge from good25 to main)
> Entering function: bad25, On N110 -> N1 (call bad25)
> takes the false branch, At N11 of Function bad25
> takes the false branch, At N18 of Function bad25
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N166 -> N167: [%3 = load i32, i32* %intTwo, align 4]
N166 -> N167: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good25, On N109 -> N62 (call good25)
> takes the true branch, At N72 of Function good25
> Leaving function: good25, On N61 -> N110 (Return edge from good25 to main)
> Entering function: bad25, On N110 -> N1 (call bad25)
> takes the false branch, At N11 of Function bad25
> takes the false branch, At N18 of Function bad25
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_25.c 58] printStructLine 		[N163 -{%1 = load i32, i32* %intOne, align 4}-> N164]	(use of uninitialized variable)
	[./416_25.c 58] printStructLine 		[N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_25.c 89] bad25 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.179s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N87): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N26
On edge  : N26 -{call printLine}-> N114
Message  : the memory is already freed
> Start from entry function: main, At N87 of Function main
> Entering function: good5, On N90 -> N51 (call good5)
> takes the true branch, At N57 of Function good5
> takes the true branch, At N62 of Function good5
> Leaving function: good5, On N50 -> N91 (Return edge from good5 to main)
> Entering function: bad5, On N91 -> N1 (call bad5)
> takes the true branch, At N7 of Function bad5
> takes the false branch, At N12 of Function bad5
> takes the true branch, At N24 of Function bad5
<Defect> : N26 -> N114: [call printLine]
N26 -> N114: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_5.c 79] bad5 		[N26 -{call printLine}-> N114]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.148s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N97): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N32
On edge  : N32 -{%9 = load i32, i32* %arrayidx2, align 4}-> N33
Message  : use of uninitialized variable
> Start from entry function: main, At N97 of Function main
> Entering function: good7, On N100 -> N56 (call good7)
> takes the false branch, At N66 of Function good7
> Leaving function: good7, On N55 -> N101 (Return edge from good7 to main)
> Entering function: bad7, On N101 -> N1 (call bad7)
> takes the true branch, At N11 of Function bad7
> takes the false branch, At N17 of Function bad7
<Defect> : N32 -> N33: [%9 = load i32, i32* %arrayidx2, align 4]
N32 -> N33: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N32
On edge  : N32 -{%9 = load i32, i32* %arrayidx2, align 4}-> N33
Message  : the memory is already freed
> Start from entry function: main, At N97 of Function main
> Entering function: good7, On N100 -> N56 (call good7)
> takes the false branch, At N66 of Function good7
> Leaving function: good7, On N55 -> N101 (Return edge from good7 to main)
> Entering function: bad7, On N101 -> N1 (call bad7)
> takes the true branch, At N11 of Function bad7
> takes the false branch, At N17 of Function bad7
<Defect> : N32 -> N33: [%9 = load i32, i32* %arrayidx2, align 4]
N32 -> N33: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_7.c 75] bad7 		[N32 -{%9 = load i32, i32* %arrayidx2, align 4}-> N33]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_7.c 75] bad7 		[N32 -{%9 = load i32, i32* %arrayidx2, align 4}-> N33]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.138s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N119): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{%11 = load i64, i64* %arrayidx7, align 8}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N119 of Function main
> Entering function: good19, On N122 -> N68 (call good19)
> takes the true branch, At N75 of Function good19
> takes the true branch, At N81 of Function good19
> Leaving function: good19, On N67 -> N123 (Return edge from good19 to main)
> Entering function: bad19, On N123 -> N1 (call bad19)
> takes the true branch, At N8 of Function bad19
> takes the false branch, At N14 of Function bad19
> takes the false branch, At N21 of Function bad19
> takes the true branch, At N37 of Function bad19
<Defect> : N40 -> N41: [%11 = load i64, i64* %arrayidx7, align 8]
N40 -> N41: [%11 = load i64, i64* %arrayidx7, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N40
On edge  : N40 -{%11 = load i64, i64* %arrayidx7, align 8}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N119 of Function main
> Entering function: good19, On N122 -> N68 (call good19)
> takes the true branch, At N75 of Function good19
> takes the true branch, At N81 of Function good19
> Leaving function: good19, On N67 -> N123 (Return edge from good19 to main)
> Entering function: bad19, On N123 -> N1 (call bad19)
> takes the true branch, At N8 of Function bad19
> takes the false branch, At N14 of Function bad19
> takes the false branch, At N21 of Function bad19
> takes the true branch, At N37 of Function bad19
<Defect> : N40 -> N41: [%11 = load i64, i64* %arrayidx7, align 8]
N40 -> N41: [%11 = load i64, i64* %arrayidx7, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_19.c 83] bad19 		[N40 -{%11 = load i64, i64* %arrayidx7, align 8}-> N41]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_19.c 83] bad19 		[N40 -{%11 = load i64, i64* %arrayidx7, align 8}-> N41]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.256s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N163
On edge  : N163 -{%1 = load i32, i32* %intOne, align 4}-> N164
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good24, On N109 -> N62 (call good24)
> takes the true branch, At N72 of Function good24
> Leaving function: good24, On N61 -> N110 (Return edge from good24 to main)
> Entering function: bad24, On N110 -> N1 (call bad24)
> takes the false branch, At N11 of Function bad24
> takes the false branch, At N18 of Function bad24
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N163 -> N164: [%1 = load i32, i32* %intOne, align 4]
N163 -> N164: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N166
On edge  : N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good24, On N109 -> N62 (call good24)
> takes the true branch, At N72 of Function good24
> Leaving function: good24, On N61 -> N110 (Return edge from good24 to main)
> Entering function: bad24, On N110 -> N1 (call bad24)
> takes the false branch, At N11 of Function bad24
> takes the false branch, At N18 of Function bad24
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N166 -> N167: [%3 = load i32, i32* %intTwo, align 4]
N166 -> N167: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good24, On N109 -> N62 (call good24)
> takes the true branch, At N72 of Function good24
> Leaving function: good24, On N61 -> N110 (Return edge from good24 to main)
> Entering function: bad24, On N110 -> N1 (call bad24)
> takes the false branch, At N11 of Function bad24
> takes the false branch, At N18 of Function bad24
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_24.c 58] printStructLine 		[N163 -{%1 = load i32, i32* %intOne, align 4}-> N164]	(use of uninitialized variable)
	[./416_24.c 58] printStructLine 		[N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_24.c 86] bad24 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.154s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good33, On N194 -> N32 (call good33)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good33)
> takes the true branch, At N39 of Function good33
> Leaving function: good33, On N31 -> N195 (Return edge from good33 to main)
> Entering function: bad33, On N195 -> N1 (call bad33)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the false branch, At N76 of Function helperBad
> takes the false branch, At N84 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad33)
> takes the false branch, At N8 of Function bad33
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_33.c 116] bad33 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.148s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good1, On N66 -> N40 (call good1)
> takes the true branch, At N48 of Function good1
> Leaving function: good1, On N39 -> N67 (Return edge from good1 to main)
> Entering function: bad1, On N67 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N39
On edge  : N39 -{Return edge from good1 to main}-> N67
Message  : the heap object @H(good1::call) is not referenced any more
> Start from entry function: main, At N63 of Function main
> Entering function: good1, On N66 -> N40 (call good1)
> takes the false branch, At N48 of Function good1
> Entering function: printLine, On N56 -> N90 (call printLine)
> takes the true branch, At N96 of Function printLine
> Leaving function: printLine, On N89 -> N58 (Return edge from printLine to good1)
<Defect> : N39 -> N67: [Return edge from good1 to main]
N39 -> N67: [Return edge from good1 to main] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_1.c 75] bad1 		[N19 -{call printLine}-> N90]	(the memory is already freed)

CWE_401(Memory Leak): 1
	[./416_1.c 105] good1 		[N39 -{Return edge from good1 to main}-> N67]	(the heap object @H(good1::call) is not referenced any more)

Found 2 defects in all (5 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.21s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good21, On N98 -> N57 (call good21)
> takes the true branch, At N67 of Function good21
> Leaving function: good21, On N56 -> N99 (Return edge from good21 to main)
> Entering function: bad21, On N99 -> N1 (call bad21)
> takes the false branch, At N11 of Function bad21
> takes the false branch, At N18 of Function bad21
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good21, On N98 -> N57 (call good21)
> takes the true branch, At N67 of Function good21
> Leaving function: good21, On N56 -> N99 (Return edge from good21 to main)
> Entering function: bad21, On N99 -> N1 (call bad21)
> takes the false branch, At N11 of Function bad21
> takes the false branch, At N18 of Function bad21
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_21.c 81] bad21 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_21.c 81] bad21 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.158s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N98): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N35
On edge  : N35 -{%9 = load i64, i64* %arrayidx2, align 8}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N98 of Function main
> Entering function: bad48, On N101 -> N1 (call bad48)
> takes the false branch, At N12 of Function bad48
> takes the false branch, At N19 of Function bad48
<Defect> : N35 -> N36: [%9 = load i64, i64* %arrayidx2, align 8]
N35 -> N36: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N35
On edge  : N35 -{%9 = load i64, i64* %arrayidx2, align 8}-> N36
Message  : use of uninitialized variable
> Start from entry function: main, At N98 of Function main
> Entering function: bad48, On N101 -> N1 (call bad48)
> takes the false branch, At N12 of Function bad48
> takes the false branch, At N19 of Function bad48
<Defect> : N35 -> N36: [%9 = load i64, i64* %arrayidx2, align 8]
N35 -> N36: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_48.c 80] bad48 		[N35 -{%9 = load i64, i64* %arrayidx2, align 8}-> N36]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_48.c 80] bad48 		[N35 -{%9 = load i64, i64* %arrayidx2, align 8}-> N36]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
13 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.169s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N130): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N187
On edge  : N187 -{%1 = load i32, i32* %intOne, align 4}-> N188
Message  : use of uninitialized variable
> Start from entry function: main, At N130 of Function main
> Entering function: good29, On N133 -> N73 (call good29)
> Entering function: staticReturnsTrue, On N78 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N79 (Return edge from staticReturnsTrue to good29)
> takes the true branch, At N80 of Function good29
> takes the true branch, At N86 of Function good29
> Leaving function: good29, On N72 -> N134 (Return edge from good29 to main)
> Entering function: bad29, On N134 -> N1 (call bad29)
> Entering function: staticReturnsTrue, On N6 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N7 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N8 of Function bad29
> takes the false branch, At N14 of Function bad29
> takes the false branch, At N21 of Function bad29
> Entering function: staticReturnsTrue, On N41 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N42 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N43 of Function bad29
> Entering function: printStructLine, On N46 -> N181 (call printStructLine)
<Defect> : N187 -> N188: [%1 = load i32, i32* %intOne, align 4]
N187 -> N188: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N190
On edge  : N190 -{%3 = load i32, i32* %intTwo, align 4}-> N191
Message  : use of uninitialized variable
> Start from entry function: main, At N130 of Function main
> Entering function: good29, On N133 -> N73 (call good29)
> Entering function: staticReturnsTrue, On N78 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N79 (Return edge from staticReturnsTrue to good29)
> takes the true branch, At N80 of Function good29
> takes the true branch, At N86 of Function good29
> Leaving function: good29, On N72 -> N134 (Return edge from good29 to main)
> Entering function: bad29, On N134 -> N1 (call bad29)
> Entering function: staticReturnsTrue, On N6 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N7 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N8 of Function bad29
> takes the false branch, At N14 of Function bad29
> takes the false branch, At N21 of Function bad29
> Entering function: staticReturnsTrue, On N41 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N42 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N43 of Function bad29
> Entering function: printStructLine, On N46 -> N181 (call printStructLine)
<Defect> : N190 -> N191: [%3 = load i32, i32* %intTwo, align 4]
N190 -> N191: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N46
On edge  : N46 -{call printStructLine}-> N181
Message  : the memory is already freed
> Start from entry function: main, At N130 of Function main
> Entering function: good29, On N133 -> N73 (call good29)
> Entering function: staticReturnsTrue, On N78 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N79 (Return edge from staticReturnsTrue to good29)
> takes the true branch, At N80 of Function good29
> takes the true branch, At N86 of Function good29
> Leaving function: good29, On N72 -> N134 (Return edge from good29 to main)
> Entering function: bad29, On N134 -> N1 (call bad29)
> Entering function: staticReturnsTrue, On N6 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N7 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N8 of Function bad29
> takes the false branch, At N14 of Function bad29
> takes the false branch, At N21 of Function bad29
> Entering function: staticReturnsTrue, On N41 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N42 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N43 of Function bad29
<Defect> : N46 -> N181: [call printStructLine]
N46 -> N181: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_29.c 69] printStructLine 		[N187 -{%1 = load i32, i32* %intOne, align 4}-> N188]	(use of uninitialized variable)
	[./416_29.c 69] printStructLine 		[N190 -{%3 = load i32, i32* %intTwo, align 4}-> N191]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_29.c 97] bad29 		[N46 -{call printStructLine}-> N181]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.184s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good39, On N194 -> N32 (call good39)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good39)
> takes the true branch, At N39 of Function good39
> Leaving function: good39, On N31 -> N195 (Return edge from good39 to main)
> Entering function: bad39, On N195 -> N1 (call bad39)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the false branch, At N76 of Function helperBad
> takes the false branch, At N84 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad39)
> takes the false branch, At N8 of Function bad39
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_39.c 116] bad39 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.149s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good36, On N194 -> N32 (call good36)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good36)
> takes the true branch, At N39 of Function good36
> Leaving function: good36, On N31 -> N195 (Return edge from good36 to main)
> Entering function: bad36, On N195 -> N1 (call bad36)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the false branch, At N76 of Function helperBad
> takes the false branch, At N84 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad36)
> takes the false branch, At N8 of Function bad36
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_36.c 121] bad36 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.179s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N203): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call printLine}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N203 of Function main
> Entering function: good37, On N206 -> N37 (call good37)
> takes the false branch, At N41 of Function good37
> Entering function: helperGood, On N59 -> N134 (call helperGood)
> takes the true branch, At N149 of Function helperGood
> takes the true branch, At N159 of Function helperGood
> Leaving function: helperGood, On N133 -> N46 (Return edge from helperGood to good37)
> takes the true branch, At N49 of Function good37
> Leaving function: good37, On N36 -> N207 (Return edge from good37 to main)
> Entering function: bad37, On N207 -> N1 (call bad37)
> takes the true branch, At N5 of Function bad37
> Entering function: helperBad, On N18 -> N63 (call helperBad)
> takes the true branch, At N78 of Function helperBad
> takes the false branch, At N88 of Function helperBad
> takes the false branch, At N96 of Function helperBad
> Leaving function: helperBad, On N62 -> N8 (Return edge from helperBad to bad37)
> takes the false branch, At N11 of Function bad37
<Defect> : N14 -> N230: [call printLine]
N14 -> N230: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_37.c 121] bad37 		[N14 -{call printLine}-> N230]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.15s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N109): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N166
On edge  : N166 -{%1 = load i32, i32* %intOne, align 4}-> N167
Message  : use of uninitialized variable
> Start from entry function: main, At N109 of Function main
> Entering function: good22, On N112 -> N62 (call good22)
> takes the true branch, At N72 of Function good22
> Leaving function: good22, On N61 -> N113 (Return edge from good22 to main)
> Entering function: bad22, On N113 -> N1 (call bad22)
> takes the false branch, At N11 of Function bad22
> takes the false branch, At N18 of Function bad22
> Entering function: printStructLine, On N39 -> N160 (call printStructLine)
<Defect> : N166 -> N167: [%1 = load i32, i32* %intOne, align 4]
N166 -> N167: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N169
On edge  : N169 -{%3 = load i32, i32* %intTwo, align 4}-> N170
Message  : use of uninitialized variable
> Start from entry function: main, At N109 of Function main
> Entering function: good22, On N112 -> N62 (call good22)
> takes the true branch, At N72 of Function good22
> Leaving function: good22, On N61 -> N113 (Return edge from good22 to main)
> Entering function: bad22, On N113 -> N1 (call bad22)
> takes the false branch, At N11 of Function bad22
> takes the false branch, At N18 of Function bad22
> Entering function: printStructLine, On N39 -> N160 (call printStructLine)
<Defect> : N169 -> N170: [%3 = load i32, i32* %intTwo, align 4]
N169 -> N170: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N160
Message  : the memory is already freed
> Start from entry function: main, At N109 of Function main
> Entering function: good22, On N112 -> N62 (call good22)
> takes the true branch, At N72 of Function good22
> Leaving function: good22, On N61 -> N113 (Return edge from good22 to main)
> Entering function: bad22, On N113 -> N1 (call bad22)
> takes the false branch, At N11 of Function bad22
> takes the false branch, At N18 of Function bad22
<Defect> : N39 -> N160: [call printStructLine]
N39 -> N160: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_22.c 58] printStructLine 		[N166 -{%1 = load i32, i32* %intOne, align 4}-> N167]	(use of uninitialized variable)
	[./416_22.c 58] printStructLine 		[N169 -{%3 = load i32, i32* %intTwo, align 4}-> N170]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_22.c 81] bad22 		[N39 -{call printStructLine}-> N160]	(the memory is already freed)

Found 3 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.176s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good34, On N194 -> N32 (call good34)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good34)
> takes the true branch, At N39 of Function good34
> Leaving function: good34, On N31 -> N195 (Return edge from good34 to main)
> Entering function: bad34, On N195 -> N1 (call bad34)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the false branch, At N76 of Function helperBad
> takes the false branch, At N84 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad34)
> takes the false branch, At N8 of Function bad34
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_34.c 122] bad34 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: bad41, On N98 -> N1 (call bad41)
> takes the false branch, At N11 of Function bad41
> takes the false branch, At N18 of Function bad41
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: bad41, On N98 -> N1 (call bad41)
> takes the false branch, At N11 of Function bad41
> takes the false branch, At N18 of Function bad41
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_41.c 88] bad41 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_41.c 88] bad41 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good16, On N98 -> N57 (call good16)
> takes the true branch, At N67 of Function good16
> Leaving function: good16, On N56 -> N99 (Return edge from good16 to main)
> Entering function: bad16, On N99 -> N1 (call bad16)
> takes the false branch, At N11 of Function bad16
> takes the false branch, At N18 of Function bad16
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good16, On N98 -> N57 (call good16)
> takes the true branch, At N67 of Function good16
> Leaving function: good16, On N56 -> N99 (Return edge from good16 to main)
> Entering function: bad16, On N99 -> N1 (call bad16)
> takes the false branch, At N11 of Function bad16
> takes the false branch, At N18 of Function bad16
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_16.c 84] bad16 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_16.c 84] bad16 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.138s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good9, On N98 -> N57 (call good9)
> takes the true branch, At N67 of Function good9
> Leaving function: good9, On N56 -> N99 (Return edge from good9 to main)
> Entering function: bad9, On N99 -> N1 (call bad9)
> takes the false branch, At N11 of Function bad9
> takes the false branch, At N18 of Function bad9
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good9, On N98 -> N57 (call good9)
> takes the true branch, At N67 of Function good9
> Leaving function: good9, On N56 -> N99 (Return edge from good9 to main)
> Entering function: bad9, On N99 -> N1 (call bad9)
> takes the false branch, At N11 of Function bad9
> takes the false branch, At N18 of Function bad9
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_9.c 81] bad9 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_9.c 81] bad9 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.162s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good15, On N98 -> N57 (call good15)
> takes the true branch, At N67 of Function good15
> Leaving function: good15, On N56 -> N99 (Return edge from good15 to main)
> Entering function: bad15, On N99 -> N1 (call bad15)
> takes the false branch, At N11 of Function bad15
> takes the false branch, At N18 of Function bad15
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good15, On N98 -> N57 (call good15)
> takes the true branch, At N67 of Function good15
> Leaving function: good15, On N56 -> N99 (Return edge from good15 to main)
> Entering function: bad15, On N99 -> N1 (call bad15)
> takes the false branch, At N11 of Function bad15
> takes the false branch, At N18 of Function bad15
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_15.c 81] bad15 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_15.c 81] bad15 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good6, On N66 -> N40 (call good6)
> takes the true branch, At N48 of Function good6
> Leaving function: good6, On N39 -> N67 (Return edge from good6 to main)
> Entering function: bad6, On N67 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_6.c 78] bad6 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.148s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good12, On N98 -> N57 (call good12)
> takes the true branch, At N67 of Function good12
> Leaving function: good12, On N56 -> N99 (Return edge from good12 to main)
> Entering function: bad12, On N99 -> N1 (call bad12)
> takes the false branch, At N11 of Function bad12
> takes the false branch, At N18 of Function bad12
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good12, On N98 -> N57 (call good12)
> takes the true branch, At N67 of Function good12
> Leaving function: good12, On N56 -> N99 (Return edge from good12 to main)
> Entering function: bad12, On N99 -> N1 (call bad12)
> takes the false branch, At N11 of Function bad12
> takes the false branch, At N18 of Function bad12
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_12.c 83] bad12 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_12.c 83] bad12 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.137s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N163
On edge  : N163 -{%1 = load i32, i32* %intOne, align 4}-> N164
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good27, On N109 -> N62 (call good27)
> takes the true branch, At N72 of Function good27
> Leaving function: good27, On N61 -> N110 (Return edge from good27 to main)
> Entering function: bad27, On N110 -> N1 (call bad27)
> takes the false branch, At N11 of Function bad27
> takes the false branch, At N18 of Function bad27
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N163 -> N164: [%1 = load i32, i32* %intOne, align 4]
N163 -> N164: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N166
On edge  : N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good27, On N109 -> N62 (call good27)
> takes the true branch, At N72 of Function good27
> Leaving function: good27, On N61 -> N110 (Return edge from good27 to main)
> Entering function: bad27, On N110 -> N1 (call bad27)
> takes the false branch, At N11 of Function bad27
> takes the false branch, At N18 of Function bad27
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N166 -> N167: [%3 = load i32, i32* %intTwo, align 4]
N166 -> N167: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good27, On N109 -> N62 (call good27)
> takes the true branch, At N72 of Function good27
> Leaving function: good27, On N61 -> N110 (Return edge from good27 to main)
> Entering function: bad27, On N110 -> N1 (call bad27)
> takes the false branch, At N11 of Function bad27
> takes the false branch, At N18 of Function bad27
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_27.c 58] printStructLine 		[N163 -{%1 = load i32, i32* %intOne, align 4}-> N164]	(use of uninitialized variable)
	[./416_27.c 58] printStructLine 		[N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_27.c 88] bad27 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N101): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N36
On edge  : N36 -{%9 = load i32, i32* %arrayidx3, align 4}-> N37
Message  : use of uninitialized variable
> Start from entry function: main, At N101 of Function main
> Entering function: good42, On N104 -> N60 (call good42)
> takes the true branch, At N71 of Function good42
> Leaving function: good42, On N59 -> N105 (Return edge from good42 to main)
> Entering function: bad42, On N105 -> N1 (call bad42)
> takes the false branch, At N12 of Function bad42
> takes the false branch, At N19 of Function bad42
<Defect> : N36 -> N37: [%9 = load i32, i32* %arrayidx3, align 4]
N36 -> N37: [%9 = load i32, i32* %arrayidx3, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N36
On edge  : N36 -{%9 = load i32, i32* %arrayidx3, align 4}-> N37
Message  : the memory is already freed
> Start from entry function: main, At N101 of Function main
> Entering function: good42, On N104 -> N60 (call good42)
> takes the true branch, At N71 of Function good42
> Leaving function: good42, On N59 -> N105 (Return edge from good42 to main)
> Entering function: bad42, On N105 -> N1 (call bad42)
> takes the false branch, At N12 of Function bad42
> takes the false branch, At N19 of Function bad42
<Defect> : N36 -> N37: [%9 = load i32, i32* %arrayidx3, align 4]
N36 -> N37: [%9 = load i32, i32* %arrayidx3, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_42.c 82] bad42 		[N36 -{%9 = load i32, i32* %arrayidx3, align 4}-> N37]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_42.c 82] bad42 		[N36 -{%9 = load i32, i32* %arrayidx3, align 4}-> N37]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.183s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N203): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call printLine}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N203 of Function main
> Entering function: good40, On N206 -> N37 (call good40)
> takes the false branch, At N41 of Function good40
> Entering function: helperGood, On N59 -> N134 (call helperGood)
> takes the true branch, At N149 of Function helperGood
> takes the true branch, At N159 of Function helperGood
> Leaving function: helperGood, On N133 -> N46 (Return edge from helperGood to good40)
> takes the true branch, At N49 of Function good40
> Leaving function: good40, On N36 -> N207 (Return edge from good40 to main)
> Entering function: bad40, On N207 -> N1 (call bad40)
> takes the true branch, At N5 of Function bad40
> Entering function: helperBad, On N18 -> N63 (call helperBad)
> takes the true branch, At N78 of Function helperBad
> takes the false branch, At N88 of Function helperBad
> takes the false branch, At N96 of Function helperBad
> Leaving function: helperBad, On N62 -> N8 (Return edge from helperBad to bad40)
> takes the false branch, At N11 of Function bad40
<Defect> : N14 -> N230: [call printLine]
N14 -> N230: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_40.c 116] bad40 		[N14 -{call printLine}-> N230]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.184s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good31, On N194 -> N32 (call good31)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good31)
> takes the true branch, At N39 of Function good31
> Leaving function: good31, On N31 -> N195 (Return edge from good31 to main)
> Entering function: bad31, On N195 -> N1 (call bad31)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the false branch, At N76 of Function helperBad
> takes the false branch, At N84 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad31)
> takes the false branch, At N8 of Function bad31
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_31.c 115] bad31 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.165s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N203): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call printLine}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N203 of Function main
> Entering function: good35, On N206 -> N37 (call good35)
> takes the false branch, At N41 of Function good35
> Entering function: helperGood, On N59 -> N134 (call helperGood)
> takes the true branch, At N149 of Function helperGood
> takes the true branch, At N159 of Function helperGood
> Leaving function: helperGood, On N133 -> N46 (Return edge from helperGood to good35)
> takes the true branch, At N49 of Function good35
> Leaving function: good35, On N36 -> N207 (Return edge from good35 to main)
> Entering function: bad35, On N207 -> N1 (call bad35)
> takes the true branch, At N5 of Function bad35
> Entering function: helperBad, On N18 -> N63 (call helperBad)
> takes the true branch, At N78 of Function helperBad
> takes the false branch, At N88 of Function helperBad
> takes the false branch, At N96 of Function helperBad
> Leaving function: helperBad, On N62 -> N8 (Return edge from helperBad to bad35)
> takes the false branch, At N11 of Function bad35
<Defect> : N14 -> N230: [call printLine]
N14 -> N230: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_35.c 122] bad35 		[N14 -{call printLine}-> N230]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.164s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N130): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N187
On edge  : N187 -{%1 = load i32, i32* %intOne, align 4}-> N188
Message  : use of uninitialized variable
> Start from entry function: main, At N130 of Function main
> Entering function: good26, On N133 -> N73 (call good26)
> takes the true branch, At N80 of Function good26
> takes the true branch, At N86 of Function good26
> Leaving function: good26, On N72 -> N134 (Return edge from good26 to main)
> Entering function: bad26, On N134 -> N1 (call bad26)
> takes the true branch, At N8 of Function bad26
> takes the false branch, At N14 of Function bad26
> takes the false branch, At N21 of Function bad26
> takes the true branch, At N43 of Function bad26
> Entering function: printStructLine, On N46 -> N181 (call printStructLine)
<Defect> : N187 -> N188: [%1 = load i32, i32* %intOne, align 4]
N187 -> N188: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N190
On edge  : N190 -{%3 = load i32, i32* %intTwo, align 4}-> N191
Message  : use of uninitialized variable
> Start from entry function: main, At N130 of Function main
> Entering function: good26, On N133 -> N73 (call good26)
> takes the true branch, At N80 of Function good26
> takes the true branch, At N86 of Function good26
> Leaving function: good26, On N72 -> N134 (Return edge from good26 to main)
> Entering function: bad26, On N134 -> N1 (call bad26)
> takes the true branch, At N8 of Function bad26
> takes the false branch, At N14 of Function bad26
> takes the false branch, At N21 of Function bad26
> takes the true branch, At N43 of Function bad26
> Entering function: printStructLine, On N46 -> N181 (call printStructLine)
<Defect> : N190 -> N191: [%3 = load i32, i32* %intTwo, align 4]
N190 -> N191: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N46
On edge  : N46 -{call printStructLine}-> N181
Message  : the memory is already freed
> Start from entry function: main, At N130 of Function main
> Entering function: good26, On N133 -> N73 (call good26)
> takes the true branch, At N80 of Function good26
> takes the true branch, At N86 of Function good26
> Leaving function: good26, On N72 -> N134 (Return edge from good26 to main)
> Entering function: bad26, On N134 -> N1 (call bad26)
> takes the true branch, At N8 of Function bad26
> takes the false branch, At N14 of Function bad26
> takes the false branch, At N21 of Function bad26
> takes the true branch, At N43 of Function bad26
<Defect> : N46 -> N181: [call printStructLine]
N46 -> N181: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_26.c 58] printStructLine 		[N187 -{%1 = load i32, i32* %intOne, align 4}-> N188]	(use of uninitialized variable)
	[./416_26.c 58] printStructLine 		[N190 -{%3 = load i32, i32* %intTwo, align 4}-> N191]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_26.c 89] bad26 		[N46 -{call printStructLine}-> N181]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.16s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N193): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N12
On edge  : N12 -{call printLine}-> N220
Message  : the memory is already freed
> Start from entry function: main, At N193 of Function main
> Entering function: good50, On N196 -> N33 (call good50)
> Entering function: helperGood, On N37 -> N124 (call helperGood)
> takes the true branch, At N139 of Function helperGood
> takes the true branch, At N149 of Function helperGood
> Leaving function: helperGood, On N123 -> N38 (Return edge from helperGood to good50)
> takes the true branch, At N41 of Function good50
> Leaving function: good50, On N32 -> N197 (Return edge from good50 to main)
> Entering function: bad50, On N197 -> N1 (call bad50)
> Entering function: helperBad, On N5 -> N53 (call helperBad)
> takes the true branch, At N68 of Function helperBad
> takes the false branch, At N78 of Function helperBad
> takes the false branch, At N86 of Function helperBad
> Leaving function: helperBad, On N52 -> N6 (Return edge from helperBad to bad50)
> takes the false branch, At N9 of Function bad50
<Defect> : N12 -> N220: [call printLine]
N12 -> N220: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_50.c 116] bad50 		[N12 -{call printLine}-> N220]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.189s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N149): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N52
On edge  : N52 -{%12 = load i64, i64* %arrayidx12, align 8}-> N53
Message  : use of uninitialized variable
> Start from entry function: main, At N149 of Function main
> Entering function: good47, On N152 -> N84 (call good47)
> takes the true branch, At N97 of Function good47
> takes the true branch, At N103 of Function good47
> Leaving function: good47, On N83 -> N153 (Return edge from good47 to main)
> Entering function: bad47, On N153 -> N1 (call bad47)
> takes the true branch, At N14 of Function bad47
> takes the false branch, At N20 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the false branch, At N27 of Function bad47
> takes the false branch, At N14 of Function bad47
> takes the true branch, At N49 of Function bad47
<Defect> : N52 -> N53: [%12 = load i64, i64* %arrayidx12, align 8]
N52 -> N53: [%12 = load i64, i64* %arrayidx12, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N52
On edge  : N52 -{%12 = load i64, i64* %arrayidx12, align 8}-> N53
Message  : the memory is already freed
> Start from entry function: main, At N149 of Function main
> Entering function: good47, On N152 -> N84 (call good47)
> takes the true branch, At N97 of Function good47
> takes the true branch, At N103 of Function good47
> Leaving function: good47, On N83 -> N153 (Return edge from good47 to main)
> Entering function: bad47, On N153 -> N1 (call bad47)
> takes the true branch, At N14 of Function bad47
> takes the false branch, At N20 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the true branch, At N27 of Function bad47
> takes the false branch, At N27 of Function bad47
> takes the false branch, At N14 of Function bad47
> takes the true branch, At N49 of Function bad47
<Defect> : N52 -> N53: [%12 = load i64, i64* %arrayidx12, align 8]
N52 -> N53: [%12 = load i64, i64* %arrayidx12, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_47.c 82] bad47 		[N52 -{%12 = load i64, i64* %arrayidx12, align 8}-> N53]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_47.c 82] bad47 		[N52 -{%12 = load i64, i64* %arrayidx12, align 8}-> N53]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.181s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N119): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N40
On edge  : N40 -{%9 = load i64, i64* %arrayidx8, align 8}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N119 of Function main
> Entering function: good20, On N122 -> N68 (call good20)
> Entering function: staticReturnsTrue, On N73 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N74 (Return edge from staticReturnsTrue to good20)
> takes the true branch, At N75 of Function good20
> takes the true branch, At N81 of Function good20
> Leaving function: good20, On N67 -> N123 (Return edge from good20 to main)
> Entering function: bad20, On N123 -> N1 (call bad20)
> Entering function: staticReturnsTrue, On N6 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N7 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N8 of Function bad20
> takes the false branch, At N14 of Function bad20
> takes the false branch, At N21 of Function bad20
> Entering function: staticReturnsTrue, On N35 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N36 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N37 of Function bad20
<Defect> : N40 -> N41: [%9 = load i64, i64* %arrayidx8, align 8]
N40 -> N41: [%9 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{%9 = load i64, i64* %arrayidx8, align 8}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N119 of Function main
> Entering function: good20, On N122 -> N68 (call good20)
> Entering function: staticReturnsTrue, On N73 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N74 (Return edge from staticReturnsTrue to good20)
> takes the true branch, At N75 of Function good20
> takes the true branch, At N81 of Function good20
> Leaving function: good20, On N67 -> N123 (Return edge from good20 to main)
> Entering function: bad20, On N123 -> N1 (call bad20)
> Entering function: staticReturnsTrue, On N6 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N7 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N8 of Function bad20
> takes the false branch, At N14 of Function bad20
> takes the false branch, At N21 of Function bad20
> Entering function: staticReturnsTrue, On N35 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N36 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N37 of Function bad20
<Defect> : N40 -> N41: [%9 = load i64, i64* %arrayidx8, align 8]
N40 -> N41: [%9 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_20.c 91] bad20 		[N40 -{%9 = load i64, i64* %arrayidx8, align 8}-> N41]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_20.c 91] bad20 		[N40 -{%9 = load i64, i64* %arrayidx8, align 8}-> N41]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.147s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good8, On N98 -> N57 (call good8)
> takes the true branch, At N67 of Function good8
> Leaving function: good8, On N56 -> N99 (Return edge from good8 to main)
> Entering function: bad8, On N99 -> N1 (call bad8)
> takes the false branch, At N11 of Function bad8
> takes the false branch, At N18 of Function bad8
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good8, On N98 -> N57 (call good8)
> takes the true branch, At N67 of Function good8
> Leaving function: good8, On N56 -> N99 (Return edge from good8 to main)
> Entering function: bad8, On N99 -> N1 (call bad8)
> takes the false branch, At N11 of Function bad8
> takes the false branch, At N18 of Function bad8
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_8.c 81] bad8 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_8.c 81] bad8 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.154s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N119): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N40
On edge  : N40 -{%11 = load i64, i64* %arrayidx6, align 8}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N119 of Function main
> Entering function: good17, On N122 -> N68 (call good17)
> takes the true branch, At N75 of Function good17
> takes the true branch, At N81 of Function good17
> Leaving function: good17, On N67 -> N123 (Return edge from good17 to main)
> Entering function: bad17, On N123 -> N1 (call bad17)
> takes the true branch, At N8 of Function bad17
> takes the false branch, At N14 of Function bad17
> takes the false branch, At N21 of Function bad17
> takes the true branch, At N37 of Function bad17
<Defect> : N40 -> N41: [%11 = load i64, i64* %arrayidx6, align 8]
N40 -> N41: [%11 = load i64, i64* %arrayidx6, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{%11 = load i64, i64* %arrayidx6, align 8}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N119 of Function main
> Entering function: good17, On N122 -> N68 (call good17)
> takes the true branch, At N75 of Function good17
> takes the true branch, At N81 of Function good17
> Leaving function: good17, On N67 -> N123 (Return edge from good17 to main)
> Entering function: bad17, On N123 -> N1 (call bad17)
> takes the true branch, At N8 of Function bad17
> takes the false branch, At N14 of Function bad17
> takes the false branch, At N21 of Function bad17
> takes the true branch, At N37 of Function bad17
<Defect> : N40 -> N41: [%11 = load i64, i64* %arrayidx6, align 8]
N40 -> N41: [%11 = load i64, i64* %arrayidx6, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_17.c 84] bad17 		[N40 -{%11 = load i64, i64* %arrayidx6, align 8}-> N41]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_17.c 84] bad17 		[N40 -{%11 = load i64, i64* %arrayidx6, align 8}-> N41]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.139s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N98): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N35
On edge  : N35 -{%9 = load i32, i32* %arrayidx2, align 4}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N98 of Function main
> Entering function: bad44, On N101 -> N1 (call bad44)
> takes the false branch, At N12 of Function bad44
> takes the false branch, At N19 of Function bad44
<Defect> : N35 -> N36: [%9 = load i32, i32* %arrayidx2, align 4]
N35 -> N36: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N35
On edge  : N35 -{%9 = load i32, i32* %arrayidx2, align 4}-> N36
Message  : use of uninitialized variable
> Start from entry function: main, At N98 of Function main
> Entering function: bad44, On N101 -> N1 (call bad44)
> takes the false branch, At N12 of Function bad44
> takes the false branch, At N19 of Function bad44
<Defect> : N35 -> N36: [%9 = load i32, i32* %arrayidx2, align 4]
N35 -> N36: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_44.c 80] bad44 		[N35 -{%9 = load i32, i32* %arrayidx2, align 4}-> N36]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_44.c 80] bad44 		[N35 -{%9 = load i32, i32* %arrayidx2, align 4}-> N36]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.172s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good49, On N194 -> N32 (call good49)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good49)
> takes the true branch, At N39 of Function good49
> Leaving function: good49, On N31 -> N195 (Return edge from good49 to main)
> Entering function: bad49, On N195 -> N1 (call bad49)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the false branch, At N76 of Function helperBad
> takes the false branch, At N84 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad49)
> takes the false branch, At N8 of Function bad49
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_49.c 117] bad49 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.152s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N119): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N40
On edge  : N40 -{%11 = load i32, i32* %arrayidx6, align 4}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N119 of Function main
> Entering function: good11, On N122 -> N68 (call good11)
> takes the true branch, At N75 of Function good11
> takes the true branch, At N81 of Function good11
> Leaving function: good11, On N67 -> N123 (Return edge from good11 to main)
> Entering function: bad11, On N123 -> N1 (call bad11)
> takes the true branch, At N8 of Function bad11
> takes the false branch, At N14 of Function bad11
> takes the false branch, At N21 of Function bad11
> takes the true branch, At N37 of Function bad11
<Defect> : N40 -> N41: [%11 = load i32, i32* %arrayidx6, align 4]
N40 -> N41: [%11 = load i32, i32* %arrayidx6, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{%11 = load i32, i32* %arrayidx6, align 4}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N119 of Function main
> Entering function: good11, On N122 -> N68 (call good11)
> takes the true branch, At N75 of Function good11
> takes the true branch, At N81 of Function good11
> Leaving function: good11, On N67 -> N123 (Return edge from good11 to main)
> Entering function: bad11, On N123 -> N1 (call bad11)
> takes the true branch, At N8 of Function bad11
> takes the false branch, At N14 of Function bad11
> takes the false branch, At N21 of Function bad11
> takes the true branch, At N37 of Function bad11
<Defect> : N40 -> N41: [%11 = load i32, i32* %arrayidx6, align 4]
N40 -> N41: [%11 = load i32, i32* %arrayidx6, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_11.c 84] bad11 		[N40 -{%11 = load i32, i32* %arrayidx6, align 4}-> N41]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_11.c 84] bad11 		[N40 -{%11 = load i32, i32* %arrayidx6, align 4}-> N41]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.154s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good18, On N98 -> N57 (call good18)
> takes the true branch, At N67 of Function good18
> Leaving function: good18, On N56 -> N99 (Return edge from good18 to main)
> Entering function: bad18, On N99 -> N1 (call bad18)
> takes the false branch, At N11 of Function bad18
> takes the false branch, At N18 of Function bad18
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good18, On N98 -> N57 (call good18)
> takes the true branch, At N67 of Function good18
> Leaving function: good18, On N56 -> N99 (Return edge from good18 to main)
> Entering function: bad18, On N99 -> N1 (call bad18)
> takes the false branch, At N11 of Function bad18
> takes the false branch, At N18 of Function bad18
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_18.c 83] bad18 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_18.c 83] bad18 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.147s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good45, On N98 -> N57 (call good45)
> takes the true branch, At N67 of Function good45
> Leaving function: good45, On N56 -> N99 (Return edge from good45 to main)
> Entering function: bad45, On N99 -> N1 (call bad45)
> takes the false branch, At N11 of Function bad45
> takes the false branch, At N18 of Function bad45
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good45, On N98 -> N57 (call good45)
> takes the true branch, At N67 of Function good45
> Leaving function: good45, On N56 -> N99 (Return edge from good45 to main)
> Entering function: bad45, On N99 -> N1 (call bad45)
> takes the false branch, At N11 of Function bad45
> takes the false branch, At N18 of Function bad45
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_45.c 88] bad45 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_45.c 88] bad45 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.205s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N124): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N45
On edge  : N45 -{%11 = load i32, i32* %arrayidx9, align 4}-> N46
Message  : the memory is already freed
> Start from entry function: main, At N124 of Function main
> Entering function: good43, On N127 -> N71 (call good43)
> takes the true branch, At N84 of Function good43
> takes the true branch, At N90 of Function good43
> Leaving function: good43, On N70 -> N128 (Return edge from good43 to main)
> Entering function: bad43, On N128 -> N1 (call bad43)
> takes the true branch, At N12 of Function bad43
> takes the false branch, At N18 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the false branch, At N25 of Function bad43
> takes the false branch, At N12 of Function bad43
<Defect> : N45 -> N46: [%11 = load i32, i32* %arrayidx9, align 4]
N45 -> N46: [%11 = load i32, i32* %arrayidx9, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N45
On edge  : N45 -{%11 = load i32, i32* %arrayidx9, align 4}-> N46
Message  : use of uninitialized variable
> Start from entry function: main, At N124 of Function main
> Entering function: good43, On N127 -> N71 (call good43)
> takes the true branch, At N84 of Function good43
> takes the true branch, At N90 of Function good43
> Leaving function: good43, On N70 -> N128 (Return edge from good43 to main)
> Entering function: bad43, On N128 -> N1 (call bad43)
> takes the true branch, At N12 of Function bad43
> takes the false branch, At N18 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the true branch, At N25 of Function bad43
> takes the false branch, At N25 of Function bad43
> takes the false branch, At N12 of Function bad43
<Defect> : N45 -> N46: [%11 = load i32, i32* %arrayidx9, align 4]
N45 -> N46: [%11 = load i32, i32* %arrayidx9, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_43.c 81] bad43 		[N45 -{%11 = load i32, i32* %arrayidx9, align 4}-> N46]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_43.c 81] bad43 		[N45 -{%11 = load i32, i32* %arrayidx9, align 4}-> N46]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
14 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.168s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N203): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call printLine}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N203 of Function main
> Entering function: good38, On N206 -> N37 (call good38)
> Entering function: staticReturnsFalse, On N39 -> N254 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N253 -> N40 (Return edge from staticReturnsFalse to good38)
> takes the false branch, At N41 of Function good38
> Entering function: helperGood, On N59 -> N134 (call helperGood)
> takes the true branch, At N149 of Function helperGood
> takes the true branch, At N159 of Function helperGood
> Leaving function: helperGood, On N133 -> N46 (Return edge from helperGood to good38)
> takes the true branch, At N49 of Function good38
> Leaving function: good38, On N36 -> N207 (Return edge from good38 to main)
> Entering function: bad38, On N207 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N3 -> N258 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N257 -> N4 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N5 of Function bad38
> Entering function: helperBad, On N18 -> N63 (call helperBad)
> takes the true branch, At N78 of Function helperBad
> takes the false branch, At N88 of Function helperBad
> takes the false branch, At N96 of Function helperBad
> Leaving function: helperBad, On N62 -> N8 (Return edge from helperBad to bad38)
> takes the false branch, At N11 of Function bad38
<Defect> : N14 -> N230: [call printLine]
N14 -> N230: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_38.c 129] bad38 		[N14 -{call printLine}-> N230]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.148s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good10, On N98 -> N57 (call good10)
> takes the true branch, At N67 of Function good10
> Leaving function: good10, On N56 -> N99 (Return edge from good10 to main)
> Entering function: bad10, On N99 -> N1 (call bad10)
> takes the false branch, At N11 of Function bad10
> takes the false branch, At N18 of Function bad10
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good10, On N98 -> N57 (call good10)
> takes the true branch, At N67 of Function good10
> Leaving function: good10, On N56 -> N99 (Return edge from good10 to main)
> Entering function: bad10, On N99 -> N1 (call bad10)
> takes the false branch, At N11 of Function bad10
> takes the false branch, At N18 of Function bad10
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_10.c 84] bad10 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_10.c 84] bad10 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good4, On N66 -> N40 (call good4)
> takes the true branch, At N48 of Function good4
> Leaving function: good4, On N39 -> N67 (Return edge from good4 to main)
> Entering function: bad4, On N67 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_4.c 79] bad4 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.156s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : use of uninitialized variable
> Start from entry function: main, At N95 of Function main
> Entering function: good14, On N98 -> N57 (call good14)
> takes the true branch, At N67 of Function good14
> Leaving function: good14, On N56 -> N99 (Return edge from good14 to main)
> Entering function: bad14, On N99 -> N1 (call bad14)
> takes the false branch, At N11 of Function bad14
> takes the false branch, At N18 of Function bad14
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good14, On N98 -> N57 (call good14)
> takes the true branch, At N67 of Function good14
> Leaving function: good14, On N56 -> N99 (Return edge from good14 to main)
> Entering function: bad14, On N99 -> N1 (call bad14)
> takes the false branch, At N11 of Function bad14
> takes the false branch, At N18 of Function bad14
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./416_14.c 81] bad14 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_14.c 81] bad14 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.154s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N163
On edge  : N163 -{%1 = load i32, i32* %intOne, align 4}-> N164
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good30, On N109 -> N62 (call good30)
> takes the true branch, At N72 of Function good30
> Leaving function: good30, On N61 -> N110 (Return edge from good30 to main)
> Entering function: bad30, On N110 -> N1 (call bad30)
> takes the false branch, At N11 of Function bad30
> takes the false branch, At N18 of Function bad30
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N163 -> N164: [%1 = load i32, i32* %intOne, align 4]
N163 -> N164: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N166
On edge  : N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167
Message  : use of uninitialized variable
> Start from entry function: main, At N106 of Function main
> Entering function: good30, On N109 -> N62 (call good30)
> takes the true branch, At N72 of Function good30
> Leaving function: good30, On N61 -> N110 (Return edge from good30 to main)
> Entering function: bad30, On N110 -> N1 (call bad30)
> takes the false branch, At N11 of Function bad30
> takes the false branch, At N18 of Function bad30
> Entering function: printStructLine, On N39 -> N157 (call printStructLine)
<Defect> : N166 -> N167: [%3 = load i32, i32* %intTwo, align 4]
N166 -> N167: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good30, On N109 -> N62 (call good30)
> takes the true branch, At N72 of Function good30
> Leaving function: good30, On N61 -> N110 (Return edge from good30 to main)
> Entering function: bad30, On N110 -> N1 (call bad30)
> takes the false branch, At N11 of Function bad30
> takes the false branch, At N18 of Function bad30
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./416_30.c 58] printStructLine 		[N163 -{%1 = load i32, i32* %intOne, align 4}-> N164]	(use of uninitialized variable)
	[./416_30.c 58] printStructLine 		[N166 -{%3 = load i32, i32* %intTwo, align 4}-> N167]	(use of uninitialized variable)

CWE_416(Use After Free): 1
	[./416_30.c 86] bad30 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/Juliet_Test_Suite/416/416_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good3, On N66 -> N40 (call good3)
> takes the true branch, At N48 of Function good3
> Leaving function: good3, On N39 -> N67 (Return edge from good3 to main)
> Entering function: bad3, On N67 -> N1 (call bad3)
> takes the false branch, At N9 of Function bad3
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_3.c 76] bad3 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0012_good]
 +memory_leak_0012_good
SCC(1): [memory_leak_0012_bad]
 +memory_leak_0012_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.098s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0012_bad to main}-> N6
Message  : the heap object @H(memory_leak_0012_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0012_good, On N4 -> N39 (call memory_leak_0012_good)
> takes the false branch, At N52 of Function memory_leak_0012_good
> Leaving function: memory_leak_0012_good, On N38 -> N5 (Return edge from memory_leak_0012_good to main)
> Entering function: memory_leak_0012_bad, On N5 -> N9 (call memory_leak_0012_bad)
> takes the false branch, At N18 of Function memory_leak_0012_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0012_bad to main]
N8 -> N6: [Return edge from memory_leak_0012_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_12.c 77] memory_leak_0012_bad 		[N8 -{Return edge from memory_leak_0012_bad to main}-> N6]	(the heap object @H(memory_leak_0012_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_005_good]
 +memory_leak_005_good
SCC(1): [memory_leak_005_bad]
 +memory_leak_005_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_005_bad to main}-> N6
Message  : the heap object @H(memory_leak_005_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_005_good, On N4 -> N45 (call memory_leak_005_good)
> takes the true branch, At N53 of Function memory_leak_005_good
> takes the false branch, At N59 of Function memory_leak_005_good
> Leaving function: memory_leak_005_good, On N44 -> N5 (Return edge from memory_leak_005_good to main)
> Entering function: memory_leak_005_bad, On N5 -> N9 (call memory_leak_005_bad)
> takes the true branch, At N17 of Function memory_leak_005_bad
> takes the true branch, At N23 of Function memory_leak_005_bad
> takes the false branch, At N31 of Function memory_leak_005_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_005_bad to main]
N8 -> N6: [Return edge from memory_leak_005_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_5.c 62] memory_leak_005_bad 		[N8 -{Return edge from memory_leak_005_bad to main}-> N6]	(the heap object @H(memory_leak_005_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_003_func_001_good]
 +memory_leak_003_func_001_good
SCC(1): [memory_leak_003_good]
 +memory_leak_003_good
SCC(1): [memory_leak_003_func_001_bad]
 +memory_leak_003_func_001_bad
SCC(1): [memory_leak_003_bad]
 +memory_leak_003_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N91
On edge  : N91 -{%1 = load i8*, i8** %str1, align 8}-> N92
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_003_good, On N4 -> N81 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N90 -> N53 (call memory_leak_003_func_001_good)
> takes the true branch, At N70 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N52 -> N91 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
<Defect> : N91 -> N92: [%1 = load i8*, i8** %str1, align 8]
N91 -> N92: [%1 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N94
On edge  : N94 -{%3 = load i8*, i8** %str1, align 8}-> N95
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_003_good, On N4 -> N81 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N90 -> N53 (call memory_leak_003_func_001_good)
> takes the true branch, At N70 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N52 -> N91 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
<Defect> : N94 -> N95: [%3 = load i8*, i8** %str1, align 8]
N94 -> N95: [%3 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N19
On edge  : N19 -{%1 = load i8*, i8** %str1, align 8}-> N20
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_003_good, On N4 -> N81 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N90 -> N53 (call memory_leak_003_func_001_good)
> takes the true branch, At N70 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N52 -> N91 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
> Leaving function: memory_leak_003_good, On N80 -> N5 (Return edge from memory_leak_003_good to main)
> Entering function: memory_leak_003_bad, On N5 -> N9 (call memory_leak_003_bad)
> Entering function: memory_leak_003_func_001_bad, On N18 -> N25 (call memory_leak_003_func_001_bad)
> takes the true branch, At N42 of Function memory_leak_003_func_001_bad
> Leaving function: memory_leak_003_func_001_bad, On N24 -> N19 (Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad)
<Defect> : N19 -> N20: [%1 = load i8*, i8** %str1, align 8]
N19 -> N20: [%1 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_003_bad to main}-> N6
Message  : the heap object @H(memory_leak_003_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_003_good, On N4 -> N81 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N90 -> N53 (call memory_leak_003_func_001_good)
> takes the true branch, At N70 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N52 -> N91 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
> Leaving function: memory_leak_003_good, On N80 -> N5 (Return edge from memory_leak_003_good to main)
> Entering function: memory_leak_003_bad, On N5 -> N9 (call memory_leak_003_bad)
> Entering function: memory_leak_003_func_001_bad, On N18 -> N25 (call memory_leak_003_func_001_bad)
> takes the false branch, At N42 of Function memory_leak_003_func_001_bad
> Leaving function: memory_leak_003_func_001_bad, On N24 -> N19 (Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad)
<Defect> : N8 -> N6: [Return edge from memory_leak_003_bad to main]
N8 -> N6: [Return edge from memory_leak_003_bad to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 3
	[./401_memory_leak_3.c 55] memory_leak_003_good 		[N91 -{%1 = load i8*, i8** %str1, align 8}-> N92]	(use of uninitialized variable)
	[./401_memory_leak_3.c 56] memory_leak_003_good 		[N94 -{%3 = load i8*, i8** %str1, align 8}-> N95]	(use of uninitialized variable)
	[./401_memory_leak_3.c 33] memory_leak_003_bad 		[N19 -{%1 = load i8*, i8** %str1, align 8}-> N20]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_memory_leak_3.c 67] memory_leak_003_bad 		[N8 -{Return edge from memory_leak_003_bad to main}-> N6]	(the heap object @H(memory_leak_003_func_001_bad::call) is not referenced any more)

Found 4 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0014_bad]
 +memory_leak_0014_bad
SCC(1): [memory_leak_0014_good]
 +memory_leak_0014_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N82
On edge  : N82 -{call void @free(i8* %10, i8* @free)}-> N83
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0014_good, On N4 -> N47 (call memory_leak_0014_good)
> takes the false branch, At N68 of Function memory_leak_0014_good
<Defect> : N82 -> N83: [call void @free(i8* %10, i8* @free)]
N82 -> N83: [call void @free(i8* %10, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0014_bad to main}-> N6
Message  : the heap object @H(memory_leak_0014_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0014_good, On N4 -> N47 (call memory_leak_0014_good)
> takes the false branch, At N68 of Function memory_leak_0014_good
> Leaving function: memory_leak_0014_good, On N46 -> N5 (Return edge from memory_leak_0014_good to main)
> Entering function: memory_leak_0014_bad, On N5 -> N9 (call memory_leak_0014_bad)
> takes the true branch, At N30 of Function memory_leak_0014_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0014_bad to main]
N8 -> N6: [Return edge from memory_leak_0014_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_14.c 59] memory_leak_0014_good 		[N82 -{call void @free(i8* %10, i8* @free)}-> N83]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_14.c 71] memory_leak_0014_bad 		[N8 -{Return edge from memory_leak_0014_bad to main}-> N6]	(the heap object @H(memory_leak_0014_bad::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_002_good]
 +memory_leak_002_good
SCC(1): [memory_leak_002_bad]
 +memory_leak_002_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.207s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_002_bad to main}-> N6
Message  : the heap object @H(memory_leak_002_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the false branch, At N20 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the true branch, At N42 of Function memory_leak_002_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_002_bad to main]
N8 -> N6: [Return edge from memory_leak_002_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_002_good::call2) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the true branch, At N20 of Function memory_leak_002_bad
> Leaving function: memory_leak_002_bad, On N8 -> N6 (Return edge from memory_leak_002_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_002_bad::call2) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the false branch, At N20 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N42 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N42 of Function memory_leak_002_bad
> takes the false branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N56 of Function memory_leak_002_bad
> Leaving function: memory_leak_002_bad, On N8 -> N6 (Return edge from memory_leak_002_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N192
On edge  : N192 -{store i32 %22, i32* %add.ptr23, align 4}-> N194
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
<Defect> : N192 -> N194: [store i32 %22, i32* %add.ptr23, align 4]
N192 -> N194: [store i32 %22, i32* %add.ptr23, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N204
On edge  : N204 -{call void @free(i8* %31, i8* @free)}-> N206
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
<Defect> : N204 -> N206: [call void @free(i8* %31, i8* @free)]
N204 -> N206: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N204
On edge  : N204 -{call void @free(i8* %31, i8* @free)}-> N206
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
<Defect> : N204 -> N206: [call void @free(i8* %31, i8* @free)]
N204 -> N206: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N191
On edge  : N191 -{%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22}-> N192
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
<Defect> : N191 -> N192: [%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22]
N191 -> N192: [%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N192
On edge  : N192 -{store i32 %22, i32* %add.ptr23, align 4}-> N194
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
<Defect> : N192 -> N194: [store i32 %22, i32* %add.ptr23, align 4]
N192 -> N194: [store i32 %22, i32* %add.ptr23, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N204
On edge  : N204 -{call void @free(i8* %31, i8* @free)}-> N206
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
<Defect> : N204 -> N206: [call void @free(i8* %31, i8* @free)]
N204 -> N206: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N78
On edge  : N78 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N79
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the false branch, At N20 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N42 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N42 of Function memory_leak_002_bad
> takes the false branch, At N28 of Function memory_leak_002_bad
> takes the true branch, At N56 of Function memory_leak_002_bad
> takes the false branch, At N63 of Function memory_leak_002_bad
> takes the true branch, At N69 of Function memory_leak_002_bad
> takes the false branch, At N69 of Function memory_leak_002_bad
> takes the true branch, At N56 of Function memory_leak_002_bad
> takes the false branch, At N63 of Function memory_leak_002_bad
> takes the true branch, At N69 of Function memory_leak_002_bad
<Defect> : N78 -> N79: [%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19]
N78 -> N79: [%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N79
On edge  : N79 -{store i32 %16, i32* %add.ptr20, align 4}-> N81
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the false branch, At N20 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N42 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N42 of Function memory_leak_002_bad
> takes the false branch, At N28 of Function memory_leak_002_bad
> takes the true branch, At N56 of Function memory_leak_002_bad
> takes the false branch, At N63 of Function memory_leak_002_bad
> takes the true branch, At N69 of Function memory_leak_002_bad
> takes the false branch, At N69 of Function memory_leak_002_bad
> takes the true branch, At N56 of Function memory_leak_002_bad
> takes the false branch, At N63 of Function memory_leak_002_bad
> takes the true branch, At N69 of Function memory_leak_002_bad
<Defect> : N79 -> N81: [store i32 %16, i32* %add.ptr20, align 4]
N79 -> N81: [store i32 %16, i32* %add.ptr20, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 3
	[./401_memory_leak_2.c 83] memory_leak_002_bad 		[N8 -{Return edge from memory_leak_002_bad to main}-> N6]	(the heap object @H(memory_leak_002_bad::call) is not referenced any more)
	[./401_memory_leak_2.c 84] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_002_good::call2) is not referenced any more)
	[./401_memory_leak_2.c 84] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_002_bad::call2) is not referenced any more)

CWE_416(Use After Free): 2
	[./401_memory_leak_2.c 68] memory_leak_002_good 		[N192 -{store i32 %22, i32* %add.ptr23, align 4}-> N194]	(the memory is already freed)
	[./401_memory_leak_2.c 70] memory_leak_002_good 		[N204 -{call void @free(i8* %31, i8* @free)}-> N206]	(the memory is already freed)

CWE_415(Double Free): 1
	[./401_memory_leak_2.c 70] memory_leak_002_good 		[N204 -{call void @free(i8* %31, i8* @free)}-> N206]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 5
	[./401_memory_leak_2.c 68] memory_leak_002_good 		[N191 -{%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22}-> N192]	(null pointer dereference)
	[./401_memory_leak_2.c 68] memory_leak_002_good 		[N192 -{store i32 %22, i32* %add.ptr23, align 4}-> N194]	(null pointer dereference)
	[./401_memory_leak_2.c 70] memory_leak_002_good 		[N204 -{call void @free(i8* %31, i8* @free)}-> N206]	(null pointer dereference)
	[./401_memory_leak_2.c 36] memory_leak_002_bad 		[N78 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N79]	(null pointer dereference)
	[./401_memory_leak_2.c 36] memory_leak_002_bad 		[N79 -{store i32 %16, i32* %add.ptr20, align 4}-> N81]	(null pointer dereference)

Found 11 defects in all (22 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_004_bad]
 +memory_leak_004_bad
SCC(1): [memory_leak_004_good]
 +memory_leak_004_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.186s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N172
On edge  : N172 -{call void @free(i8* %24, i8* @free)}-> N174
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
<Defect> : N172 -> N174: [call void @free(i8* %24, i8* @free)]
N172 -> N174: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_004_bad to main}-> N6
Message  : the heap object @H(memory_leak_004_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the true branch, At N98 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N86 -> N5 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N5 -> N9 (call memory_leak_004_bad)
> takes the false branch, At N19 of Function memory_leak_004_bad
> takes the true branch, At N26 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the true branch, At N46 of Function memory_leak_004_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_004_bad to main]
N8 -> N6: [Return edge from memory_leak_004_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_004_bad::call4) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the true branch, At N98 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N86 -> N5 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N5 -> N9 (call memory_leak_004_bad)
> takes the false branch, At N19 of Function memory_leak_004_bad
> takes the true branch, At N26 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the false branch, At N46 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the false branch, At N46 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the false branch, At N46 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the false branch, At N46 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the false branch, At N46 of Function memory_leak_004_bad
> takes the false branch, At N31 of Function memory_leak_004_bad
> takes the true branch, At N64 of Function memory_leak_004_bad
> takes the true branch, At N64 of Function memory_leak_004_bad
> takes the true branch, At N64 of Function memory_leak_004_bad
> takes the true branch, At N64 of Function memory_leak_004_bad
> takes the true branch, At N64 of Function memory_leak_004_bad
> takes the false branch, At N64 of Function memory_leak_004_bad
> Leaving function: memory_leak_004_bad, On N8 -> N6 (Return edge from memory_leak_004_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N172
On edge  : N172 -{call void @free(i8* %24, i8* @free)}-> N174
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
<Defect> : N172 -> N174: [call void @free(i8* %24, i8* @free)]
N172 -> N174: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N172
On edge  : N172 -{call void @free(i8* %24, i8* @free)}-> N174
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
<Defect> : N172 -> N174: [call void @free(i8* %24, i8* @free)]
N172 -> N174: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./401_memory_leak_4.c 78] memory_leak_004_good 		[N172 -{call void @free(i8* %24, i8* @free)}-> N174]	(the memory is already freed)

CWE_401(Memory Leak): 2
	[./401_memory_leak_4.c 90] memory_leak_004_bad 		[N8 -{Return edge from memory_leak_004_bad to main}-> N6]	(the heap object @H(memory_leak_004_bad::call) is not referenced any more)
	[./401_memory_leak_4.c 91] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_004_bad::call4) is not referenced any more)

CWE_416(Use After Free): 1
	[./401_memory_leak_4.c 78] memory_leak_004_good 		[N172 -{call void @free(i8* %24, i8* @free)}-> N174]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_4.c 78] memory_leak_004_good 		[N172 -{call void @free(i8* %24, i8* @free)}-> N174]	(null pointer dereference)

Found 5 defects in all (11 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_009_good]
 +memory_leak_009_good
SCC(1): [memory_leak_009_bad]
 +memory_leak_009_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_009_bad to main}-> N6
Message  : the heap object @H(memory_leak_009_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_009_good, On N4 -> N38 (call memory_leak_009_good)
> takes the false branch, At N49 of Function memory_leak_009_good
> Leaving function: memory_leak_009_good, On N37 -> N5 (Return edge from memory_leak_009_good to main)
> Entering function: memory_leak_009_bad, On N5 -> N9 (call memory_leak_009_bad)
> takes the false branch, At N22 of Function memory_leak_009_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_009_bad to main]
N8 -> N6: [Return edge from memory_leak_009_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_9.c 55] memory_leak_009_bad 		[N8 -{Return edge from memory_leak_009_bad to main}-> N6]	(the heap object @H(memory_leak_009_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_001_good]
 +memory_leak_001_good
SCC(1): [memory_leak_001_bad]
 +memory_leak_001_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_001_bad to main}-> N6
Message  : the heap object @H(memory_leak_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_001_good, On N4 -> N40 (call memory_leak_001_good)
> takes the true branch, At N49 of Function memory_leak_001_good
> takes the false branch, At N54 of Function memory_leak_001_good
> takes the false branch, At N49 of Function memory_leak_001_good
> Leaving function: memory_leak_001_good, On N39 -> N5 (Return edge from memory_leak_001_good to main)
> Entering function: memory_leak_001_bad, On N5 -> N9 (call memory_leak_001_bad)
> takes the true branch, At N18 of Function memory_leak_001_bad
> takes the true branch, At N23 of Function memory_leak_001_bad
> takes the false branch, At N18 of Function memory_leak_001_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_001_bad to main]
N8 -> N6: [Return edge from memory_leak_001_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_1.c 58] memory_leak_001_bad 		[N8 -{Return edge from memory_leak_001_bad to main}-> N6]	(the heap object @H(memory_leak_001_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_007_func_001_bad]
 +memory_leak_007_func_001_bad
SCC(1): [memory_leak_007_bad]
 +memory_leak_007_bad
SCC(1): [memory_leak_007_func_001_good]
 +memory_leak_007_func_001_good
SCC(1): [memory_leak_007_good]
 +memory_leak_007_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_007_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_007_good, On N4 -> N160 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N164 -> N96 (call memory_leak_007_func_001_good)
> matches the value of 1, At N102 of Function memory_leak_007_func_001_good
> takes the false branch, At N109 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N95 -> N165 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the true branch, At N168 of Function memory_leak_007_good
> takes the false branch, At N171 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N159 -> N5 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N5 -> N9 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N13 -> N32 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N38 of Function memory_leak_007_func_001_bad
> takes the true branch, At N45 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N31 -> N14 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N17 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N8 -> N6 (Return edge from memory_leak_007_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_7.c 129] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_007_func_001_bad::call) is not referenced any more)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_006_func_001_good]
 +memory_leak_006_func_001_good
SCC(1): [memory_leak_006_good]
 +memory_leak_006_good
SCC(1): [memory_leak_006_func_001_bad]
 +memory_leak_006_func_001_bad
SCC(1): [memory_leak_006_bad]
 +memory_leak_006_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_006_bad to main}-> N6
Message  : the heap object @H(memory_leak_006_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_006_good, On N4 -> N85 (call memory_leak_006_good)
> Entering function: memory_leak_006_func_001_good, On N92 -> N66 (call memory_leak_006_func_001_good)
> takes the true branch, At N74 of Function memory_leak_006_func_001_good
> Leaving function: memory_leak_006_func_001_good, On N65 -> N93 (Return edge from memory_leak_006_func_001_good to memory_leak_006_good)
> takes the true branch, At N94 of Function memory_leak_006_good
> takes the false branch, At N100 of Function memory_leak_006_good
> Leaving function: memory_leak_006_good, On N84 -> N5 (Return edge from memory_leak_006_good to main)
> Entering function: memory_leak_006_bad, On N5 -> N9 (call memory_leak_006_bad)
> Entering function: memory_leak_006_func_001_bad, On N16 -> N47 (call memory_leak_006_func_001_bad)
> takes the true branch, At N55 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N46 -> N17 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the true branch, At N18 of Function memory_leak_006_bad
> takes the true branch, At N24 of Function memory_leak_006_bad
> Entering function: memory_leak_006_func_001_bad, On N31 -> N47 (call memory_leak_006_func_001_bad)
> takes the true branch, At N55 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N46 -> N32 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the false branch, At N33 of Function memory_leak_006_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_006_bad to main]
N8 -> N6: [Return edge from memory_leak_006_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_6.c 82] memory_leak_006_bad 		[N8 -{Return edge from memory_leak_006_bad to main}-> N6]	(the heap object @H(memory_leak_006_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0013_good]
 +memory_leak_0013_good
SCC(1): [memory_leak_0013_bad]
 +memory_leak_0013_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N81
On edge  : N81 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N82
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0013_good, On N4 -> N55 (call memory_leak_0013_good)
> takes the true branch, At N64 of Function memory_leak_0013_good
> takes the true branch, At N75 of Function memory_leak_0013_good
<Defect> : N81 -> N82: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0]
N81 -> N82: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N37
On edge  : N37 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N38
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0013_good, On N4 -> N55 (call memory_leak_0013_good)
> takes the false branch, At N64 of Function memory_leak_0013_good
> takes the false branch, At N75 of Function memory_leak_0013_good
> Leaving function: memory_leak_0013_good, On N54 -> N5 (Return edge from memory_leak_0013_good to main)
> Entering function: memory_leak_0013_bad, On N5 -> N9 (call memory_leak_0013_bad)
> takes the true branch, At N18 of Function memory_leak_0013_bad
> takes the true branch, At N31 of Function memory_leak_0013_bad
<Defect> : N37 -> N38: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0]
N37 -> N38: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0013_bad to main}-> N6
Message  : the heap object @H(memory_leak_0013_bad::call2) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0013_good, On N4 -> N55 (call memory_leak_0013_good)
> takes the false branch, At N64 of Function memory_leak_0013_good
> takes the false branch, At N75 of Function memory_leak_0013_good
> Leaving function: memory_leak_0013_good, On N54 -> N5 (Return edge from memory_leak_0013_good to main)
> Entering function: memory_leak_0013_bad, On N5 -> N9 (call memory_leak_0013_bad)
> takes the false branch, At N18 of Function memory_leak_0013_bad
> takes the false branch, At N31 of Function memory_leak_0013_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0013_bad to main]
N8 -> N6: [Return edge from memory_leak_0013_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 2
	[./401_memory_leak_13.c 74] memory_leak_0013_good 		[N81 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N82]	(null pointer dereference)
	[./401_memory_leak_13.c 51] memory_leak_0013_bad 		[N37 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N38]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_13.c 89] memory_leak_0013_bad 		[N8 -{Return edge from memory_leak_0013_bad to main}-> N6]	(the heap object @H(memory_leak_0013_bad::call2) is not referenced any more)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0010_bad]
 +memory_leak_0010_bad
SCC(1): [memory_leak_0010_good]
 +memory_leak_0010_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.101s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0010_bad to main}-> N6
Message  : the heap object @H(memory_leak_0010_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0010_good, On N4 -> N43 (call memory_leak_0010_good)
> takes the false branch, At N57 of Function memory_leak_0010_good
> Leaving function: memory_leak_0010_good, On N42 -> N5 (Return edge from memory_leak_0010_good to main)
> Entering function: memory_leak_0010_bad, On N5 -> N9 (call memory_leak_0010_bad)
> takes the false branch, At N19 of Function memory_leak_0010_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0010_bad to main]
N8 -> N6: [Return edge from memory_leak_0010_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_10.c 58] memory_leak_0010_bad 		[N8 -{Return edge from memory_leak_0010_bad to main}-> N6]	(the heap object @H(memory_leak_0010_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_008_good]
 +memory_leak_008_good
SCC(1): [memory_leak_008_bad]
 +memory_leak_008_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.092s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_008_bad to main}-> N6
Message  : the heap object @H(memory_leak_008_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_008_good, On N4 -> N37 (call memory_leak_008_good)
> takes the false branch, At N48 of Function memory_leak_008_good
> Leaving function: memory_leak_008_good, On N36 -> N5 (Return edge from memory_leak_008_good to main)
> Entering function: memory_leak_008_bad, On N5 -> N9 (call memory_leak_008_bad)
> takes the false branch, At N22 of Function memory_leak_008_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_008_bad to main]
N8 -> N6: [Return edge from memory_leak_008_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_8.c 54] memory_leak_008_bad 		[N8 -{Return edge from memory_leak_008_bad to main}-> N6]	(the heap object @H(memory_leak_008_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0011_good]
 +memory_leak_0011_good
SCC(1): [memory_leak_0011_bad]
 +memory_leak_0011_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0011_bad to main}-> N6
Message  : the heap object @H(memory_leak_0011_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0011_good, On N4 -> N31 (call memory_leak_0011_good)
> takes the false branch, At N42 of Function memory_leak_0011_good
> Leaving function: memory_leak_0011_good, On N30 -> N5 (Return edge from memory_leak_0011_good to main)
> Entering function: memory_leak_0011_bad, On N5 -> N9 (call memory_leak_0011_bad)
> takes the true branch, At N19 of Function memory_leak_0011_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0011_bad to main]
N8 -> N6: [Return edge from memory_leak_0011_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_11.c 64] memory_leak_0011_bad 		[N8 -{Return edge from memory_leak_0011_bad to main}-> N6]	(the heap object @H(memory_leak_0011_bad::call) is not referenced any more)

Found 1 defects in all (5 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/401/401_memory_leak_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_0015_func_001_good]
 +memory_leak_0015_func_001_good
SCC(1): [memory_leak_0015_good]
 +memory_leak_0015_good
SCC(1): [memory_leak_0015_func_001_bad]
 +memory_leak_0015_func_001_bad
SCC(1): [memory_leak_0015_bad]
 +memory_leak_0015_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0015_bad to main}-> N6
Message  : the heap object @H(memory_leak_0015_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0015_good, On N4 -> N64 (call memory_leak_0015_good)
> Entering function: memory_leak_0015_func_001_good, On N73 -> N48 (call memory_leak_0015_func_001_good)
> Leaving function: memory_leak_0015_func_001_good, On N47 -> N74 (Return edge from memory_leak_0015_func_001_good to memory_leak_0015_good)
> takes the false branch, At N77 of Function memory_leak_0015_good
> Leaving function: memory_leak_0015_good, On N63 -> N5 (Return edge from memory_leak_0015_good to main)
> Entering function: memory_leak_0015_bad, On N5 -> N9 (call memory_leak_0015_bad)
> Entering function: memory_leak_0015_func_001_bad, On N18 -> N32 (call memory_leak_0015_func_001_bad)
> Leaving function: memory_leak_0015_func_001_bad, On N31 -> N19 (Return edge from memory_leak_0015_func_001_bad to memory_leak_0015_bad)
> takes the true branch, At N22 of Function memory_leak_0015_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0015_bad to main]
N8 -> N6: [Return edge from memory_leak_0015_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_15.c 63] memory_leak_0015_bad 		[N8 -{Return edge from memory_leak_0015_bad to main}-> N6]	(the heap object @H(memory_leak_0015_func_001_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [null_pointer_013_func_001_bad]
 +null_pointer_013_func_001_bad
SCC(1): [null_pointer_013_bad]
 +null_pointer_013_bad
SCC(1): [null_pointer_013_func_001_good]
 +null_pointer_013_func_001_good
SCC(1): [null_pointer_013_good]
 +null_pointer_013_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.09s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N21
On edge  : N21 -{store i32 2, i32* %2, align 4}-> N22
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_013_good, On N4 -> N35 (call null_pointer_013_good)
> Entering function: null_pointer_013_func_001_good, On N38 -> N31 (call null_pointer_013_func_001_good)
> Leaving function: null_pointer_013_func_001_good, On N30 -> N39 (Return edge from null_pointer_013_func_001_good to null_pointer_013_good)
> takes the true branch, At N42 of Function null_pointer_013_good
> Leaving function: null_pointer_013_good, On N34 -> N5 (Return edge from null_pointer_013_good to main)
> Entering function: null_pointer_013_bad, On N5 -> N9 (call null_pointer_013_bad)
> Entering function: null_pointer_013_func_001_bad, On N12 -> N27 (call null_pointer_013_func_001_bad)
> Leaving function: null_pointer_013_func_001_bad, On N26 -> N13 (Return edge from null_pointer_013_func_001_bad to null_pointer_013_bad)
> takes the false branch, At N16 of Function null_pointer_013_bad
<Defect> : N21 -> N22: [store i32 2, i32* %2, align 4]
N21 -> N22: [store i32 2, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_13.c 30] null_pointer_013_bad 		[N21 -{store i32 2, i32* %2, align 4}-> N22]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_011_good]
 +null_pointer_011_good
SCC(1): [null_pointer_011_bad]
 +null_pointer_011_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.076s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N22
On edge  : N22 -{store i32 1, i32* %2, align 4}-> N23
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_011_good, On N4 -> N26 (call null_pointer_011_good)
> Leaving function: null_pointer_011_good, On N25 -> N5 (Return edge from null_pointer_011_good to main)
> Entering function: null_pointer_011_bad, On N5 -> N9 (call null_pointer_011_bad)
<Defect> : N22 -> N23: [store i32 1, i32* %2, align 4]
N22 -> N23: [store i32 1, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_11.c 24] null_pointer_011_bad 		[N22 -{store i32 1, i32* %2, align 4}-> N23]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_002_bad]
 +null_pointer_002_bad
SCC(1): [null_pointer_002_good]
 +null_pointer_002_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.085s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N16
On edge  : N16 -{%1 = load i32, i32* %0, align 4}-> N17
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_002_good, On N4 -> N21 (call null_pointer_002_good)
> Leaving function: null_pointer_002_good, On N20 -> N5 (Return edge from null_pointer_002_good to main)
> Entering function: null_pointer_002_bad, On N5 -> N9 (call null_pointer_002_bad)
<Defect> : N16 -> N17: [%1 = load i32, i32* %0, align 4]
N16 -> N17: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_2.c 21] null_pointer_002_bad 		[N16 -{%1 = load i32, i32* %0, align 4}-> N17]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_012_good]
 +null_pointer_012_good
SCC(1): [null_pointer_012_bad]
 +null_pointer_012_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.073s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N14
On edge  : N14 -{%arrayidx = getelementptr inbounds i32, i32* %0, i64 3}-> N15
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_012_good, On N4 -> N19 (call null_pointer_012_good)
> Leaving function: null_pointer_012_good, On N18 -> N5 (Return edge from null_pointer_012_good to main)
> Entering function: null_pointer_012_bad, On N5 -> N9 (call null_pointer_012_bad)
<Defect> : N14 -> N15: [%arrayidx = getelementptr inbounds i32, i32* %0, i64 3]
N14 -> N15: [%arrayidx = getelementptr inbounds i32, i32* %0, i64 3] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_12.c 20] null_pointer_012_bad 		[N14 -{%arrayidx = getelementptr inbounds i32, i32* %0, i64 3}-> N15]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_006_bad]
 +null_pointer_006_bad
SCC(1): [null_pointer_006_good]
 +null_pointer_006_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.09s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_005_good]
 +null_pointer_005_good
SCC(1): [null_pointer_005_bad]
 +null_pointer_005_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.078s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N15
On edge  : N15 -{%a = getelementptr inbounds %struct.null_pointer_005_s_001, %struct.null_pointer_005_s_001* %s1, i32 0, i32 0}-> N16
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_005_good, On N4 -> N20 (call null_pointer_005_good)
> Leaving function: null_pointer_005_good, On N19 -> N5 (Return edge from null_pointer_005_good to main)
> Entering function: null_pointer_005_bad, On N5 -> N9 (call null_pointer_005_bad)
<Defect> : N15 -> N16: [%a = getelementptr inbounds %struct.null_pointer_005_s_001, %struct.null_pointer_005_s_001* %s1, i32 0, i32 0]
N15 -> N16: [%a = getelementptr inbounds %struct.null_pointer_005_s_001, %struct.null_pointer_005_s_001* %s1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_5.c 41] null_pointer_005_bad 		[N15 -{%a = getelementptr inbounds %struct.null_pointer_005_s_001, %struct.null_pointer_005_s_001* %s1, i32 0, i32 0}-> N16]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_004_good]
 +null_pointer_004_good
SCC(1): [null_pointer_004_bad]
 +null_pointer_004_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.082s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N14
On edge  : N14 -{%a = getelementptr inbounds %struct.null_pointer_004_s_001, %struct.null_pointer_004_s_001* %0, i32 0, i32 0}-> N15
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_004_good, On N4 -> N19 (call null_pointer_004_good)
> Leaving function: null_pointer_004_good, On N18 -> N5 (Return edge from null_pointer_004_good to main)
> Entering function: null_pointer_004_bad, On N5 -> N9 (call null_pointer_004_bad)
<Defect> : N14 -> N15: [%a = getelementptr inbounds %struct.null_pointer_004_s_001, %struct.null_pointer_004_s_001* %0, i32 0, i32 0]
N14 -> N15: [%a = getelementptr inbounds %struct.null_pointer_004_s_001, %struct.null_pointer_004_s_001* %0, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_4.c 26] null_pointer_004_bad 		[N14 -{%a = getelementptr inbounds %struct.null_pointer_004_s_001, %struct.null_pointer_004_s_001* %0, i32 0, i32 0}-> N15]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_007_good]
 +null_pointer_007_good
SCC(1): [null_pointer_007_bad]
 +null_pointer_007_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_003_bad]
 +null_pointer_003_bad
SCC(1): [null_pointer_003_good]
 +null_pointer_003_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.076s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N18
On edge  : N18 -{store i32 1, i32* %1, align 4}-> N19
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_003_good, On N4 -> N22 (call null_pointer_003_good)
> Leaving function: null_pointer_003_good, On N21 -> N5 (Return edge from null_pointer_003_good to main)
> Entering function: null_pointer_003_bad, On N5 -> N9 (call null_pointer_003_bad)
<Defect> : N18 -> N19: [store i32 1, i32* %1, align 4]
N18 -> N19: [store i32 1, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_3.c 22] null_pointer_003_bad 		[N18 -{store i32 1, i32* %1, align 4}-> N19]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_001_bad]
 +null_pointer_001_bad
SCC(1): [null_pointer_001_good]
 +null_pointer_001_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.079s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N14
On edge  : N14 -{store i32 1, i32* %0, align 4}-> N15
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_001_good, On N4 -> N18 (call null_pointer_001_good)
> Leaving function: null_pointer_001_good, On N17 -> N5 (Return edge from null_pointer_001_good to main)
> Entering function: null_pointer_001_bad, On N5 -> N9 (call null_pointer_001_bad)
<Defect> : N14 -> N15: [store i32 1, i32* %0, align 4]
N14 -> N15: [store i32 1, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_1.c 20] null_pointer_001_bad 		[N14 -{store i32 1, i32* %0, align 4}-> N15]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_010_good]
 +null_pointer_010_good
SCC(1): [null_pointer_010_bad]
 +null_pointer_010_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.079s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N18
On edge  : N18 -{store i32 1, i32* %1, align 4}-> N19
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_010_good, On N4 -> N22 (call null_pointer_010_good)
> Leaving function: null_pointer_010_good, On N21 -> N5 (Return edge from null_pointer_010_good to main)
> Entering function: null_pointer_010_bad, On N5 -> N9 (call null_pointer_010_bad)
<Defect> : N18 -> N19: [store i32 1, i32* %1, align 4]
N18 -> N19: [store i32 1, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_10.c 24] null_pointer_010_bad 		[N18 -{store i32 1, i32* %1, align 4}-> N19]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [null_pointer_008_func_001_bad]
 +null_pointer_008_func_001_bad
SCC(1): [null_pointer_008_bad]
 +null_pointer_008_bad
SCC(1): [null_pointer_008_func_001_good]
 +null_pointer_008_func_001_good
SCC(1): [null_pointer_008_good]
 +null_pointer_008_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.095s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N15
On edge  : N15 -{store i32 1, i32* %0, align 4}-> N16
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_008_good, On N4 -> N27 (call null_pointer_008_good)
> Entering function: null_pointer_008_func_001_good, On N30 -> N23 (call null_pointer_008_func_001_good)
> Leaving function: null_pointer_008_func_001_good, On N22 -> N31 (Return edge from null_pointer_008_func_001_good to null_pointer_008_good)
> Leaving function: null_pointer_008_good, On N26 -> N5 (Return edge from null_pointer_008_good to main)
> Entering function: null_pointer_008_bad, On N5 -> N9 (call null_pointer_008_bad)
> Entering function: null_pointer_008_func_001_bad, On N12 -> N19 (call null_pointer_008_func_001_bad)
> Leaving function: null_pointer_008_func_001_bad, On N18 -> N13 (Return edge from null_pointer_008_func_001_bad to null_pointer_008_bad)
<Defect> : N15 -> N16: [store i32 1, i32* %0, align 4]
N15 -> N16: [store i32 1, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_8.c 26] null_pointer_008_bad 		[N15 -{store i32 1, i32* %0, align 4}-> N16]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/476/476_null_pointer_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [null_pointer_009_func_001_good]
 +null_pointer_009_func_001_good
SCC(1): [null_pointer_009_good]
 +null_pointer_009_good
SCC(1): [null_pointer_009_func_001_bad]
 +null_pointer_009_func_001_bad
SCC(1): [null_pointer_009_bad]
 +null_pointer_009_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.093s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N19
On edge  : N19 -{store i32 1, i32* %0, align 4}-> N20
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_009_good, On N4 -> N32 (call null_pointer_009_good)
> Entering function: null_pointer_009_func_001_good, On N36 -> N23 (call null_pointer_009_func_001_good)
> Leaving function: null_pointer_009_func_001_good, On N22 -> N37 (Return edge from null_pointer_009_func_001_good to null_pointer_009_good)
> Leaving function: null_pointer_009_good, On N31 -> N5 (Return edge from null_pointer_009_good to main)
> Entering function: null_pointer_009_bad, On N5 -> N9 (call null_pointer_009_bad)
> Entering function: null_pointer_009_func_001_bad, On N9 -> N14 (call null_pointer_009_func_001_bad)
<Defect> : N19 -> N20: [store i32 1, i32* %0, align 4]
N19 -> N20: [store i32 1, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_9.c 19] null_pointer_009_func_001_bad 		[N19 -{store i32 1, i32* %0, align 4}-> N20]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_underflow_001_bad]
 +data_underflow_001_bad
SCC(1): [data_underflow_001_good]
 +data_underflow_001_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.066s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N8
On edge  : N8 -{%sub = sub i32 %0, 2}-> N9
Message  : integer underflow
> Start from entry function: main, At N25 of Function main
> Entering function: data_underflow_001_good, On N28 -> N13 (call data_underflow_001_good)
> Leaving function: data_underflow_001_good, On N12 -> N29 (Return edge from data_underflow_001_good to main)
> Entering function: data_underflow_001_bad, On N29 -> N1 (call data_underflow_001_bad)
<Defect> : N8 -> N9: [%sub = sub i32 %0, 2]
N8 -> N9: [%sub = sub i32 %0, 2] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_data_underflow_1.c 11] data_underflow_001_bad 		[N8 -{%sub = sub i32 %0, 2}-> N9]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_underflow_003_bad]
 +data_underflow_003_bad
SCC(1): [data_underflow_003_good]
 +data_underflow_003_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.087s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N11
On edge  : N11 -{%dec1 = add i32 %1, -1}-> N12
Message  : integer underflow
> Start from entry function: main, At N35 of Function main
> Entering function: data_underflow_003_good, On N38 -> N18 (call data_underflow_003_good)
> Leaving function: data_underflow_003_good, On N17 -> N39 (Return edge from data_underflow_003_good to main)
> Entering function: data_underflow_003_bad, On N39 -> N1 (call data_underflow_003_bad)
<Defect> : N11 -> N12: [%dec1 = add i32 %1, -1]
N11 -> N12: [%dec1 = add i32 %1, -1] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_data_underflow_2.c 12] data_underflow_003_bad 		[N11 -{%dec1 = add i32 %1, -1}-> N12]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_underflow_004_bad]
 +data_underflow_004_bad
SCC(1): [data_underflow_004_good]
 +data_underflow_004_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.083s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N8
On edge  : N8 -{%sub = sub i32 %0, 128}-> N9
Message  : integer underflow
> Start from entry function: main, At N25 of Function main
> Entering function: data_underflow_004_good, On N28 -> N13 (call data_underflow_004_good)
> Leaving function: data_underflow_004_good, On N12 -> N29 (Return edge from data_underflow_004_good to main)
> Entering function: data_underflow_004_bad, On N29 -> N1 (call data_underflow_004_bad)
<Defect> : N8 -> N9: [%sub = sub i32 %0, 128]
N8 -> N9: [%sub = sub i32 %0, 128] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_data_underflow_3.c 11] data_underflow_004_bad 		[N8 -{%sub = sub i32 %0, 128}-> N9]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_underflow_012_bad]
 +data_underflow_012_bad
SCC(1): [data_underflow_012_good]
 +data_underflow_012_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.08s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N37): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N14
On edge  : N14 -{%add = add i32 %1, %2}-> N15
Message  : integer underflow
> Start from entry function: main, At N37 of Function main
> Entering function: data_underflow_012_good, On N40 -> N19 (call data_underflow_012_good)
> Leaving function: data_underflow_012_good, On N18 -> N41 (Return edge from data_underflow_012_good to main)
> Entering function: data_underflow_012_bad, On N41 -> N1 (call data_underflow_012_bad)
<Defect> : N14 -> N15: [%add = add i32 %1, %2]
N14 -> N15: [%add = add i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_data_underflow_9.c 12] data_underflow_012_bad 		[N14 -{%add = add i32 %1, %2}-> N15]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [data_underflow_010_func_001]
 +data_underflow_010_func_001
SCC(1): [data_underflow_010_bad]
 +data_underflow_010_bad
SCC(1): [data_underflow_010_good]
 +data_underflow_010_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.07s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N31): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N9
On edge  : N9 -{%sub = sub i32 %0, %call}-> N10
Message  : integer underflow
> Start from entry function: main, At N31 of Function main
> Entering function: data_underflow_010_good, On N34 -> N18 (call data_underflow_010_good)
> Entering function: data_underflow_010_func_001, On N25 -> N14 (call data_underflow_010_func_001)
> Leaving function: data_underflow_010_func_001, On N13 -> N26 (Return edge from data_underflow_010_func_001 to data_underflow_010_good)
> Leaving function: data_underflow_010_good, On N17 -> N35 (Return edge from data_underflow_010_good to main)
> Entering function: data_underflow_010_bad, On N35 -> N1 (call data_underflow_010_bad)
> Entering function: data_underflow_010_func_001, On N8 -> N14 (call data_underflow_010_func_001)
> Leaving function: data_underflow_010_func_001, On N13 -> N9 (Return edge from data_underflow_010_func_001 to data_underflow_010_bad)
<Defect> : N9 -> N10: [%sub = sub i32 %0, %call]
N9 -> N10: [%sub = sub i32 %0, %call] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_data_underflow_6.c 16] data_underflow_010_bad 		[N9 -{%sub = sub i32 %0, %call}-> N10]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_underflow_005_bad]
 +data_underflow_005_bad
SCC(1): [data_underflow_005_good]
 +data_underflow_005_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.077s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N8
On edge  : N8 -{%mul = mul i32 %0, 2}-> N9
Message  : integer underflow
> Start from entry function: main, At N25 of Function main
> Entering function: data_underflow_005_good, On N28 -> N13 (call data_underflow_005_good)
> Leaving function: data_underflow_005_good, On N12 -> N29 (Return edge from data_underflow_005_good to main)
> Entering function: data_underflow_005_bad, On N29 -> N1 (call data_underflow_005_bad)
<Defect> : N8 -> N9: [%mul = mul i32 %0, 2]
N8 -> N9: [%mul = mul i32 %0, 2] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_data_underflow_4.c 11] data_underflow_005_bad 		[N8 -{%mul = mul i32 %0, 2}-> N9]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [data_underflow_011_func_001_bad]
 +data_underflow_011_func_001_bad
SCC(1): [data_underflow_011_bad]
 +data_underflow_011_bad
SCC(1): [data_underflow_011_func_001_good]
 +data_underflow_011_func_001_good
SCC(1): [data_underflow_011_good]
 +data_underflow_011_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.073s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N17
On edge  : N17 -{%sub = sub i32 %0, %1}-> N18
Message  : integer underflow
> Start from entry function: main, At N43 of Function main
> Entering function: data_underflow_011_good, On N46 -> N38 (call data_underflow_011_good)
> Entering function: data_underflow_011_func_001_good, On N38 -> N22 (call data_underflow_011_func_001_good)
> Leaving function: data_underflow_011_func_001_good, On N21 -> N40 (Return edge from data_underflow_011_func_001_good to data_underflow_011_good)
> Leaving function: data_underflow_011_good, On N37 -> N47 (Return edge from data_underflow_011_good to main)
> Entering function: data_underflow_011_bad, On N47 -> N1 (call data_underflow_011_bad)
> Entering function: data_underflow_011_func_001_bad, On N1 -> N6 (call data_underflow_011_func_001_bad)
<Defect> : N17 -> N18: [%sub = sub i32 %0, %1]
N17 -> N18: [%sub = sub i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_data_underflow_7.c 11] data_underflow_011_func_001_bad 		[N17 -{%sub = sub i32 %0, %1}-> N18]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_underflow_006_bad]
 +data_underflow_006_bad
SCC(1): [data_underflow_006_good]
 +data_underflow_006_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.069s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N15): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/191/191_data_underflow_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_underflow_009_bad]
 +data_underflow_009_bad
SCC(1): [data_underflow_009_good]
 +data_underflow_009_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.072s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N29): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N10
On edge  : N10 -{%conv1 = trunc i32 %sub to i8}-> N11
Message  : integer underflow
> Start from entry function: main, At N29 of Function main
> Entering function: data_underflow_009_good, On N32 -> N15 (call data_underflow_009_good)
> Leaving function: data_underflow_009_good, On N14 -> N33 (Return edge from data_underflow_009_good to main)
> Entering function: data_underflow_009_bad, On N33 -> N1 (call data_underflow_009_bad)
<Defect> : N10 -> N11: [%conv1 = trunc i32 %sub to i8]
N10 -> N11: [%conv1 = trunc i32 %sub to i8] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 1
	[./191_data_underflow_5.c 11] data_underflow_009_bad 		[N10 -{%conv1 = trunc i32 %sub to i8}-> N11]	(integer underflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_003_bad]
 +bit_shift_003_bad
SCC(1): [bit_shift_003_good]
 +bit_shift_003_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.084s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N8
On edge  : N8 -{%shl = shl i32 %0, 32}-> N9
Message  : integer overflow
> Start from entry function: main, At N25 of Function main
> Entering function: bit_shift_003_good, On N28 -> N13 (call bit_shift_003_good)
> Leaving function: bit_shift_003_good, On N12 -> N29 (Return edge from bit_shift_003_good to main)
> Entering function: bit_shift_003_bad, On N29 -> N1 (call bit_shift_003_bad)
<Defect> : N8 -> N9: [%shl = shl i32 %0, 32]
N8 -> N9: [%shl = shl i32 %0, 32] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_2.c 11] bit_shift_003_bad 		[N8 -{%shl = shl i32 %0, 32}-> N9]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_017_bad]
 +bit_shift_017_bad
SCC(1): [bit_shift_017_good]
 +bit_shift_017_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.068s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N15): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Undefined Behavior
At node  : N4
On edge  : N4 -{store i32 undef, i32* %ret, align 4}-> N5
Message  : undefined behavior
> Start from entry function: main, At N15 of Function main
> Entering function: bit_shift_017_good, On N18 -> N8 (call bit_shift_017_good)
> Leaving function: bit_shift_017_good, On N7 -> N19 (Return edge from bit_shift_017_good to main)
> Entering function: bit_shift_017_bad, On N19 -> N1 (call bit_shift_017_bad)
<Defect> : N4 -> N5: [store i32 undef, i32* %ret, align 4]
N4 -> N5: [store i32 undef, i32* %ret, align 4] <--
-- end of trace --
=====================================================
UNDEFINED_BEHAVIOR(Undefined Behavior): 1
	[./190_bit_shift_14.c 10] bit_shift_017_bad 		[N4 -{store i32 undef, i32* %ret, align 4}-> N5]	(undefined behavior)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_015_bad]
 +bit_shift_015_bad
SCC(1): [bit_shift_015_good]
 +bit_shift_015_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.086s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N41): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N16
On edge  : N16 -{%shl = shl i32 %1, %2}-> N17
Message  : integer overflow
> Start from entry function: main, At N41 of Function main
> Entering function: bit_shift_015_good, On N44 -> N21 (call bit_shift_015_good)
> Leaving function: bit_shift_015_good, On N20 -> N45 (Return edge from bit_shift_015_good to main)
> Entering function: bit_shift_015_bad, On N45 -> N1 (call bit_shift_015_bad)
<Defect> : N16 -> N17: [%shl = shl i32 %1, %2]
N16 -> N17: [%shl = shl i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_12.c 14] bit_shift_015_bad 		[N16 -{%shl = shl i32 %1, %2}-> N17]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [bit_shift_013_func_001]
 +bit_shift_013_func_001
SCC(1): [bit_shift_013_bad]
 +bit_shift_013_bad
SCC(1): [bit_shift_013_good]
 +bit_shift_013_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.071s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N27): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%shl = shl i32 %0, %1}-> N18
Message  : integer overflow
> Start from entry function: main, At N27 of Function main
> Entering function: bit_shift_013_good, On N30 -> N22 (call bit_shift_013_good)
> Entering function: bit_shift_013_func_001, On N22 -> N6 (call bit_shift_013_func_001)
> Leaving function: bit_shift_013_func_001, On N5 -> N24 (Return edge from bit_shift_013_func_001 to bit_shift_013_good)
> Leaving function: bit_shift_013_good, On N21 -> N31 (Return edge from bit_shift_013_good to main)
> Entering function: bit_shift_013_bad, On N31 -> N1 (call bit_shift_013_bad)
> Entering function: bit_shift_013_func_001, On N1 -> N6 (call bit_shift_013_func_001)
<Defect> : N17 -> N18: [%shl = shl i32 %0, %1]
N17 -> N18: [%shl = shl i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_10.c 11] bit_shift_013_func_001 		[N17 -{%shl = shl i32 %0, %1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_012_bad]
 +data_overflow_012_bad
SCC(1): [data_overflow_012_good]
 +data_overflow_012_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.082s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N8
On edge  : N8 -{%add = add i32 %0, 128}-> N9
Message  : integer overflow
> Start from entry function: main, At N25 of Function main
> Entering function: data_overflow_012_good, On N28 -> N13 (call data_overflow_012_good)
> Leaving function: data_overflow_012_good, On N12 -> N29 (Return edge from data_overflow_012_good to main)
> Entering function: data_overflow_012_bad, On N29 -> N1 (call data_overflow_012_bad)
<Defect> : N8 -> N9: [%add = add i32 %0, 128]
N8 -> N9: [%add = add i32 %0, 128] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_5.c 11] data_overflow_012_bad 		[N8 -{%add = add i32 %0, 128}-> N9]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_016_bad]
 +data_overflow_016_bad
SCC(1): [data_overflow_016_good]
 +data_overflow_016_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.092s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N27): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N9
On edge  : N9 -{%add = add i32 %mul, 3}-> N10
Message  : integer overflow
> Start from entry function: main, At N27 of Function main
> Entering function: data_overflow_016_good, On N30 -> N14 (call data_overflow_016_good)
> Leaving function: data_overflow_016_good, On N13 -> N31 (Return edge from data_overflow_016_good to main)
> Entering function: data_overflow_016_bad, On N31 -> N1 (call data_overflow_016_bad)
<Defect> : N9 -> N10: [%add = add i32 %mul, 3]
N9 -> N10: [%add = add i32 %mul, 3] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_10.c 11] data_overflow_016_bad 		[N9 -{%add = add i32 %mul, 3}-> N10]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_009_bad]
 +bit_shift_009_bad
SCC(1): [bit_shift_009_good]
 +bit_shift_009_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.089s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N36): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Undefined Behavior
At node  : N13
On edge  : N13 -{%shl = shl i32 %0, %1}-> N14
Message  : undefined behavior
> Start from entry function: main, At N36 of Function main
> Entering function: bit_shift_009_good, On N39 -> N18 (call bit_shift_009_good)
> Leaving function: bit_shift_009_good, On N17 -> N40 (Return edge from bit_shift_009_good to main)
> Entering function: bit_shift_009_bad, On N40 -> N1 (call bit_shift_009_bad)
<Defect> : N13 -> N14: [%shl = shl i32 %0, %1]
N13 -> N14: [%shl = shl i32 %0, %1] <--
-- end of trace --
=====================================================
UNDEFINED_BEHAVIOR(Undefined Behavior): 1
	[./190_bit_shift_6.c 16] bit_shift_009_bad 		[N13 -{%shl = shl i32 %0, %1}-> N14]	(undefined behavior)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_008_bad]
 +bit_shift_008_bad
SCC(1): [bit_shift_008_good]
 +bit_shift_008_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.073s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N12
On edge  : N12 -{%shl = shl i32 %0, %1}-> N13
Message  : integer overflow
> Start from entry function: main, At N33 of Function main
> Entering function: bit_shift_008_good, On N36 -> N17 (call bit_shift_008_good)
> Leaving function: bit_shift_008_good, On N16 -> N37 (Return edge from bit_shift_008_good to main)
> Entering function: bit_shift_008_bad, On N37 -> N1 (call bit_shift_008_bad)
<Defect> : N12 -> N13: [%shl = shl i32 %0, %1]
N12 -> N13: [%shl = shl i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_5.c 12] bit_shift_008_bad 		[N12 -{%shl = shl i32 %0, %1}-> N13]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_014_bad]
 +data_overflow_014_bad
SCC(1): [data_overflow_014_good]
 +data_overflow_014_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.069s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N12
On edge  : N12 -{%add = add i32 %0, %1}-> N13
Message  : integer overflow
> Start from entry function: main, At N33 of Function main
> Entering function: data_overflow_014_good, On N36 -> N17 (call data_overflow_014_good)
> Leaving function: data_overflow_014_good, On N16 -> N37 (Return edge from data_overflow_014_good to main)
> Entering function: data_overflow_014_bad, On N37 -> N1 (call data_overflow_014_bad)
<Defect> : N12 -> N13: [%add = add i32 %0, %1]
N12 -> N13: [%add = add i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_8.c 12] data_overflow_014_bad 		[N12 -{%add = add i32 %0, %1}-> N13]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [data_overflow_019_func_001_bad]
 +data_overflow_019_func_001_bad
SCC(1): [data_overflow_019_bad]
 +data_overflow_019_bad
SCC(1): [data_overflow_019_func_001_good]
 +data_overflow_019_func_001_good
SCC(1): [data_overflow_019_good]
 +data_overflow_019_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.081s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%add = add i32 %0, %1}-> N18
Message  : integer overflow
> Start from entry function: main, At N43 of Function main
> Entering function: data_overflow_019_good, On N46 -> N38 (call data_overflow_019_good)
> Entering function: data_overflow_019_func_001_good, On N38 -> N22 (call data_overflow_019_func_001_good)
> Leaving function: data_overflow_019_func_001_good, On N21 -> N40 (Return edge from data_overflow_019_func_001_good to data_overflow_019_good)
> Leaving function: data_overflow_019_good, On N37 -> N47 (Return edge from data_overflow_019_good to main)
> Entering function: data_overflow_019_bad, On N47 -> N1 (call data_overflow_019_bad)
> Entering function: data_overflow_019_func_001_bad, On N1 -> N6 (call data_overflow_019_func_001_bad)
<Defect> : N17 -> N18: [%add = add i32 %0, %1]
N17 -> N18: [%add = add i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_13.c 11] data_overflow_019_func_001_bad 		[N17 -{%add = add i32 %0, %1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_017_bad]
 +data_overflow_017_bad
SCC(1): [data_overflow_017_good]
 +data_overflow_017_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.074s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N29): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N10
On edge  : N10 -{%add = add i32 %mul, 88048}-> N11
Message  : integer overflow
> Start from entry function: main, At N29 of Function main
> Entering function: data_overflow_017_good, On N32 -> N15 (call data_overflow_017_good)
> Leaving function: data_overflow_017_good, On N14 -> N33 (Return edge from data_overflow_017_good to main)
> Entering function: data_overflow_017_bad, On N33 -> N1 (call data_overflow_017_bad)
<Defect> : N10 -> N11: [%add = add i32 %mul, 88048]
N10 -> N11: [%add = add i32 %mul, 88048] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_11.c 11] data_overflow_017_bad 		[N10 -{%add = add i32 %mul, 88048}-> N11]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_001_bad]
 +data_overflow_001_bad
SCC(1): [data_overflow_001_good]
 +data_overflow_001_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.086s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N29): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N10
On edge  : N10 -{%conv1 = trunc i32 %add to i8}-> N11
Message  : integer overflow
> Start from entry function: main, At N29 of Function main
> Entering function: data_overflow_001_good, On N32 -> N15 (call data_overflow_001_good)
> Leaving function: data_overflow_001_good, On N14 -> N33 (Return edge from data_overflow_001_good to main)
> Entering function: data_overflow_001_bad, On N33 -> N1 (call data_overflow_001_bad)
<Defect> : N10 -> N11: [%conv1 = trunc i32 %add to i8]
N10 -> N11: [%conv1 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_1.c 7] data_overflow_001_bad 		[N10 -{%conv1 = trunc i32 %add to i8}-> N11]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_002_bad]
 +data_overflow_002_bad
SCC(1): [data_overflow_002_good]
 +data_overflow_002_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.078s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N29): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N10
On edge  : N10 -{%conv1 = trunc i32 %add to i16}-> N11
Message  : integer overflow
> Start from entry function: main, At N29 of Function main
> Entering function: data_overflow_002_good, On N32 -> N15 (call data_overflow_002_good)
> Leaving function: data_overflow_002_good, On N14 -> N33 (Return edge from data_overflow_002_good to main)
> Entering function: data_overflow_002_bad, On N33 -> N1 (call data_overflow_002_bad)
<Defect> : N10 -> N11: [%conv1 = trunc i32 %add to i16]
N10 -> N11: [%conv1 = trunc i32 %add to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_2.c 11] data_overflow_002_bad 		[N10 -{%conv1 = trunc i32 %add to i16}-> N11]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_015_bad]
 +data_overflow_015_bad
SCC(1): [data_overflow_015_good]
 +data_overflow_015_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.089s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N36): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N13
On edge  : N13 -{%add = add i32 %0, %1}-> N14
Message  : integer overflow
> Start from entry function: main, At N36 of Function main
> Entering function: data_overflow_015_good, On N39 -> N18 (call data_overflow_015_good)
> Leaving function: data_overflow_015_good, On N17 -> N40 (Return edge from data_overflow_015_good to main)
> Entering function: data_overflow_015_bad, On N40 -> N1 (call data_overflow_015_bad)
<Defect> : N13 -> N14: [%add = add i32 %0, %1]
N13 -> N14: [%add = add i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_9.c 16] data_overflow_015_bad 		[N13 -{%add = add i32 %0, %1}-> N14]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [bit_shift_012_func_001_bad]
 +bit_shift_012_func_001_bad
SCC(1): [bit_shift_012_bad]
 +bit_shift_012_bad
SCC(1): [bit_shift_012_func_001_good]
 +bit_shift_012_func_001_good
SCC(1): [bit_shift_012_good]
 +bit_shift_012_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N35): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N9
On edge  : N9 -{%shl = shl i32 %0, %call}-> N10
Message  : integer overflow
> Start from entry function: main, At N35 of Function main
> Entering function: bit_shift_012_good, On N38 -> N22 (call bit_shift_012_good)
> Entering function: bit_shift_012_func_001_good, On N29 -> N18 (call bit_shift_012_func_001_good)
> Leaving function: bit_shift_012_func_001_good, On N17 -> N30 (Return edge from bit_shift_012_func_001_good to bit_shift_012_good)
> Leaving function: bit_shift_012_good, On N21 -> N39 (Return edge from bit_shift_012_good to main)
> Entering function: bit_shift_012_bad, On N39 -> N1 (call bit_shift_012_bad)
> Entering function: bit_shift_012_func_001_bad, On N8 -> N14 (call bit_shift_012_func_001_bad)
> Leaving function: bit_shift_012_func_001_bad, On N13 -> N9 (Return edge from bit_shift_012_func_001_bad to bit_shift_012_bad)
<Defect> : N9 -> N10: [%shl = shl i32 %0, %call]
N9 -> N10: [%shl = shl i32 %0, %call] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_9.c 16] bit_shift_012_bad 		[N9 -{%shl = shl i32 %0, %call}-> N10]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_005_bad]
 +bit_shift_005_bad
SCC(1): [bit_shift_005_good]
 +bit_shift_005_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.069s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Undefined Behavior
At node  : N8
On edge  : N8 -{%shl = shl i32 %0, -1}-> N9
Message  : undefined behavior
> Start from entry function: main, At N25 of Function main
> Entering function: bit_shift_005_good, On N28 -> N13 (call bit_shift_005_good)
> Leaving function: bit_shift_005_good, On N12 -> N29 (Return edge from bit_shift_005_good to main)
> Entering function: bit_shift_005_bad, On N29 -> N1 (call bit_shift_005_bad)
<Defect> : N8 -> N9: [%shl = shl i32 %0, -1]
N8 -> N9: [%shl = shl i32 %0, -1] <--
-- end of trace --
=====================================================
UNDEFINED_BEHAVIOR(Undefined Behavior): 1
	[./190_bit_shift_3.c 11] bit_shift_005_bad 		[N8 -{%shl = shl i32 %0, -1}-> N9]	(undefined behavior)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_007_bad]
 +bit_shift_007_bad
SCC(1): [bit_shift_007_good]
 +bit_shift_007_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.077s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Undefined Behavior
At node  : N8
On edge  : N8 -{%shr = ashr i32 %0, -1}-> N9
Message  : undefined behavior
> Start from entry function: main, At N25 of Function main
> Entering function: bit_shift_007_good, On N28 -> N13 (call bit_shift_007_good)
> Leaving function: bit_shift_007_good, On N12 -> N29 (Return edge from bit_shift_007_good to main)
> Entering function: bit_shift_007_bad, On N29 -> N1 (call bit_shift_007_bad)
<Defect> : N8 -> N9: [%shr = ashr i32 %0, -1]
N8 -> N9: [%shr = ashr i32 %0, -1] <--
-- end of trace --
=====================================================
UNDEFINED_BEHAVIOR(Undefined Behavior): 1
	[./190_bit_shift_4.c 11] bit_shift_007_bad 		[N8 -{%shr = ashr i32 %0, -1}-> N9]	(undefined behavior)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_013_bad]
 +data_overflow_013_bad
SCC(1): [data_overflow_013_good]
 +data_overflow_013_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.087s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N8
On edge  : N8 -{%mul = mul i32 %0, 2}-> N9
Message  : integer overflow
> Start from entry function: main, At N25 of Function main
> Entering function: data_overflow_013_good, On N28 -> N13 (call data_overflow_013_good)
> Leaving function: data_overflow_013_good, On N12 -> N29 (Return edge from data_overflow_013_good to main)
> Entering function: data_overflow_013_bad, On N29 -> N1 (call data_overflow_013_bad)
<Defect> : N8 -> N9: [%mul = mul i32 %0, 2]
N8 -> N9: [%mul = mul i32 %0, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_6.c 11] data_overflow_013_bad 		[N8 -{%mul = mul i32 %0, 2}-> N9]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_011_bad]
 +data_overflow_011_bad
SCC(1): [data_overflow_011_good]
 +data_overflow_011_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.068s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N29): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N8
On edge  : N8 -{%inc = add i32 %0, 1}-> N9
Message  : integer overflow
> Start from entry function: main, At N29 of Function main
> Entering function: data_overflow_011_good, On N32 -> N15 (call data_overflow_011_good)
> Leaving function: data_overflow_011_good, On N14 -> N33 (Return edge from data_overflow_011_good to main)
> Entering function: data_overflow_011_bad, On N33 -> N1 (call data_overflow_011_bad)
<Defect> : N8 -> N9: [%inc = add i32 %0, 1]
N8 -> N9: [%inc = add i32 %0, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_4.c 11] data_overflow_011_bad 		[N8 -{%inc = add i32 %0, 1}-> N9]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_001_bad]
 +bit_shift_001_bad
SCC(1): [bit_shift_001_good]
 +bit_shift_001_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.076s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N8
On edge  : N8 -{%shl = shl i32 %0, 32}-> N9
Message  : integer overflow
> Start from entry function: main, At N25 of Function main
> Entering function: bit_shift_001_good, On N28 -> N13 (call bit_shift_001_good)
> Leaving function: bit_shift_001_good, On N12 -> N29 (Return edge from bit_shift_001_good to main)
> Entering function: bit_shift_001_bad, On N29 -> N1 (call bit_shift_001_bad)
<Defect> : N8 -> N9: [%shl = shl i32 %0, 32]
N8 -> N9: [%shl = shl i32 %0, 32] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_1.c 11] bit_shift_001_bad 		[N8 -{%shl = shl i32 %0, 32}-> N9]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_020_bad]
 +data_overflow_020_bad
SCC(1): [data_overflow_020_good]
 +data_overflow_020_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.078s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N37): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N14
On edge  : N14 -{%add = add i32 %1, %2}-> N15
Message  : integer overflow
> Start from entry function: main, At N37 of Function main
> Entering function: data_overflow_020_good, On N40 -> N19 (call data_overflow_020_good)
> Leaving function: data_overflow_020_good, On N18 -> N41 (Return edge from data_overflow_020_good to main)
> Entering function: data_overflow_020_bad, On N41 -> N1 (call data_overflow_020_bad)
<Defect> : N14 -> N15: [%add = add i32 %1, %2]
N14 -> N15: [%add = add i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_16.c 12] data_overflow_020_bad 		[N14 -{%add = add i32 %1, %2}-> N15]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_014_bad]
 +bit_shift_014_bad
SCC(1): [bit_shift_014_good]
 +bit_shift_014_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.092s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N37): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N14
On edge  : N14 -{%shl = shl i32 %1, %2}-> N15
Message  : integer overflow
> Start from entry function: main, At N37 of Function main
> Entering function: bit_shift_014_good, On N40 -> N19 (call bit_shift_014_good)
> Leaving function: bit_shift_014_good, On N18 -> N41 (Return edge from bit_shift_014_good to main)
> Entering function: bit_shift_014_bad, On N41 -> N1 (call bit_shift_014_bad)
<Defect> : N14 -> N15: [%shl = shl i32 %1, %2]
N14 -> N15: [%shl = shl i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_11.c 12] bit_shift_014_bad 		[N14 -{%shl = shl i32 %1, %2}-> N15]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_022_bad]
 +data_overflow_022_bad
SCC(1): [data_overflow_022_good]
 +data_overflow_022_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.071s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N20
On edge  : N20 -{%add = add i32 %2, %3}-> N21
Message  : integer overflow
> Start from entry function: main, At N49 of Function main
> Entering function: data_overflow_022_good, On N52 -> N25 (call data_overflow_022_good)
> Leaving function: data_overflow_022_good, On N24 -> N53 (Return edge from data_overflow_022_good to main)
> Entering function: data_overflow_022_bad, On N53 -> N1 (call data_overflow_022_bad)
<Defect> : N20 -> N21: [%add = add i32 %2, %3]
N20 -> N21: [%add = add i32 %2, %3] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_15.c 16] data_overflow_022_bad 		[N20 -{%add = add i32 %2, %3}-> N21]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_003_bad]
 +data_overflow_003_bad
SCC(1): [data_overflow_003_good]
 +data_overflow_003_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.08s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N25): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N8
On edge  : N8 -{%add = add i32 %0, 1}-> N9
Message  : integer overflow
> Start from entry function: main, At N25 of Function main
> Entering function: data_overflow_003_good, On N28 -> N13 (call data_overflow_003_good)
> Leaving function: data_overflow_003_good, On N12 -> N29 (Return edge from data_overflow_003_good to main)
> Entering function: data_overflow_003_bad, On N29 -> N1 (call data_overflow_003_bad)
<Defect> : N8 -> N9: [%add = add i32 %0, 1]
N8 -> N9: [%add = add i32 %0, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_3.c 11] data_overflow_003_bad 		[N8 -{%add = add i32 %0, 1}-> N9]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_021_bad]
 +data_overflow_021_bad
SCC(1): [data_overflow_021_good]
 +data_overflow_021_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.083s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N41): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N16
On edge  : N16 -{%add = add i32 %1, %2}-> N17
Message  : integer overflow
> Start from entry function: main, At N41 of Function main
> Entering function: data_overflow_021_good, On N44 -> N21 (call data_overflow_021_good)
> Leaving function: data_overflow_021_good, On N20 -> N45 (Return edge from data_overflow_021_good to main)
> Entering function: data_overflow_021_bad, On N45 -> N1 (call data_overflow_021_bad)
<Defect> : N16 -> N17: [%add = add i32 %1, %2]
N16 -> N17: [%add = add i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_14.c 14] data_overflow_021_bad 		[N16 -{%add = add i32 %1, %2}-> N17]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_010_bad]
 +bit_shift_010_bad
SCC(1): [bit_shift_010_good]
 +bit_shift_010_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.079s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N37): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N14
On edge  : N14 -{%shl = shl i32 %0, %add}-> N15
Message  : integer overflow
> Start from entry function: main, At N37 of Function main
> Entering function: bit_shift_010_good, On N40 -> N19 (call bit_shift_010_good)
> Leaving function: bit_shift_010_good, On N18 -> N41 (Return edge from bit_shift_010_good to main)
> Entering function: bit_shift_010_bad, On N41 -> N1 (call bit_shift_010_bad)
<Defect> : N14 -> N15: [%shl = shl i32 %0, %add]
N14 -> N15: [%shl = shl i32 %0, %add] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_7.c 12] bit_shift_010_bad 		[N14 -{%shl = shl i32 %0, %add}-> N15]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [data_overflow_018_func_001]
 +data_overflow_018_func_001
SCC(1): [data_overflow_018_bad]
 +data_overflow_018_bad
SCC(1): [data_overflow_018_good]
 +data_overflow_018_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.089s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N31): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N9
On edge  : N9 -{%add = add i32 %0, %call}-> N10
Message  : integer overflow
> Start from entry function: main, At N31 of Function main
> Entering function: data_overflow_018_good, On N34 -> N18 (call data_overflow_018_good)
> Entering function: data_overflow_018_func_001, On N25 -> N14 (call data_overflow_018_func_001)
> Leaving function: data_overflow_018_func_001, On N13 -> N26 (Return edge from data_overflow_018_func_001 to data_overflow_018_good)
> Leaving function: data_overflow_018_good, On N17 -> N35 (Return edge from data_overflow_018_good to main)
> Entering function: data_overflow_018_bad, On N35 -> N1 (call data_overflow_018_bad)
> Entering function: data_overflow_018_func_001, On N8 -> N14 (call data_overflow_018_func_001)
> Leaving function: data_overflow_018_func_001, On N13 -> N9 (Return edge from data_overflow_018_func_001 to data_overflow_018_bad)
<Defect> : N9 -> N10: [%add = add i32 %0, %call]
N9 -> N10: [%add = add i32 %0, %call] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_12.c 16] data_overflow_018_bad 		[N9 -{%add = add i32 %0, %call}-> N10]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_011_bad]
 +bit_shift_011_bad
SCC(1): [bit_shift_011_good]
 +bit_shift_011_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.069s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N39): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N15
On edge  : N15 -{%shl = shl i32 %0, %add}-> N16
Message  : integer overflow
> Start from entry function: main, At N39 of Function main
> Entering function: bit_shift_011_good, On N42 -> N20 (call bit_shift_011_good)
> Leaving function: bit_shift_011_good, On N19 -> N43 (Return edge from bit_shift_011_good to main)
> Entering function: bit_shift_011_bad, On N43 -> N1 (call bit_shift_011_bad)
<Defect> : N15 -> N16: [%shl = shl i32 %0, %add]
N15 -> N16: [%shl = shl i32 %0, %add] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_8.c 12] bit_shift_011_bad 		[N15 -{%shl = shl i32 %0, %add}-> N16]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_bit_shift_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_016_bad]
 +bit_shift_016_bad
SCC(1): [bit_shift_016_good]
 +bit_shift_016_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.089s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N49): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N20
On edge  : N20 -{%shl = shl i32 %2, %3}-> N21
Message  : integer overflow
> Start from entry function: main, At N49 of Function main
> Entering function: bit_shift_016_good, On N52 -> N25 (call bit_shift_016_good)
> Leaving function: bit_shift_016_good, On N24 -> N53 (Return edge from bit_shift_016_good to main)
> Entering function: bit_shift_016_bad, On N53 -> N1 (call bit_shift_016_bad)
<Defect> : N20 -> N21: [%shl = shl i32 %2, %3]
N20 -> N21: [%shl = shl i32 %2, %3] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_13.c 16] bit_shift_016_bad 		[N20 -{%shl = shl i32 %2, %3}-> N21]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/190/190_data_overflow_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_014_bad]
 +data_overflow_014_bad
SCC(1): [data_overflow_014_good]
 +data_overflow_014_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.069s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N33): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N12
On edge  : N12 -{%add = add i32 %0, %1}-> N13
Message  : integer overflow
> Start from entry function: main, At N33 of Function main
> Entering function: data_overflow_014_good, On N36 -> N17 (call data_overflow_014_good)
> Leaving function: data_overflow_014_good, On N16 -> N37 (Return edge from data_overflow_014_good to main)
> Entering function: data_overflow_014_bad, On N37 -> N1 (call data_overflow_014_bad)
<Defect> : N12 -> N13: [%add = add i32 %0, %1]
N12 -> N13: [%add = add i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_7.c 12] data_overflow_014_bad 		[N12 -{%add = add i32 %0, %1}-> N13]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_012_good]
 +zero_division_012_good
SCC(1): [zero_division_012_bad]
 +zero_division_012_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.075s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N23
On edge  : N23 -{%div = sdiv i32 %0, %sub}-> N24
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_012_good, On N4 -> N28 (call zero_division_012_good)
> Leaving function: zero_division_012_good, On N27 -> N5 (Return edge from zero_division_012_good to main)
> Entering function: zero_division_012_bad, On N5 -> N9 (call zero_division_012_bad)
<Defect> : N23 -> N24: [%div = sdiv i32 %0, %sub]
N23 -> N24: [%div = sdiv i32 %0, %sub] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_10.c 12] zero_division_012_bad 		[N23 -{%div = sdiv i32 %0, %sub}-> N24]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_002_good]
 +zero_division_002_good
SCC(1): [zero_division_002_bad]
 +zero_division_002_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.083s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N16
On edge  : N16 -{%div = sdiv i32 %0, 0}-> N17
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_002_good, On N4 -> N23 (call zero_division_002_good)
> Leaving function: zero_division_002_good, On N22 -> N5 (Return edge from zero_division_002_good to main)
> Entering function: zero_division_002_bad, On N5 -> N9 (call zero_division_002_bad)
<Defect> : N16 -> N17: [%div = sdiv i32 %0, 0]
N16 -> N17: [%div = sdiv i32 %0, 0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_2.c 11] zero_division_002_bad 		[N16 -{%div = sdiv i32 %0, 0}-> N17]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_011_good]
 +zero_division_011_good
SCC(1): [zero_division_011_bad]
 +zero_division_011_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.07s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N22
On edge  : N22 -{%div = sdiv i32 %0, %sub}-> N23
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_011_good, On N4 -> N27 (call zero_division_011_good)
> Leaving function: zero_division_011_good, On N26 -> N5 (Return edge from zero_division_011_good to main)
> Entering function: zero_division_011_bad, On N5 -> N9 (call zero_division_011_bad)
<Defect> : N22 -> N23: [%div = sdiv i32 %0, %sub]
N22 -> N23: [%div = sdiv i32 %0, %sub] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_9.c 12] zero_division_011_bad 		[N22 -{%div = sdiv i32 %0, %sub}-> N23]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_015_good]
 +zero_division_015_good
SCC(1): [zero_division_015_bad]
 +zero_division_015_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.081s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N24
On edge  : N24 -{%div = sdiv i32 %1, %2}-> N25
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_015_good, On N4 -> N29 (call zero_division_015_good)
> Leaving function: zero_division_015_good, On N28 -> N5 (Return edge from zero_division_015_good to main)
> Entering function: zero_division_015_bad, On N5 -> N9 (call zero_division_015_bad)
<Defect> : N24 -> N25: [%div = sdiv i32 %1, %2]
N24 -> N25: [%div = sdiv i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_13.c 14] zero_division_015_bad 		[N24 -{%div = sdiv i32 %1, %2}-> N25]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_005_good]
 +zero_division_005_good
SCC(1): [zero_division_005_bad]
 +zero_division_005_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N22
On edge  : N22 -{%div = sdiv i32 %1, %2}-> N23
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_005_good, On N4 -> N27 (call zero_division_005_good)
> Leaving function: zero_division_005_good, On N26 -> N5 (Return edge from zero_division_005_good to main)
> Entering function: zero_division_005_bad, On N5 -> N9 (call zero_division_005_bad)
<Defect> : N22 -> N23: [%div = sdiv i32 %1, %2]
N22 -> N23: [%div = sdiv i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_15.c 16] zero_division_005_bad 		[N22 -{%div = sdiv i32 %1, %2}-> N23]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [zero_division_016_func_002_good]
 +zero_division_016_func_002_good
SCC(1): [zero_division_016_func_001_good]
 +zero_division_016_func_001_good
SCC(1): [zero_division_016_good]
 +zero_division_016_good
SCC(1): [zero_division_016_func_002_bad]
 +zero_division_016_func_002_bad
SCC(1): [zero_division_016_func_001_bad]
 +zero_division_016_func_001_bad
SCC(1): [zero_division_016_bad]
 +zero_division_016_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N28
On edge  : N28 -{%div = sdiv i32 %3, %4}-> N29
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_016_good, On N4 -> N67 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N77 -> N42 (call zero_division_016_func_001_good)
> Leaving function: zero_division_016_func_001_good, On N41 -> N78 (Return edge from zero_division_016_func_001_good to zero_division_016_good)
> Entering function: zero_division_016_func_002_good, On N78 -> N59 (call zero_division_016_func_002_good)
> Leaving function: zero_division_016_func_002_good, On N58 -> N79 (Return edge from zero_division_016_func_002_good to zero_division_016_good)
> Leaving function: zero_division_016_good, On N66 -> N5 (Return edge from zero_division_016_good to main)
> Entering function: zero_division_016_bad, On N5 -> N9 (call zero_division_016_bad)
> Entering function: zero_division_016_func_001_bad, On N19 -> N33 (call zero_division_016_func_001_bad)
> Leaving function: zero_division_016_func_001_bad, On N32 -> N20 (Return edge from zero_division_016_func_001_bad to zero_division_016_bad)
> Entering function: zero_division_016_func_002_bad, On N20 -> N51 (call zero_division_016_func_002_bad)
> Leaving function: zero_division_016_func_002_bad, On N50 -> N21 (Return edge from zero_division_016_func_002_bad to zero_division_016_bad)
<Defect> : N28 -> N29: [%div = sdiv i32 %3, %4]
N28 -> N29: [%div = sdiv i32 %3, %4] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(zero_division_016_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_016_good, On N4 -> N67 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N77 -> N42 (call zero_division_016_func_001_good)
> Leaving function: zero_division_016_func_001_good, On N41 -> N78 (Return edge from zero_division_016_func_001_good to zero_division_016_good)
> Entering function: zero_division_016_func_002_good, On N78 -> N59 (call zero_division_016_func_002_good)
> Leaving function: zero_division_016_func_002_good, On N58 -> N79 (Return edge from zero_division_016_func_002_good to zero_division_016_good)
> Leaving function: zero_division_016_good, On N66 -> N5 (Return edge from zero_division_016_good to main)
> Entering function: zero_division_016_bad, On N5 -> N9 (call zero_division_016_bad)
> Entering function: zero_division_016_func_001_bad, On N19 -> N33 (call zero_division_016_func_001_bad)
> Leaving function: zero_division_016_func_001_bad, On N32 -> N20 (Return edge from zero_division_016_func_001_bad to zero_division_016_bad)
> Entering function: zero_division_016_func_002_bad, On N20 -> N51 (call zero_division_016_func_002_bad)
> Leaving function: zero_division_016_func_002_bad, On N50 -> N21 (Return edge from zero_division_016_func_002_bad to zero_division_016_bad)
> Leaving function: zero_division_016_bad, On N8 -> N6 (Return edge from zero_division_016_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(zero_division_016_func_001_good::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_016_good, On N4 -> N67 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N77 -> N42 (call zero_division_016_func_001_good)
> Leaving function: zero_division_016_func_001_good, On N41 -> N78 (Return edge from zero_division_016_func_001_good to zero_division_016_good)
> Entering function: zero_division_016_func_002_good, On N78 -> N59 (call zero_division_016_func_002_good)
> Leaving function: zero_division_016_func_002_good, On N58 -> N79 (Return edge from zero_division_016_func_002_good to zero_division_016_good)
> Leaving function: zero_division_016_good, On N66 -> N5 (Return edge from zero_division_016_good to main)
> Entering function: zero_division_016_bad, On N5 -> N9 (call zero_division_016_bad)
> Entering function: zero_division_016_func_001_bad, On N19 -> N33 (call zero_division_016_func_001_bad)
> Leaving function: zero_division_016_func_001_bad, On N32 -> N20 (Return edge from zero_division_016_func_001_bad to zero_division_016_bad)
> Entering function: zero_division_016_func_002_bad, On N20 -> N51 (call zero_division_016_func_002_bad)
> Leaving function: zero_division_016_func_002_bad, On N50 -> N21 (Return edge from zero_division_016_func_002_bad to zero_division_016_bad)
> Leaving function: zero_division_016_bad, On N8 -> N6 (Return edge from zero_division_016_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N47
On edge  : N47 -{store i32 1, i32* %1, align 4}-> N48
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_016_good, On N4 -> N67 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N77 -> N42 (call zero_division_016_func_001_good)
<Defect> : N47 -> N48: [store i32 1, i32* %1, align 4]
N47 -> N48: [store i32 1, i32* %1, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N38
On edge  : N38 -{store i32 -1, i32* %1, align 4}-> N39
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_016_good, On N4 -> N67 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N77 -> N42 (call zero_division_016_func_001_good)
> Leaving function: zero_division_016_func_001_good, On N41 -> N78 (Return edge from zero_division_016_func_001_good to zero_division_016_good)
> Entering function: zero_division_016_func_002_good, On N78 -> N59 (call zero_division_016_func_002_good)
> Leaving function: zero_division_016_func_002_good, On N58 -> N79 (Return edge from zero_division_016_func_002_good to zero_division_016_good)
> Leaving function: zero_division_016_good, On N66 -> N5 (Return edge from zero_division_016_good to main)
> Entering function: zero_division_016_bad, On N5 -> N9 (call zero_division_016_bad)
> Entering function: zero_division_016_func_001_bad, On N19 -> N33 (call zero_division_016_func_001_bad)
<Defect> : N38 -> N39: [store i32 -1, i32* %1, align 4]
N38 -> N39: [store i32 -1, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_14.c 32] zero_division_016_bad 		[N28 -{%div = sdiv i32 %3, %4}-> N29]	(Divide By Zero)

CWE_401(Memory Leak): 2
	[./369_zero_division_14.c 68] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(zero_division_016_func_001_bad::call) is not referenced any more)
	[./369_zero_division_14.c 68] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(zero_division_016_func_001_good::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 2
	[./369_zero_division_14.c 44] zero_division_016_func_001_good 		[N47 -{store i32 1, i32* %1, align 4}-> N48]	(null pointer dereference)
	[./369_zero_division_14.c 14] zero_division_016_func_001_bad 		[N38 -{store i32 -1, i32* %1, align 4}-> N39]	(null pointer dereference)

Found 5 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [zero_division_007_func_001_good]
 +zero_division_007_func_001_good
SCC(1): [zero_division_007_good]
 +zero_division_007_good
SCC(1): [zero_division_007_func_001_bad]
 +zero_division_007_func_001_bad
SCC(1): [zero_division_007_bad]
 +zero_division_007_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.082s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N18
On edge  : N18 -{%div = sdiv i32 %0, %1}-> N19
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_007_good, On N4 -> N33 (call zero_division_007_good)
> Entering function: zero_division_007_func_001_good, On N39 -> N28 (call zero_division_007_func_001_good)
> Leaving function: zero_division_007_func_001_good, On N27 -> N40 (Return edge from zero_division_007_func_001_good to zero_division_007_good)
> Leaving function: zero_division_007_good, On N32 -> N5 (Return edge from zero_division_007_good to main)
> Entering function: zero_division_007_bad, On N5 -> N9 (call zero_division_007_bad)
> Entering function: zero_division_007_func_001_bad, On N15 -> N23 (call zero_division_007_func_001_bad)
> Leaving function: zero_division_007_func_001_bad, On N22 -> N16 (Return edge from zero_division_007_func_001_bad to zero_division_007_bad)
<Defect> : N18 -> N19: [%div = sdiv i32 %0, %1]
N18 -> N19: [%div = sdiv i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_6.c 25] zero_division_007_bad 		[N18 -{%div = sdiv i32 %0, %1}-> N19]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [zero_division_013_func_001_good]
 +zero_division_013_func_001_good
SCC(1): [zero_division_013_good]
 +zero_division_013_good
SCC(1): [zero_division_013_func_001_bad]
 +zero_division_013_func_001_bad
SCC(1): [zero_division_013_bad]
 +zero_division_013_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.086s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N17
On edge  : N17 -{%div = sdiv i32 %0, %call}-> N18
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_013_good, On N4 -> N30 (call zero_division_013_good)
> Entering function: zero_division_013_func_001_good, On N37 -> N26 (call zero_division_013_func_001_good)
> Leaving function: zero_division_013_func_001_good, On N25 -> N38 (Return edge from zero_division_013_func_001_good to zero_division_013_good)
> Leaving function: zero_division_013_good, On N29 -> N5 (Return edge from zero_division_013_good to main)
> Entering function: zero_division_013_bad, On N5 -> N9 (call zero_division_013_bad)
> Entering function: zero_division_013_func_001_bad, On N16 -> N22 (call zero_division_013_func_001_bad)
> Leaving function: zero_division_013_func_001_bad, On N21 -> N17 (Return edge from zero_division_013_func_001_bad to zero_division_013_bad)
<Defect> : N17 -> N18: [%div = sdiv i32 %0, %call]
N17 -> N18: [%div = sdiv i32 %0, %call] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_11.c 16] zero_division_013_bad 		[N17 -{%div = sdiv i32 %0, %call}-> N18]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [zero_division_004_func_001_good]
 +zero_division_004_func_001_good
SCC(1): [zero_division_004_good]
 +zero_division_004_good
SCC(1): [zero_division_004_func_001_bad]
 +zero_division_004_func_001_bad
SCC(1): [zero_division_004_bad]
 +zero_division_004_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.089s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N20
On edge  : N20 -{%rem = srem i32 %1, %0}-> N21
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_004_good, On N4 -> N33 (call zero_division_004_good)
> Entering function: zero_division_004_func_001_good, On N37 -> N25 (call zero_division_004_func_001_good)
> Leaving function: zero_division_004_func_001_good, On N24 -> N38 (Return edge from zero_division_004_func_001_good to zero_division_004_good)
> Leaving function: zero_division_004_good, On N32 -> N5 (Return edge from zero_division_004_good to main)
> Entering function: zero_division_004_bad, On N5 -> N9 (call zero_division_004_bad)
> Entering function: zero_division_004_func_001_bad, On N13 -> N17 (call zero_division_004_func_001_bad)
<Defect> : N20 -> N21: [%rem = srem i32 %1, %0]
N20 -> N21: [%rem = srem i32 %1, %0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_4.c 11] zero_division_004_func_001_bad 		[N20 -{%rem = srem i32 %1, %0}-> N21]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_003_good]
 +zero_division_003_good
SCC(1): [zero_division_003_bad]
 +zero_division_003_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.083s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N16
On edge  : N16 -{%rem = srem i32 %0, 0}-> N17
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_003_good, On N4 -> N21 (call zero_division_003_good)
> Leaving function: zero_division_003_good, On N20 -> N5 (Return edge from zero_division_003_good to main)
> Entering function: zero_division_003_bad, On N5 -> N9 (call zero_division_003_bad)
<Defect> : N16 -> N17: [%rem = srem i32 %0, 0]
N16 -> N17: [%rem = srem i32 %0, 0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_3.c 11] zero_division_003_bad 		[N16 -{%rem = srem i32 %0, 0}-> N17]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [zero_division_014_func_001]
 +zero_division_014_func_001
SCC(1): [zero_division_014_good]
 +zero_division_014_good
SCC(1): [zero_division_014_bad]
 +zero_division_014_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.08s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N25
On edge  : N25 -{%div = sdiv i32 %0, %1}-> N26
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_014_good, On N4 -> N30 (call zero_division_014_good)
> Entering function: zero_division_014_func_001, On N30 -> N14 (call zero_division_014_func_001)
> Leaving function: zero_division_014_func_001, On N13 -> N32 (Return edge from zero_division_014_func_001 to zero_division_014_good)
> Leaving function: zero_division_014_good, On N29 -> N5 (Return edge from zero_division_014_good to main)
> Entering function: zero_division_014_bad, On N5 -> N9 (call zero_division_014_bad)
> Entering function: zero_division_014_func_001, On N9 -> N14 (call zero_division_014_func_001)
<Defect> : N25 -> N26: [%div = sdiv i32 %0, %1]
N25 -> N26: [%div = sdiv i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_12.c 11] zero_division_014_func_001 		[N25 -{%div = sdiv i32 %0, %1}-> N26]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_009_good]
 +zero_division_009_good
SCC(1): [zero_division_009_bad]
 +zero_division_009_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.073s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N20
On edge  : N20 -{%div = sdiv i32 %0, %1}-> N21
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_009_good, On N4 -> N25 (call zero_division_009_good)
> Leaving function: zero_division_009_good, On N24 -> N5 (Return edge from zero_division_009_good to main)
> Entering function: zero_division_009_bad, On N5 -> N9 (call zero_division_009_bad)
<Defect> : N20 -> N21: [%div = sdiv i32 %0, %1]
N20 -> N21: [%div = sdiv i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_7.c 12] zero_division_009_bad 		[N20 -{%div = sdiv i32 %0, %1}-> N21]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_010_bad]
 +zero_division_010_bad
SCC(1): [zero_division_010_good]
 +zero_division_010_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.085s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N21
On edge  : N21 -{%div = sdiv i32 %0, %1}-> N22
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_010_good, On N4 -> N26 (call zero_division_010_good)
> takes the false branch, At N38 of Function zero_division_010_good
> Leaving function: zero_division_010_good, On N25 -> N5 (Return edge from zero_division_010_good to main)
> Entering function: zero_division_010_bad, On N5 -> N9 (call zero_division_010_bad)
<Defect> : N21 -> N22: [%div = sdiv i32 %0, %1]
N21 -> N22: [%div = sdiv i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_8.c 17] zero_division_010_bad 		[N21 -{%div = sdiv i32 %0, %1}-> N22]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_006_bad]
 +zero_division_006_bad
SCC(1): [zero_division_006_good]
 +zero_division_006_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.082s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N21
On edge  : N21 -{%div = sdiv i32 %0, %2}-> N22
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_006_good, On N4 -> N26 (call zero_division_006_good)
> Leaving function: zero_division_006_good, On N25 -> N5 (Return edge from zero_division_006_good to main)
> Entering function: zero_division_006_bad, On N5 -> N9 (call zero_division_006_bad)
<Defect> : N21 -> N22: [%div = sdiv i32 %0, %2]
N21 -> N22: [%div = sdiv i32 %0, %2] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_5.c 15] zero_division_006_bad 		[N21 -{%div = sdiv i32 %0, %2}-> N22]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/369/369_zero_division_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_001_good]
 +zero_division_001_good
SCC(1): [zero_division_001_bad]
 +zero_division_001_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.066s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N16
On edge  : N16 -{%div = sdiv i32 %0, 0}-> N17
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_001_good, On N4 -> N21 (call zero_division_001_good)
> Leaving function: zero_division_001_good, On N20 -> N5 (Return edge from zero_division_001_good to main)
> Entering function: zero_division_001_bad, On N5 -> N9 (call zero_division_001_bad)
<Defect> : N16 -> N17: [%div = sdiv i32 %0, 0]
N16 -> N17: [%div = sdiv i32 %0, 0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_1.c 11] zero_division_001_bad 		[N16 -{%div = sdiv i32 %0, 0}-> N17]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_var_011_func_001_good]
 +uninit_var_011_func_001_good
SCC(1): [uninit_var_011_good]
 +uninit_var_011_good
SCC(1): [uninit_var_011_func_001_bad]
 +uninit_var_011_func_001_bad
SCC(1): [uninit_var_011_bad]
 +uninit_var_011_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.098s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N40
On edge  : N40 -{%4 = load i32, i32* %arrayidx1, align 4}-> N41
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_011_good, On N4 -> N78 (call uninit_var_011_good)
> Entering function: uninit_var_011_func_001_good, On N86 -> N50 (call uninit_var_011_func_001_good)
> takes the true branch, At N64 of Function uninit_var_011_func_001_good
> Leaving function: uninit_var_011_func_001_good, On N49 -> N87 (Return edge from uninit_var_011_func_001_good to uninit_var_011_good)
> Leaving function: uninit_var_011_good, On N77 -> N5 (Return edge from uninit_var_011_good to main)
> Entering function: uninit_var_011_bad, On N5 -> N9 (call uninit_var_011_bad)
> Entering function: uninit_var_011_func_001_bad, On N17 -> N22 (call uninit_var_011_func_001_bad)
> takes the true branch, At N36 of Function uninit_var_011_func_001_bad
<Defect> : N40 -> N41: [%4 = load i32, i32* %arrayidx1, align 4]
N40 -> N41: [%4 = load i32, i32* %arrayidx1, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_10.c 11] uninit_var_011_func_001_bad 		[N40 -{%4 = load i32, i32* %arrayidx1, align 4}-> N41]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_memory_access_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_memory_access_001_good]
 +uninit_memory_access_001_good
SCC(1): [uninit_memory_access_001_bad]
 +uninit_memory_access_001_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.071s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N14
On edge  : N14 -{store i64* %a, i64** %ret, align 8}-> N15
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_001_good, On N4 -> N18 (call uninit_memory_access_001_good)
> Leaving function: uninit_memory_access_001_good, On N17 -> N5 (Return edge from uninit_memory_access_001_good to main)
> Entering function: uninit_memory_access_001_bad, On N5 -> N9 (call uninit_memory_access_001_bad)
<Defect> : N14 -> N15: [store i64* %a, i64** %ret, align 8]
N14 -> N15: [store i64* %a, i64** %ret, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_memory_access_1.c 11] uninit_memory_access_001_bad 		[N14 -{store i64* %a, i64** %ret, align 8}-> N15]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_var_012_bad]
 +uninit_var_012_bad
SCC(1): [uninit_var_012_good]
 +uninit_var_012_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N19
On edge  : N19 -{%1 = load i32, i32* %uninit, align 4}-> N20
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_012_good, On N4 -> N25 (call uninit_var_012_good)
> Leaving function: uninit_var_012_good, On N24 -> N5 (Return edge from uninit_var_012_good to main)
> Entering function: uninit_var_012_bad, On N5 -> N9 (call uninit_var_012_bad)
<Defect> : N19 -> N20: [%1 = load i32, i32* %uninit, align 4]
N19 -> N20: [%1 = load i32, i32* %uninit, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_11.c 17] uninit_var_012_bad 		[N19 -{%1 = load i32, i32* %uninit, align 4}-> N20]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_memory_access_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_memory_access_006_func_001_good]
 +uninit_memory_access_006_func_001_good
SCC(1): [uninit_memory_access_006_good]
 +uninit_memory_access_006_good
SCC(1): [uninit_memory_access_006_func_001_bad]
 +uninit_memory_access_006_func_001_bad
SCC(1): [uninit_memory_access_006_bad]
 +uninit_memory_access_006_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.165s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N80
On edge  : N80 -{store i8 %4, i8* %5, align 1}-> N81
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_006_good, On N4 -> N98 (call uninit_memory_access_006_good)
> Entering function: uninit_memory_access_006_func_001_good, On N108 -> N60 (call uninit_memory_access_006_func_001_good)
> takes the false branch, At N69 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
<Defect> : N80 -> N81: [store i8 %4, i8* %5, align 1]
N80 -> N81: [store i8 %4, i8* %5, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N42
On edge  : N42 -{store i8 %4, i8* %5, align 1}-> N43
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_006_good, On N4 -> N98 (call uninit_memory_access_006_good)
> Entering function: uninit_memory_access_006_func_001_good, On N108 -> N60 (call uninit_memory_access_006_func_001_good)
> takes the false branch, At N69 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the false branch, At N76 of Function uninit_memory_access_006_func_001_good
> Leaving function: uninit_memory_access_006_func_001_good, On N59 -> N109 (Return edge from uninit_memory_access_006_func_001_good to uninit_memory_access_006_good)
> Leaving function: uninit_memory_access_006_good, On N97 -> N5 (Return edge from uninit_memory_access_006_good to main)
> Entering function: uninit_memory_access_006_bad, On N5 -> N9 (call uninit_memory_access_006_bad)
> Entering function: uninit_memory_access_006_func_001_bad, On N18 -> N22 (call uninit_memory_access_006_func_001_bad)
> takes the false branch, At N31 of Function uninit_memory_access_006_func_001_bad
> takes the true branch, At N38 of Function uninit_memory_access_006_func_001_bad
<Defect> : N42 -> N43: [store i8 %4, i8* %5, align 1]
N42 -> N43: [store i8 %4, i8* %5, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N97
On edge  : N97 -{Return edge from uninit_memory_access_006_good to main}-> N5
Message  : the heap object @H(uninit_memory_access_006_good::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_006_good, On N4 -> N98 (call uninit_memory_access_006_good)
> Entering function: uninit_memory_access_006_func_001_good, On N108 -> N60 (call uninit_memory_access_006_func_001_good)
> takes the false branch, At N69 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the false branch, At N76 of Function uninit_memory_access_006_func_001_good
> Leaving function: uninit_memory_access_006_func_001_good, On N59 -> N109 (Return edge from uninit_memory_access_006_func_001_good to uninit_memory_access_006_good)
<Defect> : N97 -> N5: [Return edge from uninit_memory_access_006_good to main]
N97 -> N5: [Return edge from uninit_memory_access_006_good to main] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N17
On edge  : N17 -{%1 = load i8*, i8** %str2, align 8}-> N18
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_006_good, On N4 -> N98 (call uninit_memory_access_006_good)
> Entering function: uninit_memory_access_006_func_001_good, On N108 -> N60 (call uninit_memory_access_006_func_001_good)
> takes the false branch, At N69 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the false branch, At N76 of Function uninit_memory_access_006_func_001_good
> Leaving function: uninit_memory_access_006_func_001_good, On N59 -> N109 (Return edge from uninit_memory_access_006_func_001_good to uninit_memory_access_006_good)
> Leaving function: uninit_memory_access_006_good, On N97 -> N5 (Return edge from uninit_memory_access_006_good to main)
> Entering function: uninit_memory_access_006_bad, On N5 -> N9 (call uninit_memory_access_006_bad)
<Defect> : N17 -> N18: [%1 = load i8*, i8** %str2, align 8]
N17 -> N18: [%1 = load i8*, i8** %str2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N35
On edge  : N35 -{%2 = load i8, i8* %1, align 1}-> N36
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_006_good, On N4 -> N98 (call uninit_memory_access_006_good)
> Entering function: uninit_memory_access_006_func_001_good, On N108 -> N60 (call uninit_memory_access_006_func_001_good)
> takes the false branch, At N69 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the true branch, At N76 of Function uninit_memory_access_006_func_001_good
> takes the false branch, At N76 of Function uninit_memory_access_006_func_001_good
> Leaving function: uninit_memory_access_006_func_001_good, On N59 -> N109 (Return edge from uninit_memory_access_006_func_001_good to uninit_memory_access_006_good)
> Leaving function: uninit_memory_access_006_good, On N97 -> N5 (Return edge from uninit_memory_access_006_good to main)
> Entering function: uninit_memory_access_006_bad, On N5 -> N9 (call uninit_memory_access_006_bad)
> Entering function: uninit_memory_access_006_func_001_bad, On N18 -> N22 (call uninit_memory_access_006_func_001_bad)
> takes the false branch, At N31 of Function uninit_memory_access_006_func_001_bad
<Defect> : N35 -> N36: [%2 = load i8, i8* %1, align 1]
N35 -> N36: [%2 = load i8, i8* %1, align 1] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 2
	[./457_uninit_memory_access_5.c 47] uninit_memory_access_006_func_001_good 		[N80 -{store i8 %4, i8* %5, align 1}-> N81]	(null pointer dereference)
	[./457_uninit_memory_access_5.c 19] uninit_memory_access_006_func_001_bad 		[N42 -{store i8 %4, i8* %5, align 1}-> N43]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./457_uninit_memory_access_5.c 62] uninit_memory_access_006_good 		[N97 -{Return edge from uninit_memory_access_006_good to main}-> N5]	(the heap object @H(uninit_memory_access_006_good::call) is not referenced any more)

CWE_457(Use of Uninitialized Variable): 2
	[./457_uninit_memory_access_5.c 30] uninit_memory_access_006_bad 		[N17 -{%1 = load i8*, i8** %str2, align 8}-> N18]	(use of uninitialized variable)
	[./457_uninit_memory_access_5.c 17] uninit_memory_access_006_func_001_bad 		[N35 -{%2 = load i8, i8* %1, align 1}-> N36]	(use of uninitialized variable)

Found 5 defects in all (21 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_memory_access_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_memory_access_005_good]
 +uninit_memory_access_005_good
SCC(1): [uninit_memory_access_005_bad]
 +uninit_memory_access_005_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.132s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N58
On edge  : N58 -{%10 = load i32, i32* %arrayidx14, align 4}-> N59
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_005_good, On N4 -> N67 (call uninit_memory_access_005_good)
> takes the true branch, At N84 of Function uninit_memory_access_005_good
> takes the true branch, At N89 of Function uninit_memory_access_005_good
> takes the true branch, At N89 of Function uninit_memory_access_005_good
> takes the false branch, At N89 of Function uninit_memory_access_005_good
> takes the true branch, At N84 of Function uninit_memory_access_005_good
> takes the true branch, At N89 of Function uninit_memory_access_005_good
> takes the true branch, At N89 of Function uninit_memory_access_005_good
> takes the false branch, At N89 of Function uninit_memory_access_005_good
> takes the false branch, At N84 of Function uninit_memory_access_005_good
> Leaving function: uninit_memory_access_005_good, On N66 -> N5 (Return edge from uninit_memory_access_005_good to main)
> Entering function: uninit_memory_access_005_bad, On N5 -> N9 (call uninit_memory_access_005_bad)
> takes the true branch, At N26 of Function uninit_memory_access_005_bad
> takes the true branch, At N31 of Function uninit_memory_access_005_bad
> takes the false branch, At N31 of Function uninit_memory_access_005_bad
> takes the false branch, At N26 of Function uninit_memory_access_005_bad
<Defect> : N58 -> N59: [%10 = load i32, i32* %arrayidx14, align 4]
N58 -> N59: [%10 = load i32, i32* %arrayidx14, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_memory_access_4.c 23] uninit_memory_access_005_bad 		[N58 -{%10 = load i32, i32* %arrayidx14, align 4}-> N59]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_memory_access_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_memory_access_008_func_001_good]
 +uninit_memory_access_008_func_001_good
SCC(1): [uninit_memory_access_008_good]
 +uninit_memory_access_008_good
SCC(1): [uninit_memory_access_008_func_001_bad]
 +uninit_memory_access_008_func_001_bad
SCC(1): [uninit_memory_access_008_bad]
 +uninit_memory_access_008_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N57
On edge  : N57 -{%bf.load = load i16, i16* %3, align 4}-> N58
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_008_good, On N4 -> N74 (call uninit_memory_access_008_good)
> Entering function: uninit_memory_access_008_func_001_good, On N78 -> N46 (call uninit_memory_access_008_func_001_good)
> takes the true branch, At N54 of Function uninit_memory_access_008_func_001_good
<Defect> : N57 -> N58: [%bf.load = load i16, i16* %3, align 4]
N57 -> N58: [%bf.load = load i16, i16* %3, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N17
On edge  : N17 -{%bf.load = load i16, i16* %1, align 4}-> N18
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_008_good, On N4 -> N74 (call uninit_memory_access_008_good)
> Entering function: uninit_memory_access_008_func_001_good, On N78 -> N46 (call uninit_memory_access_008_func_001_good)
> takes the false branch, At N54 of Function uninit_memory_access_008_func_001_good
> Leaving function: uninit_memory_access_008_func_001_good, On N45 -> N79 (Return edge from uninit_memory_access_008_func_001_good to uninit_memory_access_008_good)
> takes the false branch, At N82 of Function uninit_memory_access_008_good
> Leaving function: uninit_memory_access_008_good, On N73 -> N5 (Return edge from uninit_memory_access_008_good to main)
> Entering function: uninit_memory_access_008_bad, On N5 -> N9 (call uninit_memory_access_008_bad)
> Entering function: uninit_memory_access_008_func_001_bad, On N13 -> N36 (call uninit_memory_access_008_func_001_bad)
> Leaving function: uninit_memory_access_008_func_001_bad, On N35 -> N14 (Return edge from uninit_memory_access_008_func_001_bad to uninit_memory_access_008_bad)
<Defect> : N17 -> N18: [%bf.load = load i16, i16* %1, align 4]
N17 -> N18: [%bf.load = load i16, i16* %1, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N17
On edge  : N17 -{%bf.load = load i16, i16* %1, align 4}-> N18
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_008_good, On N4 -> N74 (call uninit_memory_access_008_good)
> Entering function: uninit_memory_access_008_func_001_good, On N78 -> N46 (call uninit_memory_access_008_func_001_good)
> takes the false branch, At N54 of Function uninit_memory_access_008_func_001_good
> Leaving function: uninit_memory_access_008_func_001_good, On N45 -> N79 (Return edge from uninit_memory_access_008_func_001_good to uninit_memory_access_008_good)
> takes the false branch, At N82 of Function uninit_memory_access_008_good
> Leaving function: uninit_memory_access_008_good, On N73 -> N5 (Return edge from uninit_memory_access_008_good to main)
> Entering function: uninit_memory_access_008_bad, On N5 -> N9 (call uninit_memory_access_008_bad)
> Entering function: uninit_memory_access_008_func_001_bad, On N13 -> N36 (call uninit_memory_access_008_func_001_bad)
> Leaving function: uninit_memory_access_008_func_001_bad, On N35 -> N14 (Return edge from uninit_memory_access_008_func_001_bad to uninit_memory_access_008_bad)
<Defect> : N17 -> N18: [%bf.load = load i16, i16* %1, align 4]
N17 -> N18: [%bf.load = load i16, i16* %1, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Signed to Unsigned Conversion Error
At node  : N23
On edge  : N23 -{%4 = trunc i32 %bf.cast to i16}-> N24
Message  : Signed to Unsigned Conversion Error
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_008_good, On N4 -> N74 (call uninit_memory_access_008_good)
> Entering function: uninit_memory_access_008_func_001_good, On N78 -> N46 (call uninit_memory_access_008_func_001_good)
> takes the false branch, At N54 of Function uninit_memory_access_008_func_001_good
> Leaving function: uninit_memory_access_008_func_001_good, On N45 -> N79 (Return edge from uninit_memory_access_008_func_001_good to uninit_memory_access_008_good)
> takes the false branch, At N82 of Function uninit_memory_access_008_good
> Leaving function: uninit_memory_access_008_good, On N73 -> N5 (Return edge from uninit_memory_access_008_good to main)
> Entering function: uninit_memory_access_008_bad, On N5 -> N9 (call uninit_memory_access_008_bad)
> Entering function: uninit_memory_access_008_func_001_bad, On N13 -> N36 (call uninit_memory_access_008_func_001_bad)
> Leaving function: uninit_memory_access_008_func_001_bad, On N35 -> N14 (Return edge from uninit_memory_access_008_func_001_bad to uninit_memory_access_008_bad)
<Defect> : N23 -> N24: [%4 = trunc i32 %bf.cast to i16]
N23 -> N24: [%4 = trunc i32 %bf.cast to i16] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from uninit_memory_access_008_bad to main}-> N6
Message  : the heap object @H(uninit_memory_access_008_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_008_good, On N4 -> N74 (call uninit_memory_access_008_good)
> Entering function: uninit_memory_access_008_func_001_good, On N78 -> N46 (call uninit_memory_access_008_func_001_good)
> takes the false branch, At N54 of Function uninit_memory_access_008_func_001_good
> Leaving function: uninit_memory_access_008_func_001_good, On N45 -> N79 (Return edge from uninit_memory_access_008_func_001_good to uninit_memory_access_008_good)
> takes the false branch, At N82 of Function uninit_memory_access_008_good
> Leaving function: uninit_memory_access_008_good, On N73 -> N5 (Return edge from uninit_memory_access_008_good to main)
> Entering function: uninit_memory_access_008_bad, On N5 -> N9 (call uninit_memory_access_008_bad)
> Entering function: uninit_memory_access_008_func_001_bad, On N13 -> N36 (call uninit_memory_access_008_func_001_bad)
> Leaving function: uninit_memory_access_008_func_001_bad, On N35 -> N14 (Return edge from uninit_memory_access_008_func_001_bad to uninit_memory_access_008_bad)
<Defect> : N8 -> N6: [Return edge from uninit_memory_access_008_bad to main]
N8 -> N6: [Return edge from uninit_memory_access_008_bad to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./457_uninit_memory_access_7.c 37] uninit_memory_access_008_func_001_good 		[N57 -{%bf.load = load i16, i16* %3, align 4}-> N58]	(use of uninitialized variable)
	[./457_uninit_memory_access_7.c 24] uninit_memory_access_008_bad 		[N17 -{%bf.load = load i16, i16* %1, align 4}-> N18]	(use of uninitialized variable)

CWE_476(Null Pointer Dereference): 1
	[./457_uninit_memory_access_7.c 24] uninit_memory_access_008_bad 		[N17 -{%bf.load = load i16, i16* %1, align 4}-> N18]	(null pointer dereference)

CWE_195(Signed to Unsigned Conversion Error): 1
	[./457_uninit_memory_access_7.c 24] uninit_memory_access_008_bad 		[N23 -{%4 = trunc i32 %bf.cast to i16}-> N24]	(Signed to Unsigned Conversion Error)

CWE_401(Memory Leak): 1
	[./457_uninit_memory_access_7.c 56] uninit_memory_access_008_bad 		[N8 -{Return edge from uninit_memory_access_008_bad to main}-> N6]	(the heap object @H(uninit_memory_access_008_func_001_bad::call) is not referenced any more)

Found 5 defects in all (8 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_var_003_good]
 +uninit_var_003_good
SCC(1): [uninit_var_003_bad]
 +uninit_var_003_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.073s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N16
On edge  : N16 -{%0 = load i32, i32* %arrayidx1, align 4}-> N17
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_003_good, On N4 -> N21 (call uninit_var_003_good)
> Leaving function: uninit_var_003_good, On N20 -> N5 (Return edge from uninit_var_003_good to main)
> Entering function: uninit_var_003_bad, On N5 -> N9 (call uninit_var_003_bad)
<Defect> : N16 -> N17: [%0 = load i32, i32* %arrayidx1, align 4]
N16 -> N17: [%0 = load i32, i32* %arrayidx1, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_3.c 10] uninit_var_003_bad 		[N16 -{%0 = load i32, i32* %arrayidx1, align 4}-> N17]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_var_010_func_001_good]
 +uninit_var_010_func_001_good
SCC(1): [uninit_var_010_good]
 +uninit_var_010_good
SCC(1): [uninit_var_010_func_001_bad]
 +uninit_var_010_func_001_bad
SCC(1): [uninit_var_010_bad]
 +uninit_var_010_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.166s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N43
On edge  : N43 -{%4 = load i32, i32* %arrayidx5, align 4}-> N44
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_010_good, On N4 -> N123 (call uninit_var_010_good)
> Entering function: uninit_var_010_func_001_good, On N127 -> N69 (call uninit_var_010_func_001_good)
> takes the true branch, At N85 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the false branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N85 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the true branch, At N90 of Function uninit_var_010_func_001_good
> takes the false branch, At N90 of Function uninit_var_010_func_001_good
> takes the false branch, At N85 of Function uninit_var_010_func_001_good
> Leaving function: uninit_var_010_func_001_good, On N68 -> N128 (Return edge from uninit_var_010_func_001_good to uninit_var_010_good)
> Leaving function: uninit_var_010_good, On N122 -> N5 (Return edge from uninit_var_010_good to main)
> Entering function: uninit_var_010_bad, On N5 -> N9 (call uninit_var_010_bad)
> Entering function: uninit_var_010_func_001_bad, On N13 -> N17 (call uninit_var_010_func_001_bad)
> takes the true branch, At N31 of Function uninit_var_010_func_001_bad
> takes the true branch, At N36 of Function uninit_var_010_func_001_bad
<Defect> : N43 -> N44: [%4 = load i32, i32* %arrayidx5, align 4]
N43 -> N44: [%4 = load i32, i32* %arrayidx5, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_9.c 12] uninit_var_010_func_001_bad 		[N43 -{%4 = load i32, i32* %arrayidx5, align 4}-> N44]	(use of uninitialized variable)

Found 1 defects in all (11 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [_bad]
 +_bad
SCC(1): [u_bad]
 +u_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.091s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N13): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N32
On edge  : N32 -{%2 = load i32, i32* %data, align 4}-> N33
Message  : use of uninitialized variable
> Start from entry function: main, At N13 of Function main
> Entering function: u_bad, On N16 -> N20 (call u_bad)
> Entering function: _bad, On N28 -> N1 (call _bad)
> Leaving function: _bad, On N0 -> N29 (Return edge from _bad to u_bad)
> takes the true branch, At N30 of Function u_bad
<Defect> : N32 -> N33: [%2 = load i32, i32* %data, align 4]
N32 -> N33: [%2 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_7.c 38] u_bad 		[N32 -{%2 = load i32, i32* %data, align 4}-> N33]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_memory_access_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [uninit_memory_access_007_func_002_good]
 +uninit_memory_access_007_func_002_good
SCC(1): [uninit_memory_access_007_func_004_good]
 +uninit_memory_access_007_func_004_good
SCC(1): [uninit_memory_access_007_func_001_good]
 +uninit_memory_access_007_func_001_good
SCC(1): [uninit_memory_access_007_func_003_good]
 +uninit_memory_access_007_func_003_good
SCC(1): [uninit_memory_access_007_good]
 +uninit_memory_access_007_good
SCC(1): [uninit_memory_access_007_func_003_bad]
 +uninit_memory_access_007_func_003_bad
SCC(1): [uninit_memory_access_007_func_001_bad]
 +uninit_memory_access_007_func_001_bad
SCC(1): [uninit_memory_access_007_func_004_bad]
 +uninit_memory_access_007_func_004_bad
SCC(1): [uninit_memory_access_007_func_002_bad]
 +uninit_memory_access_007_func_002_bad
SCC(1): [uninit_memory_access_007_bad]
 +uninit_memory_access_007_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.144s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N68
On edge  : N68 -{%3 = load i32, i32* %arrayidx, align 4}-> N69
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_007_good, On N4 -> N176 (call uninit_memory_access_007_good)
> Entering function: uninit_memory_access_007_func_001_good, On N179 -> N36 (call uninit_memory_access_007_func_001_good)
> Leaving function: uninit_memory_access_007_func_001_good, On N35 -> N180 (Return edge from uninit_memory_access_007_func_001_good to uninit_memory_access_007_good)
> Entering function: uninit_memory_access_007_func_002_good, On N180 -> N82 (call uninit_memory_access_007_func_002_good)
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the true branch, At N95 of Function uninit_memory_access_007_func_002_good
> takes the false branch, At N95 of Function uninit_memory_access_007_func_002_good
> Leaving function: uninit_memory_access_007_func_002_good, On N81 -> N181 (Return edge from uninit_memory_access_007_func_002_good to uninit_memory_access_007_good)
> Entering function: uninit_memory_access_007_func_003_good, On N181 -> N128 (call uninit_memory_access_007_func_003_good)
> Leaving function: uninit_memory_access_007_func_003_good, On N127 -> N182 (Return edge from uninit_memory_access_007_func_003_good to uninit_memory_access_007_good)
> Entering function: uninit_memory_access_007_func_004_good, On N184 -> N158 (call uninit_memory_access_007_func_004_good)
> takes the true branch, At N167 of Function uninit_memory_access_007_func_004_good
> Leaving function: uninit_memory_access_007_func_004_good, On N157 -> N185 (Return edge from uninit_memory_access_007_func_004_good to uninit_memory_access_007_good)
> Leaving function: uninit_memory_access_007_good, On N175 -> N5 (Return edge from uninit_memory_access_007_good to main)
> Entering function: uninit_memory_access_007_bad, On N5 -> N9 (call uninit_memory_access_007_bad)
> Entering function: uninit_memory_access_007_func_001_bad, On N12 -> N21 (call uninit_memory_access_007_func_001_bad)
> Leaving function: uninit_memory_access_007_func_001_bad, On N20 -> N13 (Return edge from uninit_memory_access_007_func_001_bad to uninit_memory_access_007_bad)
> Entering function: uninit_memory_access_007_func_002_bad, On N13 -> N49 (call uninit_memory_access_007_func_002_bad)
> takes the true branch, At N62 of Function uninit_memory_access_007_func_002_bad
<Defect> : N68 -> N69: [%3 = load i32, i32* %arrayidx, align 4]
N68 -> N69: [%3 = load i32, i32* %arrayidx, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_memory_access_6.c 29] uninit_memory_access_007_func_002_bad 		[N68 -{%3 = load i32, i32* %arrayidx, align 4}-> N69]	(use of uninitialized variable)

Found 1 defects in all (9 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_var_005_func_001_good]
 +uninit_var_005_func_001_good
SCC(1): [uninit_var_005_good]
 +uninit_var_005_good
SCC(1): [uninit_var_005_func_001_bad]
 +uninit_var_005_func_001_bad
SCC(1): [uninit_var_005_bad]
 +uninit_var_005_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.072s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N20
On edge  : N20 -{%0 = load i32, i32* %ret, align 4}-> N21
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_005_good, On N4 -> N32 (call uninit_var_005_good)
> Entering function: uninit_var_005_func_001_good, On N35 -> N24 (call uninit_var_005_func_001_good)
> Leaving function: uninit_var_005_func_001_good, On N23 -> N36 (Return edge from uninit_var_005_func_001_good to uninit_var_005_good)
> Leaving function: uninit_var_005_good, On N31 -> N5 (Return edge from uninit_var_005_good to main)
> Entering function: uninit_var_005_bad, On N5 -> N9 (call uninit_var_005_bad)
> Entering function: uninit_var_005_func_001_bad, On N12 -> N17 (call uninit_var_005_func_001_bad)
<Defect> : N20 -> N21: [%0 = load i32, i32* %ret, align 4]
N20 -> N21: [%0 = load i32, i32* %ret, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_4.c 11] uninit_var_005_func_001_bad 		[N20 -{%0 = load i32, i32* %ret, align 4}-> N21]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_memory_access_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [_002_bad]
 +_002_bad
SCC(1): [_002_good]
 +_002_good
SCC(1): [bad]
 +bad
SCC(1): [good]
 +good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.345s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N270): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N229
On edge  : N229 -{%8 = load i64, i64* %arrayidx8, align 8}-> N230
Message  : use of uninitialized variable
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the false branch, At N84 of Function _002_good
> Leaving function: _002_good, On N54 -> N208 (Return edge from _002_good to good)
> takes the true branch, At N210 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
<Defect> : N229 -> N230: [%8 = load i64, i64* %arrayidx8, align 8]
N229 -> N230: [%8 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N73
On edge  : N73 -{%arrayidx = getelementptr inbounds i64*, i64** %4, i64 %idxprom}-> N74
Message  : null pointer dereference
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
<Defect> : N73 -> N74: [%arrayidx = getelementptr inbounds i64*, i64** %4, i64 %idxprom]
N73 -> N74: [%arrayidx = getelementptr inbounds i64*, i64** %4, i64 %idxprom] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N99
On edge  : N99 -{%arrayidx11 = getelementptr inbounds i64, i64* %12, i64 %idxprom8}-> N100
Message  : null pointer dereference
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
<Defect> : N99 -> N100: [%arrayidx11 = getelementptr inbounds i64, i64* %12, i64 %idxprom8]
N99 -> N100: [%arrayidx11 = getelementptr inbounds i64, i64* %12, i64 %idxprom8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N100
On edge  : N100 -{store i64 %conv, i64* %arrayidx11, align 8}-> N102
Message  : null pointer dereference
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
<Defect> : N100 -> N102: [store i64 %conv, i64* %arrayidx11, align 8]
N100 -> N102: [store i64 %conv, i64* %arrayidx11, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N228
On edge  : N228 -{%arrayidx8 = getelementptr inbounds i64, i64* %7, i64 %idxprom}-> N229
Message  : null pointer dereference
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the false branch, At N84 of Function _002_good
> Leaving function: _002_good, On N54 -> N208 (Return edge from _002_good to good)
> takes the true branch, At N210 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
<Defect> : N228 -> N229: [%arrayidx8 = getelementptr inbounds i64, i64* %7, i64 %idxprom]
N228 -> N229: [%arrayidx8 = getelementptr inbounds i64, i64* %7, i64 %idxprom] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N229
On edge  : N229 -{%8 = load i64, i64* %arrayidx8, align 8}-> N230
Message  : null pointer dereference
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the false branch, At N84 of Function _002_good
> Leaving function: _002_good, On N54 -> N208 (Return edge from _002_good to good)
> takes the true branch, At N210 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
<Defect> : N229 -> N230: [%8 = load i64, i64* %arrayidx8, align 8]
N229 -> N230: [%8 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N231
On edge  : N231 -{store i64 %add, i64* %arrayidx8, align 8}-> N233
Message  : null pointer dereference
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the false branch, At N84 of Function _002_good
> Leaving function: _002_good, On N54 -> N208 (Return edge from _002_good to good)
> takes the true branch, At N210 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
<Defect> : N231 -> N233: [store i64 %add, i64* %arrayidx8, align 8]
N231 -> N233: [store i64 %add, i64* %arrayidx8, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N243
On edge  : N243 -{call void @free(i8* %13, i8* @free)}-> N244
Message  : null pointer dereference
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the false branch, At N84 of Function _002_good
> Leaving function: _002_good, On N54 -> N208 (Return edge from _002_good to good)
> takes the true branch, At N210 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the false branch, At N220 of Function good
<Defect> : N243 -> N244: [call void @free(i8* %13, i8* @free)]
N243 -> N244: [call void @free(i8* %13, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N229
On edge  : N229 -{%8 = load i64, i64* %arrayidx8, align 8}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the false branch, At N84 of Function _002_good
> Leaving function: _002_good, On N54 -> N208 (Return edge from _002_good to good)
> takes the true branch, At N210 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the false branch, At N220 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
<Defect> : N229 -> N230: [%8 = load i64, i64* %arrayidx8, align 8]
N229 -> N230: [%8 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N231
On edge  : N231 -{store i64 %add, i64* %arrayidx8, align 8}-> N233
Message  : the memory is already freed
> Start from entry function: main, At N270 of Function main
> Entering function: good, On N273 -> N195 (call good)
> takes the true branch, At N205 of Function good
> Entering function: _002_good, On N261 -> N55 (call _002_good)
> takes the true branch, At N67 of Function _002_good
> takes the true branch, At N67 of Function _002_good
> takes the false branch, At N67 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the true branch, At N84 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the true branch, At N89 of Function _002_good
> takes the false branch, At N89 of Function _002_good
> takes the false branch, At N84 of Function _002_good
> Leaving function: _002_good, On N54 -> N208 (Return edge from _002_good to good)
> takes the true branch, At N210 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the true branch, At N220 of Function good
> takes the false branch, At N220 of Function good
> takes the true branch, At N215 of Function good
> takes the true branch, At N220 of Function good
<Defect> : N231 -> N233: [store i64 %add, i64* %arrayidx8, align 8]
N231 -> N233: [store i64 %add, i64* %arrayidx8, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_memory_access_8.c 92] good 		[N229 -{%8 = load i64, i64* %arrayidx8, align 8}-> N230]	(use of uninitialized variable)

CWE_476(Null Pointer Dereference): 7
	[./457_uninit_memory_access_8.c 67] _002_good 		[N73 -{%arrayidx = getelementptr inbounds i64*, i64** %4, i64 %idxprom}-> N74]	(null pointer dereference)
	[./457_uninit_memory_access_8.c 73] _002_good 		[N99 -{%arrayidx11 = getelementptr inbounds i64, i64* %12, i64 %idxprom8}-> N100]	(null pointer dereference)
	[./457_uninit_memory_access_8.c 73] _002_good 		[N100 -{store i64 %conv, i64* %arrayidx11, align 8}-> N102]	(null pointer dereference)
	[./457_uninit_memory_access_8.c 92] good 		[N228 -{%arrayidx8 = getelementptr inbounds i64, i64* %7, i64 %idxprom}-> N229]	(null pointer dereference)
	[./457_uninit_memory_access_8.c 92] good 		[N229 -{%8 = load i64, i64* %arrayidx8, align 8}-> N230]	(null pointer dereference)
	[./457_uninit_memory_access_8.c 92] good 		[N231 -{store i64 %add, i64* %arrayidx8, align 8}-> N233]	(null pointer dereference)
	[./457_uninit_memory_access_8.c 94] good 		[N243 -{call void @free(i8* %13, i8* @free)}-> N244]	(null pointer dereference)

CWE_416(Use After Free): 2
	[./457_uninit_memory_access_8.c 92] good 		[N229 -{%8 = load i64, i64* %arrayidx8, align 8}-> N230]	(the memory is already freed)
	[./457_uninit_memory_access_8.c 92] good 		[N231 -{store i64 %add, i64* %arrayidx8, align 8}-> N233]	(the memory is already freed)

Found 10 defects in all (94 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_var_006_good]
 +uninit_var_006_good
SCC(1): [uninit_var_006_bad]
 +uninit_var_006_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.076s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N28
On edge  : N28 -{%1 = load i64, i64* %a, align 8}-> N21
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_006_good, On N4 -> N32 (call uninit_var_006_good)
> takes the true branch, At N40 of Function uninit_var_006_good
> Leaving function: uninit_var_006_good, On N31 -> N5 (Return edge from uninit_var_006_good to main)
> Entering function: uninit_var_006_bad, On N5 -> N9 (call uninit_var_006_bad)
> takes the false branch, At N17 of Function uninit_var_006_bad
<Defect> : N28 -> N21: [%1 = load i64, i64* %a, align 8]
N28 -> N21: [%1 = load i64, i64* %a, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_5.c 10] uninit_var_006_bad 		[N28 -{%1 = load i64, i64* %a, align 8}-> N21]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_memory_access_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [_001_bad]
 +_001_bad
SCC(1): [_001_good]
 +_001_good
SCC(1): [bad]
 +bad
SCC(1): [good]
 +good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.098s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N44): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N30
On edge  : N30 -{%0 = load i8*, i8** %str, align 8}-> N31
Message  : use of uninitialized variable
> Start from entry function: main, At N44 of Function main
> Entering function: good, On N47 -> N35 (call good)
> Entering function: _001_good, On N40 -> N14 (call _001_good)
> Leaving function: _001_good, On N13 -> N41 (Return edge from _001_good to good)
> Leaving function: good, On N34 -> N48 (Return edge from good to main)
> Entering function: bad, On N48 -> N27 (call bad)
<Defect> : N30 -> N31: [%0 = load i8*, i8** %str, align 8]
N30 -> N31: [%0 = load i8*, i8** %str, align 8] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_memory_access_3.c 16] bad 		[N30 -{%0 = load i8*, i8** %str, align 8}-> N31]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_var_013_func_001_good]
 +uninit_var_013_func_001_good
SCC(1): [uninit_var_013_good]
 +uninit_var_013_good
SCC(1): [uninit_var_013_func_001_bad]
 +uninit_var_013_func_001_bad
SCC(1): [uninit_var_013_bad]
 +uninit_var_013_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.072s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N20
On edge  : N20 -{%0 = load i32, i32* %val, align 4}-> N21
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_013_good, On N4 -> N32 (call uninit_var_013_good)
> Entering function: uninit_var_013_func_001_good, On N35 -> N24 (call uninit_var_013_func_001_good)
> Leaving function: uninit_var_013_func_001_good, On N23 -> N36 (Return edge from uninit_var_013_func_001_good to uninit_var_013_good)
> Leaving function: uninit_var_013_good, On N31 -> N5 (Return edge from uninit_var_013_good to main)
> Entering function: uninit_var_013_bad, On N5 -> N9 (call uninit_var_013_bad)
> Entering function: uninit_var_013_func_001_bad, On N12 -> N17 (call uninit_var_013_func_001_bad)
<Defect> : N20 -> N21: [%0 = load i32, i32* %val, align 4]
N20 -> N21: [%0 = load i32, i32* %val, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_12.c 11] uninit_var_013_func_001_bad 		[N20 -{%0 = load i32, i32* %val, align 4}-> N21]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_var_009_func_001_good]
 +uninit_var_009_func_001_good
SCC(1): [uninit_var_009_good]
 +uninit_var_009_good
SCC(1): [uninit_var_009_func_001_bad]
 +uninit_var_009_func_001_bad
SCC(1): [uninit_var_009_bad]
 +uninit_var_009_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N25
On edge  : N25 -{%call = call i8* @strcpy(i8* %0, i8* %arraydecay, i8* @strcpy)}-> N26
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_009_good, On N4 -> N43 (call uninit_var_009_good)
> Entering function: uninit_var_009_func_001_good, On N47 -> N29 (call uninit_var_009_func_001_good)
> Leaving function: uninit_var_009_func_001_good, On N28 -> N48 (Return edge from uninit_var_009_func_001_good to uninit_var_009_good)
> Leaving function: uninit_var_009_good, On N42 -> N5 (Return edge from uninit_var_009_good to main)
> Entering function: uninit_var_009_bad, On N5 -> N9 (call uninit_var_009_bad)
> Entering function: uninit_var_009_func_001_bad, On N13 -> N17 (call uninit_var_009_func_001_bad)
<Defect> : N25 -> N26: [%call = call i8* @strcpy(i8* %0, i8* %arraydecay, i8* @strcpy)]
N25 -> N26: [%call = call i8* @strcpy(i8* %0, i8* %arraydecay, i8* @strcpy)] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_8.c 11] uninit_var_009_func_001_bad 		[N25 -{%call = call i8* @strcpy(i8* %0, i8* %arraydecay, i8* @strcpy)}-> N26]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_memory_access_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_memory_access_003_good]
 +uninit_memory_access_003_good
SCC(1): [uninit_memory_access_003_bad]
 +uninit_memory_access_003_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.082s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N20
On edge  : N20 -{%2 = load i8*, i8** %str2, align 8}-> N21
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_003_good, On N4 -> N30 (call uninit_memory_access_003_good)
> takes the false branch, At N40 of Function uninit_memory_access_003_good
> Leaving function: uninit_memory_access_003_good, On N29 -> N5 (Return edge from uninit_memory_access_003_good to main)
> Entering function: uninit_memory_access_003_bad, On N5 -> N9 (call uninit_memory_access_003_bad)
> takes the true branch, At N18 of Function uninit_memory_access_003_bad
<Defect> : N20 -> N21: [%2 = load i8*, i8** %str2, align 8]
N20 -> N21: [%2 = load i8*, i8** %str2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N21
On edge  : N21 -{%call1 = call i8* @strcpy(i8* %1, i8* %2, i8* @strcpy)}-> N22
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_memory_access_003_good, On N4 -> N30 (call uninit_memory_access_003_good)
> takes the false branch, At N40 of Function uninit_memory_access_003_good
> Leaving function: uninit_memory_access_003_good, On N29 -> N5 (Return edge from uninit_memory_access_003_good to main)
> Entering function: uninit_memory_access_003_bad, On N5 -> N9 (call uninit_memory_access_003_bad)
> takes the true branch, At N18 of Function uninit_memory_access_003_bad
<Defect> : N21 -> N22: [%call1 = call i8* @strcpy(i8* %1, i8* %2, i8* @strcpy)]
N21 -> N22: [%call1 = call i8* @strcpy(i8* %1, i8* %2, i8* @strcpy)] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 2
	[./457_uninit_memory_access_2.c 16] uninit_memory_access_003_bad 		[N20 -{%2 = load i8*, i8** %str2, align 8}-> N21]	(use of uninitialized variable)
	[./457_uninit_memory_access_2.c 16] uninit_memory_access_003_bad 		[N21 -{%call1 = call i8* @strcpy(i8* %1, i8* %2, i8* @strcpy)}-> N22]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_var_014_func_001_good]
 +uninit_var_014_func_001_good
SCC(1): [uninit_var_014_good]
 +uninit_var_014_good
SCC(1): [uninit_var_014_func_001_bad]
 +uninit_var_014_func_001_bad
SCC(1): [uninit_var_014_bad]
 +uninit_var_014_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N104
On edge  : N104 -{%5 = load i32, i32* %b, align 4}-> N105
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_014_good, On N4 -> N125 (call uninit_var_014_good)
> Entering function: uninit_var_014_func_001_good, On N146 -> N82 (call uninit_var_014_func_001_good)
<Defect> : N104 -> N105: [%5 = load i32, i32* %b, align 4]
N104 -> N105: [%5 = load i32, i32* %b, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N27
On edge  : N27 -{%5 = load i32, i32* %4, align 4}-> N28
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_014_good, On N4 -> N125 (call uninit_var_014_good)
> Entering function: uninit_var_014_func_001_good, On N146 -> N82 (call uninit_var_014_func_001_good)
> Leaving function: uninit_var_014_func_001_good, On N81 -> N147 (Return edge from uninit_var_014_func_001_good to uninit_var_014_good)
> Leaving function: uninit_var_014_good, On N124 -> N5 (Return edge from uninit_var_014_good to main)
> Entering function: uninit_var_014_bad, On N5 -> N9 (call uninit_var_014_bad)
<Defect> : N27 -> N28: [%5 = load i32, i32* %4, align 4]
N27 -> N28: [%5 = load i32, i32* %4, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N61
On edge  : N61 -{%5 = load i32, i32* %b, align 4}-> N62
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_014_good, On N4 -> N125 (call uninit_var_014_good)
> Entering function: uninit_var_014_func_001_good, On N146 -> N82 (call uninit_var_014_func_001_good)
> Leaving function: uninit_var_014_func_001_good, On N81 -> N147 (Return edge from uninit_var_014_func_001_good to uninit_var_014_good)
> Leaving function: uninit_var_014_good, On N124 -> N5 (Return edge from uninit_var_014_good to main)
> Entering function: uninit_var_014_bad, On N5 -> N9 (call uninit_var_014_bad)
> Entering function: uninit_var_014_func_001_bad, On N28 -> N39 (call uninit_var_014_func_001_bad)
<Defect> : N61 -> N62: [%5 = load i32, i32* %b, align 4]
N61 -> N62: [%5 = load i32, i32* %b, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 3
	[./457_uninit_var_14.c 35] uninit_var_014_func_001_good 		[N104 -{%5 = load i32, i32* %b, align 4}-> N105]	(use of uninitialized variable)
	[./457_uninit_var_14.c 25] uninit_var_014_bad 		[N27 -{%5 = load i32, i32* %4, align 4}-> N28]	(use of uninitialized variable)
	[./457_uninit_var_14.c 16] uninit_var_014_func_001_bad 		[N61 -{%5 = load i32, i32* %b, align 4}-> N62]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_var_007_bad]
 +uninit_var_007_bad
SCC(1): [uninit_var_007_good]
 +uninit_var_007_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.08s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N19
On edge  : N19 -{%0 = load i32, i32* %uninit, align 4}-> N20
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_007_good, On N4 -> N24 (call uninit_var_007_good)
> Leaving function: uninit_var_007_good, On N23 -> N5 (Return edge from uninit_var_007_good to main)
> Entering function: uninit_var_007_bad, On N5 -> N9 (call uninit_var_007_bad)
<Defect> : N19 -> N20: [%0 = load i32, i32* %uninit, align 4]
N19 -> N20: [%0 = load i32, i32* %uninit, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_6.c 18] uninit_var_007_bad 		[N19 -{%0 = load i32, i32* %uninit, align 4}-> N20]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_var_002_good]
 +uninit_var_002_good
SCC(1): [uninit_var_002_bad]
 +uninit_var_002_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.092s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N15
On edge  : N15 -{%0 = load i32, i32* %arrayidx, align 4}-> N16
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_002_good, On N4 -> N20 (call uninit_var_002_good)
> Leaving function: uninit_var_002_good, On N19 -> N5 (Return edge from uninit_var_002_good to main)
> Entering function: uninit_var_002_bad, On N5 -> N9 (call uninit_var_002_bad)
<Defect> : N15 -> N16: [%0 = load i32, i32* %arrayidx, align 4]
N15 -> N16: [%0 = load i32, i32* %arrayidx, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_2.c 10] uninit_var_002_bad 		[N15 -{%0 = load i32, i32* %arrayidx, align 4}-> N16]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [uninit_var_001_good]
 +uninit_var_001_good
SCC(1): [uninit_var_001_bad]
 +uninit_var_001_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.067s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N14
On edge  : N14 -{%0 = load i32, i32* %a, align 4}-> N15
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_001_good, On N4 -> N19 (call uninit_var_001_good)
> Leaving function: uninit_var_001_good, On N18 -> N5 (Return edge from uninit_var_001_good to main)
> Entering function: uninit_var_001_bad, On N5 -> N9 (call uninit_var_001_bad)
<Defect> : N14 -> N15: [%0 = load i32, i32* %a, align 4]
N14 -> N15: [%0 = load i32, i32* %a, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_1.c 10] uninit_var_001_bad 		[N14 -{%0 = load i32, i32* %a, align 4}-> N15]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/457/457_uninit_var_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [uninit_var_015_func_001_good]
 +uninit_var_015_func_001_good
SCC(1): [uninit_var_015_good]
 +uninit_var_015_good
SCC(1): [uninit_var_015_func_001_bad]
 +uninit_var_015_func_001_bad
SCC(1): [uninit_var_015_bad]
 +uninit_var_015_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N17
On edge  : N17 -{%0 = load i32, i32* %arrayidx, align 4}-> N18
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: uninit_var_015_good, On N4 -> N51 (call uninit_var_015_good)
> Entering function: uninit_var_015_func_001_good, On N55 -> N35 (call uninit_var_015_func_001_good)
> Leaving function: uninit_var_015_func_001_good, On N34 -> N56 (Return edge from uninit_var_015_func_001_good to uninit_var_015_good)
> Leaving function: uninit_var_015_good, On N50 -> N5 (Return edge from uninit_var_015_good to main)
> Entering function: uninit_var_015_bad, On N5 -> N9 (call uninit_var_015_bad)
> Entering function: uninit_var_015_func_001_bad, On N15 -> N22 (call uninit_var_015_func_001_bad)
> Leaving function: uninit_var_015_func_001_bad, On N21 -> N16 (Return edge from uninit_var_015_func_001_bad to uninit_var_015_bad)
<Defect> : N17 -> N18: [%0 = load i32, i32* %arrayidx, align 4]
N17 -> N18: [%0 = load i32, i32* %arrayidx, align 4] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 1
	[./457_uninit_var_13.c 18] uninit_var_015_bad 		[N17 -{%0 = load i32, i32* %arrayidx, align 4}-> N18]	(use of uninitialized variable)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_009_bad]
 +double_free_009_bad
SCC(1): [double_free_009_good]
 +double_free_009_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.093s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the true branch, At N41 of Function double_free_009_good
> Leaving function: double_free_009_good, On N32 -> N69 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N69 -> N1 (call double_free_009_bad)
> takes the false branch, At N9 of Function double_free_009_bad
> takes the true branch, At N16 of Function double_free_009_bad
> takes the false branch, At N16 of Function double_free_009_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the true branch, At N41 of Function double_free_009_good
> Leaving function: double_free_009_good, On N32 -> N69 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N69 -> N1 (call double_free_009_bad)
> takes the false branch, At N9 of Function double_free_009_bad
> takes the true branch, At N16 of Function double_free_009_bad
> takes the false branch, At N16 of Function double_free_009_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_9.c 29] double_free_009_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_9.c 29] double_free_009_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_002_bad]
 +double_free_002_bad
SCC(1): [double_free_002_good]
 +double_free_002_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N89): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N34
On edge  : N34 -{call void @free(i8* %7, i8* @free)}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the true branch, At N53 of Function double_free_002_good
> Leaving function: double_free_002_good, On N44 -> N93 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N93 -> N1 (call double_free_002_bad)
> takes the false branch, At N9 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
> takes the false branch, At N16 of Function double_free_002_bad
<Defect> : N34 -> N36: [call void @free(i8* %7, i8* @free)]
N34 -> N36: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N34
On edge  : N34 -{call void @free(i8* %7, i8* @free)}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the true branch, At N53 of Function double_free_002_good
> Leaving function: double_free_002_good, On N44 -> N93 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N93 -> N1 (call double_free_002_bad)
> takes the false branch, At N9 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the false branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
> takes the false branch, At N16 of Function double_free_002_bad
<Defect> : N34 -> N36: [call void @free(i8* %7, i8* @free)]
N34 -> N36: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_double_free_2.c 32] double_free_002_bad 		[N34 -{call void @free(i8* %7, i8* @free)}-> N36]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_double_free_2.c 32] double_free_002_bad 		[N34 -{call void @free(i8* %7, i8* @free)}-> N36]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_007_bad]
 +double_free_007_bad
SCC(1): [double_free_007_good]
 +double_free_007_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.081s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N20
On edge  : N20 -{call void @free(i8* %3, i8* @free)}-> N22
Message  : the memory is already freed
> Start from entry function: main, At N57 of Function main
> Entering function: double_free_007_good, On N60 -> N29 (call double_free_007_good)
> takes the true branch, At N37 of Function double_free_007_good
> Leaving function: double_free_007_good, On N28 -> N61 (Return edge from double_free_007_good to main)
> Entering function: double_free_007_bad, On N61 -> N1 (call double_free_007_bad)
> takes the false branch, At N9 of Function double_free_007_bad
> takes the true branch, At N15 of Function double_free_007_bad
<Defect> : N20 -> N22: [call void @free(i8* %3, i8* @free)]
N20 -> N22: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N20
On edge  : N20 -{call void @free(i8* %3, i8* @free)}-> N22
Message  : the memory is already freed
> Start from entry function: main, At N57 of Function main
> Entering function: double_free_007_good, On N60 -> N29 (call double_free_007_good)
> takes the true branch, At N37 of Function double_free_007_good
> Leaving function: double_free_007_good, On N28 -> N61 (Return edge from double_free_007_good to main)
> Entering function: double_free_007_bad, On N61 -> N1 (call double_free_007_bad)
> takes the false branch, At N9 of Function double_free_007_bad
> takes the true branch, At N15 of Function double_free_007_bad
<Defect> : N20 -> N22: [call void @free(i8* %3, i8* @free)]
N20 -> N22: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_double_free_7.c 27] double_free_007_bad 		[N20 -{call void @free(i8* %3, i8* @free)}-> N22]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_double_free_7.c 27] double_free_007_bad 		[N20 -{call void @free(i8* %3, i8* @free)}-> N22]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_006_bad]
 +double_free_006_bad
SCC(1): [double_free_006_good]
 +double_free_006_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.081s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N37): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N13
On edge  : N13 -{call void @free(i8* %2, i8* @free)}-> N15
Message  : the memory is already freed
> Start from entry function: main, At N37 of Function main
> Entering function: double_free_006_good, On N40 -> N20 (call double_free_006_good)
> takes the true branch, At N27 of Function double_free_006_good
> Leaving function: double_free_006_good, On N19 -> N41 (Return edge from double_free_006_good to main)
> Entering function: double_free_006_bad, On N41 -> N1 (call double_free_006_bad)
> takes the false branch, At N8 of Function double_free_006_bad
<Defect> : N13 -> N15: [call void @free(i8* %2, i8* @free)]
N13 -> N15: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N13
On edge  : N13 -{call void @free(i8* %2, i8* @free)}-> N15
Message  : the memory is already freed
> Start from entry function: main, At N37 of Function main
> Entering function: double_free_006_good, On N40 -> N20 (call double_free_006_good)
> takes the true branch, At N27 of Function double_free_006_good
> Leaving function: double_free_006_good, On N19 -> N41 (Return edge from double_free_006_good to main)
> Entering function: double_free_006_bad, On N41 -> N1 (call double_free_006_bad)
> takes the false branch, At N8 of Function double_free_006_bad
<Defect> : N13 -> N15: [call void @free(i8* %2, i8* @free)]
N13 -> N15: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_6.c 25] double_free_006_bad 		[N13 -{call void @free(i8* %2, i8* @free)}-> N15]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_6.c 25] double_free_006_bad 		[N13 -{call void @free(i8* %2, i8* @free)}-> N15]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [double_free_function_008_bad]
 +double_free_function_008_bad
SCC(1): [double_free_008_bad]
 +double_free_008_bad
SCC(1): [double_free_function_008_good]
 +double_free_function_008_good
SCC(1): [double_free_008_good]
 +double_free_008_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N10
On edge  : N10 -{call void @free(i8* %1, i8* @free)}-> N12
Message  : the memory is already freed
> Start from entry function: main, At N43 of Function main
> Entering function: double_free_008_good, On N46 -> N17 (call double_free_008_good)
> takes the true branch, At N22 of Function double_free_008_good
> Leaving function: double_free_008_good, On N16 -> N47 (Return edge from double_free_008_good to main)
> Entering function: double_free_008_bad, On N47 -> N1 (call double_free_008_bad)
> takes the false branch, At N6 of Function double_free_008_bad
> Entering function: double_free_function_008_bad, On N15 -> N31 (call double_free_function_008_bad)
> Leaving function: double_free_function_008_bad, On N30 -> N9 (Return edge from double_free_function_008_bad to double_free_008_bad)
<Defect> : N10 -> N12: [call void @free(i8* %1, i8* @free)]
N10 -> N12: [call void @free(i8* %1, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N10
On edge  : N10 -{call void @free(i8* %1, i8* @free)}-> N12
Message  : the memory is already freed
> Start from entry function: main, At N43 of Function main
> Entering function: double_free_008_good, On N46 -> N17 (call double_free_008_good)
> takes the true branch, At N22 of Function double_free_008_good
> Leaving function: double_free_008_good, On N16 -> N47 (Return edge from double_free_008_good to main)
> Entering function: double_free_008_bad, On N47 -> N1 (call double_free_008_bad)
> takes the false branch, At N6 of Function double_free_008_bad
> Entering function: double_free_function_008_bad, On N15 -> N31 (call double_free_function_008_bad)
> Leaving function: double_free_function_008_bad, On N30 -> N9 (Return edge from double_free_function_008_bad to double_free_008_bad)
<Defect> : N10 -> N12: [call void @free(i8* %1, i8* @free)]
N10 -> N12: [call void @free(i8* %1, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_8.c 28] double_free_008_bad 		[N10 -{call void @free(i8* %1, i8* @free)}-> N12]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_8.c 28] double_free_008_bad 		[N10 -{call void @free(i8* %1, i8* @free)}-> N12]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_003_bad]
 +double_free_003_bad
SCC(1): [double_free_003_good]
 +double_free_003_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N34
On edge  : N34 -{call void @free(i8* %7, i8* @free)}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N81 of Function main
> Entering function: double_free_003_good, On N84 -> N45 (call double_free_003_good)
> takes the true branch, At N53 of Function double_free_003_good
> Leaving function: double_free_003_good, On N44 -> N85 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N85 -> N1 (call double_free_003_bad)
> takes the false branch, At N9 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
> takes the false branch, At N16 of Function double_free_003_bad
<Defect> : N34 -> N36: [call void @free(i8* %7, i8* @free)]
N34 -> N36: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N34
On edge  : N34 -{call void @free(i8* %7, i8* @free)}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N81 of Function main
> Entering function: double_free_003_good, On N84 -> N45 (call double_free_003_good)
> takes the true branch, At N53 of Function double_free_003_good
> Leaving function: double_free_003_good, On N44 -> N85 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N85 -> N1 (call double_free_003_bad)
> takes the false branch, At N9 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the false branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
> takes the false branch, At N16 of Function double_free_003_bad
<Defect> : N34 -> N36: [call void @free(i8* %7, i8* @free)]
N34 -> N36: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_double_free_3.c 32] double_free_003_bad 		[N34 -{call void @free(i8* %7, i8* @free)}-> N36]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_double_free_3.c 32] double_free_003_bad 		[N34 -{call void @free(i8* %7, i8* @free)}-> N36]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_011_bad]
 +double_free_011_bad
SCC(1): [double_free_011_good]
 +double_free_011_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N85): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N42
On edge  : N42 -{Return edge from double_free_011_good to main}-> N89
Message  : the heap object @H(double_free_011_good::call) is not referenced any more
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the false branch, At N53 of Function double_free_011_good
> takes the false branch, At N65 of Function double_free_011_good
<Defect> : N42 -> N89: [Return edge from double_free_011_good to main]
N42 -> N89: [Return edge from double_free_011_good to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from double_free_011_bad to main}-> N90
Message  : the heap object @H(double_free_011_bad::call) is not referenced any more
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the true branch, At N53 of Function double_free_011_good
> Leaving function: double_free_011_good, On N42 -> N89 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N89 -> N1 (call double_free_011_bad)
> takes the false branch, At N11 of Function double_free_011_bad
> takes the false branch, At N23 of Function double_free_011_bad
<Defect> : N0 -> N90: [Return edge from double_free_011_bad to main]
N0 -> N90: [Return edge from double_free_011_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N28
On edge  : N28 -{call void @free(i8* %4, i8* @free)}-> N30
Message  : the memory is already freed
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the true branch, At N53 of Function double_free_011_good
> Leaving function: double_free_011_good, On N42 -> N89 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N89 -> N1 (call double_free_011_bad)
> takes the false branch, At N11 of Function double_free_011_bad
> takes the true branch, At N23 of Function double_free_011_bad
> takes the true branch, At N26 of Function double_free_011_bad
> takes the true branch, At N23 of Function double_free_011_bad
> takes the true branch, At N26 of Function double_free_011_bad
<Defect> : N28 -> N30: [call void @free(i8* %4, i8* @free)]
N28 -> N30: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N28
On edge  : N28 -{call void @free(i8* %4, i8* @free)}-> N30
Message  : the memory is already freed
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the true branch, At N53 of Function double_free_011_good
> Leaving function: double_free_011_good, On N42 -> N89 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N89 -> N1 (call double_free_011_bad)
> takes the false branch, At N11 of Function double_free_011_bad
> takes the true branch, At N23 of Function double_free_011_bad
> takes the true branch, At N26 of Function double_free_011_bad
> takes the true branch, At N23 of Function double_free_011_bad
> takes the true branch, At N26 of Function double_free_011_bad
<Defect> : N28 -> N30: [call void @free(i8* %4, i8* @free)]
N28 -> N30: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./415_double_free_11.c 58] double_free_011_good 		[N42 -{Return edge from double_free_011_good to main}-> N89]	(the heap object @H(double_free_011_good::call) is not referenced any more)
	[./415_double_free_11.c 59] double_free_011_bad 		[N0 -{Return edge from double_free_011_bad to main}-> N90]	(the heap object @H(double_free_011_bad::call) is not referenced any more)

CWE_416(Use After Free): 1
	[./415_double_free_11.c 27] double_free_011_bad 		[N28 -{call void @free(i8* %4, i8* @free)}-> N30]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_11.c 27] double_free_011_bad 		[N28 -{call void @free(i8* %4, i8* @free)}-> N30]	(the memory is already freed)

Found 4 defects in all (14 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_005_bad]
 +double_free_005_bad
SCC(1): [double_free_005_good]
 +double_free_005_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.086s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N47): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N16
On edge  : N16 -{call void @free(i8* %3, i8* @free)}-> N18
Message  : the memory is already freed
> Start from entry function: main, At N47 of Function main
> Entering function: double_free_005_good, On N50 -> N25 (call double_free_005_good)
> takes the true branch, At N32 of Function double_free_005_good
> Leaving function: double_free_005_good, On N24 -> N51 (Return edge from double_free_005_good to main)
> Entering function: double_free_005_bad, On N51 -> N1 (call double_free_005_bad)
> takes the false branch, At N8 of Function double_free_005_bad
> takes the true branch, At N14 of Function double_free_005_bad
<Defect> : N16 -> N18: [call void @free(i8* %3, i8* @free)]
N16 -> N18: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N16
On edge  : N16 -{call void @free(i8* %3, i8* @free)}-> N18
Message  : the memory is already freed
> Start from entry function: main, At N47 of Function main
> Entering function: double_free_005_good, On N50 -> N25 (call double_free_005_good)
> takes the true branch, At N32 of Function double_free_005_good
> Leaving function: double_free_005_good, On N24 -> N51 (Return edge from double_free_005_good to main)
> Entering function: double_free_005_bad, On N51 -> N1 (call double_free_005_bad)
> takes the false branch, At N8 of Function double_free_005_bad
> takes the true branch, At N14 of Function double_free_005_bad
<Defect> : N16 -> N18: [call void @free(i8* %3, i8* @free)]
N16 -> N18: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_5.c 25] double_free_005_bad 		[N16 -{call void @free(i8* %3, i8* @free)}-> N18]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_5.c 25] double_free_005_bad 		[N16 -{call void @free(i8* %3, i8* @free)}-> N18]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_010_bad]
 +double_free_010_bad
SCC(1): [double_free_010_good]
 +double_free_010_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the true branch, At N41 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the false branch, At N16 of Function double_free_010_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the true branch, At N41 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the false branch, At N16 of Function double_free_010_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_double_free_10.c 29] double_free_010_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_double_free_10.c 29] double_free_010_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_004_bad]
 +double_free_004_bad
SCC(1): [double_free_004_good]
 +double_free_004_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N88): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from double_free_004_bad to main}-> N93
Message  : the heap object @H(double_free_004_bad::call) is not referenced any more
> Start from entry function: main, At N88 of Function main
> Entering function: double_free_004_good, On N91 -> N52 (call double_free_004_good)
> takes the true branch, At N60 of Function double_free_004_good
> Leaving function: double_free_004_good, On N51 -> N92 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N92 -> N1 (call double_free_004_bad)
> takes the false branch, At N9 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the false branch, At N16 of Function double_free_004_bad
> takes the false branch, At N30 of Function double_free_004_bad
> takes the false branch, At N37 of Function double_free_004_bad
<Defect> : N0 -> N93: [Return edge from double_free_004_bad to main]
N0 -> N93: [Return edge from double_free_004_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N39
On edge  : N39 -{call void @free(i8* %6, i8* @free)}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N88 of Function main
> Entering function: double_free_004_good, On N91 -> N52 (call double_free_004_good)
> takes the true branch, At N60 of Function double_free_004_good
> Leaving function: double_free_004_good, On N51 -> N92 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N92 -> N1 (call double_free_004_bad)
> takes the false branch, At N9 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the false branch, At N16 of Function double_free_004_bad
> takes the true branch, At N30 of Function double_free_004_bad
> takes the true branch, At N37 of Function double_free_004_bad
<Defect> : N39 -> N41: [call void @free(i8* %6, i8* @free)]
N39 -> N41: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call void @free(i8* %6, i8* @free)}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N88 of Function main
> Entering function: double_free_004_good, On N91 -> N52 (call double_free_004_good)
> takes the true branch, At N60 of Function double_free_004_good
> Leaving function: double_free_004_good, On N51 -> N92 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N92 -> N1 (call double_free_004_bad)
> takes the false branch, At N9 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the true branch, At N16 of Function double_free_004_bad
> takes the false branch, At N16 of Function double_free_004_bad
> takes the true branch, At N30 of Function double_free_004_bad
> takes the true branch, At N37 of Function double_free_004_bad
<Defect> : N39 -> N41: [call void @free(i8* %6, i8* @free)]
N39 -> N41: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./415_double_free_4.c 66] double_free_004_bad 		[N0 -{Return edge from double_free_004_bad to main}-> N93]	(the heap object @H(double_free_004_bad::call) is not referenced any more)

CWE_415(Double Free): 1
	[./415_double_free_4.c 37] double_free_004_bad 		[N39 -{call void @free(i8* %6, i8* @free)}-> N41]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_double_free_4.c 37] double_free_004_bad 		[N39 -{call void @free(i8* %6, i8* @free)}-> N41]	(the memory is already freed)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_001_bad]
 +double_free_001_bad
SCC(1): [double_free_001_good]
 +double_free_001_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.077s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N37): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N13
On edge  : N13 -{call void @free(i8* %2, i8* @free)}-> N15
Message  : the memory is already freed
> Start from entry function: main, At N37 of Function main
> Entering function: double_free_001_good, On N40 -> N20 (call double_free_001_good)
> takes the true branch, At N27 of Function double_free_001_good
> Leaving function: double_free_001_good, On N19 -> N41 (Return edge from double_free_001_good to main)
> Entering function: double_free_001_bad, On N41 -> N1 (call double_free_001_bad)
> takes the false branch, At N8 of Function double_free_001_bad
<Defect> : N13 -> N15: [call void @free(i8* %2, i8* @free)]
N13 -> N15: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N13
On edge  : N13 -{call void @free(i8* %2, i8* @free)}-> N15
Message  : the memory is already freed
> Start from entry function: main, At N37 of Function main
> Entering function: double_free_001_good, On N40 -> N20 (call double_free_001_good)
> takes the true branch, At N27 of Function double_free_001_good
> Leaving function: double_free_001_good, On N19 -> N41 (Return edge from double_free_001_good to main)
> Entering function: double_free_001_bad, On N41 -> N1 (call double_free_001_bad)
> takes the false branch, At N8 of Function double_free_001_bad
<Defect> : N13 -> N15: [call void @free(i8* %2, i8* @free)]
N13 -> N15: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_1.c 25] double_free_001_bad 		[N13 -{call void @free(i8* %2, i8* @free)}-> N15]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_1.c 25] double_free_001_bad 		[N13 -{call void @free(i8* %2, i8* @free)}-> N15]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark/itc/415/415_double_free_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_012_bad]
 +double_free_012_bad
SCC(1): [double_free_012_good]
 +double_free_012_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N19
On edge  : N19 -{call void @free(i8* %2, i8* @free)}-> N21
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: double_free_012_good, On N66 -> N32 (call double_free_012_good)
> takes the true branch, At N40 of Function double_free_012_good
> Leaving function: double_free_012_good, On N31 -> N67 (Return edge from double_free_012_good to main)
> Entering function: double_free_012_bad, On N67 -> N1 (call double_free_012_bad)
> takes the false branch, At N9 of Function double_free_012_bad
> takes the true branch, At N17 of Function double_free_012_bad
> takes the true branch, At N17 of Function double_free_012_bad
<Defect> : N19 -> N21: [call void @free(i8* %2, i8* @free)]
N19 -> N21: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call void @free(i8* %2, i8* @free)}-> N21
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: double_free_012_good, On N66 -> N32 (call double_free_012_good)
> takes the true branch, At N40 of Function double_free_012_good
> Leaving function: double_free_012_good, On N31 -> N67 (Return edge from double_free_012_good to main)
> Entering function: double_free_012_bad, On N67 -> N1 (call double_free_012_bad)
> takes the false branch, At N9 of Function double_free_012_bad
> takes the true branch, At N17 of Function double_free_012_bad
> takes the true branch, At N17 of Function double_free_012_bad
<Defect> : N19 -> N21: [call void @free(i8* %2, i8* @free)]
N19 -> N21: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_double_free_12.c 26] double_free_012_bad 		[N19 -{call void @free(i8* %2, i8* @free)}-> N21]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_double_free_12.c 26] double_free_012_bad 		[N19 -{call void @free(i8* %2, i8* @free)}-> N21]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

