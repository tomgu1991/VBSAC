Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad48 to main}-> N71
Message  : the heap object @H(bad48::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good48, On N69 -> N39 (call good48)
> takes the true branch, At N48 of Function good48
> Leaving function: good48, On N38 -> N70 (Return edge from good48 to main)
> Entering function: bad48, On N70 -> N1 (call bad48)
> takes the false branch, At N10 of Function bad48
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad48)
<Defect> : N0 -> N71: [Return edge from bad48 to main]
N0 -> N71: [Return edge from bad48 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_48.c 103] bad48 		[N0 -{Return edge from bad48 to main}-> N71]	(the heap object @H(bad48::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad15 to main}-> N62
Message  : the heap object @H(bad15::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good15, On N60 -> N35 (call good15)
> takes the true branch, At N43 of Function good15
> Leaving function: good15, On N34 -> N61 (Return edge from good15 to main)
> Entering function: bad15, On N61 -> N1 (call bad15)
> takes the false branch, At N9 of Function bad15
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad15)
<Defect> : N0 -> N62: [Return edge from bad15 to main]
N0 -> N62: [Return edge from bad15 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_15.c 123] bad15 		[N0 -{Return edge from bad15 to main}-> N62]	(the heap object @H(bad15::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad13 to main}-> N62
Message  : the heap object @H(bad13::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good13, On N60 -> N35 (call good13)
> takes the true branch, At N43 of Function good13
> Leaving function: good13, On N34 -> N61 (Return edge from good13 to main)
> Entering function: bad13, On N61 -> N1 (call bad13)
> takes the false branch, At N9 of Function bad13
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad13)
<Defect> : N0 -> N62: [Return edge from bad13 to main]
N0 -> N62: [Return edge from bad13 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_13.c 104] bad13 		[N0 -{Return edge from bad13 to main}-> N62]	(the heap object @H(bad13::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad25 to main}-> N62
Message  : the heap object @H(bad25::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good25, On N60 -> N35 (call good25)
> takes the true branch, At N43 of Function good25
> Leaving function: good25, On N34 -> N61 (Return edge from good25 to main)
> Entering function: bad25, On N61 -> N1 (call bad25)
> takes the false branch, At N9 of Function bad25
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad25)
<Defect> : N0 -> N62: [Return edge from bad25 to main]
N0 -> N62: [Return edge from bad25 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_25.c 102] bad25 		[N0 -{Return edge from bad25 to main}-> N62]	(the heap object @H(bad25::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N46
On edge  : N46 -{Return edge from good42 to main}-> N87
Message  : the heap object @H(good42::call1) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good42, On N86 -> N47 (call good42)
> Entering function: globalReturnsTrue, On N51 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N52 (Return edge from globalReturnsTrue to good42)
> takes the true branch, At N53 of Function good42
> takes the false branch, At N59 of Function good42
> Entering function: printLine, On N64 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N66 (Return edge from printLine to good42)
> Entering function: globalReturnsFalse, On N66 -> N33 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N32 -> N67 (Return edge from globalReturnsFalse to good42)
> takes the true branch, At N68 of Function good42
> Entering function: printLine, On N80 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N74 (Return edge from printLine to good42)
<Defect> : N46 -> N87: [Return edge from good42 to main]
N46 -> N87: [Return edge from good42 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad42 to main}-> N88
Message  : the heap object @H(bad42::call1) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good42, On N86 -> N47 (call good42)
> Entering function: globalReturnsTrue, On N51 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N52 (Return edge from globalReturnsTrue to good42)
> takes the true branch, At N53 of Function good42
> takes the true branch, At N59 of Function good42
> Leaving function: good42, On N46 -> N87 (Return edge from good42 to main)
> Entering function: bad42, On N87 -> N1 (call bad42)
> Entering function: globalReturnsTrue, On N5 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N6 (Return edge from globalReturnsTrue to bad42)
> takes the true branch, At N7 of Function bad42
> takes the false branch, At N13 of Function bad42
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad42)
> Entering function: globalReturnsTrue, On N20 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N21 (Return edge from globalReturnsTrue to bad42)
> takes the true branch, At N22 of Function bad42
<Defect> : N0 -> N88: [Return edge from bad42 to main]
N0 -> N88: [Return edge from bad42 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N72
On edge  : N72 -{call void @free(i8* %4, i8* @free)}-> N74
Message  : null pointer dereference
> Start from entry function: main, At N83 of Function main
> Entering function: good42, On N86 -> N47 (call good42)
> Entering function: globalReturnsTrue, On N51 -> N37 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N36 -> N52 (Return edge from globalReturnsTrue to good42)
> takes the false branch, At N53 of Function good42
> Entering function: globalReturnsFalse, On N66 -> N33 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N32 -> N67 (Return edge from globalReturnsFalse to good42)
> takes the false branch, At N68 of Function good42
<Defect> : N72 -> N74: [call void @free(i8* %4, i8* @free)]
N72 -> N74: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./401_42.c 101] good42 		[N46 -{Return edge from good42 to main}-> N87]	(the heap object @H(good42::call1) is not referenced any more)
	[./401_42.c 102] bad42 		[N0 -{Return edge from bad42 to main}-> N88]	(the heap object @H(bad42::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_42.c 94] good42 		[N72 -{call void @free(i8* %4, i8* @free)}-> N74]	(null pointer dereference)

Found 3 defects in all (15 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %3, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good23, On N84 -> N46 (call good23)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good23)
> takes the false branch, At N52 of Function good23
> Entering function: staticReturnsFalse, On N64 -> N113 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N112 -> N65 (Return edge from staticReturnsFalse to good23)
> takes the false branch, At N66 of Function good23
<Defect> : N70 -> N72: [call void @free(i8* %3, i8* @free)]
N70 -> N72: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good23 to main}-> N85
Message  : the heap object @H(good23::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good23, On N84 -> N46 (call good23)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good23)
> takes the true branch, At N52 of Function good23
> takes the false branch, At N57 of Function good23
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good23)
> Entering function: staticReturnsFalse, On N64 -> N113 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N112 -> N65 (Return edge from staticReturnsFalse to good23)
> takes the true branch, At N66 of Function good23
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good23)
<Defect> : N45 -> N85: [Return edge from good23 to main]
N45 -> N85: [Return edge from good23 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad23 to main}-> N86
Message  : the heap object @H(bad23::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good23, On N84 -> N46 (call good23)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good23)
> takes the true branch, At N52 of Function good23
> takes the true branch, At N57 of Function good23
> Leaving function: good23, On N45 -> N85 (Return edge from good23 to main)
> Entering function: bad23, On N85 -> N1 (call bad23)
> Entering function: staticReturnsTrue, On N5 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N6 (Return edge from staticReturnsTrue to bad23)
> takes the true branch, At N7 of Function bad23
> takes the false branch, At N12 of Function bad23
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad23)
> Entering function: staticReturnsTrue, On N19 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N20 (Return edge from staticReturnsTrue to bad23)
> takes the true branch, At N21 of Function bad23
<Defect> : N0 -> N86: [Return edge from bad23 to main]
N0 -> N86: [Return edge from bad23 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_23.c 104] good23 		[N70 -{call void @free(i8* %3, i8* @free)}-> N72]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_23.c 111] good23 		[N45 -{Return edge from good23 to main}-> N85]	(the heap object @H(good23::call1) is not referenced any more)
	[./401_23.c 112] bad23 		[N0 -{Return edge from bad23 to main}-> N86]	(the heap object @H(bad23::call1) is not referenced any more)

Found 3 defects in all (15 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.156s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad46 to main}-> N71
Message  : the heap object @H(bad46::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good46, On N69 -> N39 (call good46)
> takes the true branch, At N48 of Function good46
> Leaving function: good46, On N38 -> N70 (Return edge from good46 to main)
> Entering function: bad46, On N70 -> N1 (call bad46)
> takes the false branch, At N10 of Function bad46
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad46)
<Defect> : N0 -> N71: [Return edge from bad46 to main]
N0 -> N71: [Return edge from bad46 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_46.c 105] bad46 		[N0 -{Return edge from bad46 to main}-> N71]	(the heap object @H(bad46::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good30, On N84 -> N46 (call good30)
> takes the false branch, At N52 of Function good30
> takes the false branch, At N66 of Function good30
<Defect> : N70 -> N72: [call void @free(i8* %5, i8* @free)]
N70 -> N72: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good30 to main}-> N85
Message  : the heap object @H(good30::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good30, On N84 -> N46 (call good30)
> takes the true branch, At N52 of Function good30
> takes the false branch, At N57 of Function good30
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good30)
> takes the true branch, At N66 of Function good30
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good30)
<Defect> : N45 -> N85: [Return edge from good30 to main]
N45 -> N85: [Return edge from good30 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad30 to main}-> N86
Message  : the heap object @H(bad30::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good30, On N84 -> N46 (call good30)
> takes the true branch, At N52 of Function good30
> takes the true branch, At N57 of Function good30
> Leaving function: good30, On N45 -> N85 (Return edge from good30 to main)
> Entering function: bad30, On N85 -> N1 (call bad30)
> takes the true branch, At N7 of Function bad30
> takes the false branch, At N12 of Function bad30
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad30)
> takes the true branch, At N21 of Function bad30
<Defect> : N0 -> N86: [Return edge from bad30 to main]
N0 -> N86: [Return edge from bad30 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_30.c 94] good30 		[N70 -{call void @free(i8* %5, i8* @free)}-> N72]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_30.c 101] good30 		[N45 -{Return edge from good30 to main}-> N85]	(the heap object @H(good30::call) is not referenced any more)
	[./401_30.c 102] bad30 		[N0 -{Return edge from bad30 to main}-> N86]	(the heap object @H(bad30::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad40 to main}-> N64
Message  : the heap object @H(bad40::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good40, On N62 -> N36 (call good40)
> takes the true branch, At N45 of Function good40
> Leaving function: good40, On N35 -> N63 (Return edge from good40 to main)
> Entering function: bad40, On N63 -> N1 (call bad40)
> takes the false branch, At N10 of Function bad40
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad40)
<Defect> : N0 -> N64: [Return edge from bad40 to main]
N0 -> N64: [Return edge from bad40 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_40.c 103] bad40 		[N0 -{Return edge from bad40 to main}-> N64]	(the heap object @H(bad40::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad44 to main}-> N71
Message  : the heap object @H(bad44::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good44, On N69 -> N39 (call good44)
> takes the true branch, At N48 of Function good44
> Leaving function: good44, On N38 -> N70 (Return edge from good44 to main)
> Entering function: bad44, On N70 -> N1 (call bad44)
> takes the false branch, At N10 of Function bad44
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad44)
<Defect> : N0 -> N71: [Return edge from bad44 to main]
N0 -> N71: [Return edge from bad44 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_44.c 102] bad44 		[N0 -{Return edge from bad44 to main}-> N71]	(the heap object @H(bad44::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N49
On edge  : N49 -{Return edge from good50 to main}-> N94
Message  : the heap object @H(good50::call1) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: good50, On N93 -> N50 (call good50)
> Entering function: staticReturnsTrue, On N54 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N55 (Return edge from staticReturnsTrue to good50)
> takes the true branch, At N56 of Function good50
> takes the false branch, At N62 of Function good50
> Entering function: printIntLine, On N70 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N72 (Return edge from printIntLine to good50)
> Entering function: staticReturnsFalse, On N72 -> N122 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N121 -> N73 (Return edge from staticReturnsFalse to good50)
> takes the true branch, At N74 of Function good50
> Entering function: printLine, On N87 -> N107 (call printLine)
> takes the true branch, At N113 of Function printLine
> Leaving function: printLine, On N106 -> N81 (Return edge from printLine to good50)
<Defect> : N49 -> N94: [Return edge from good50 to main]
N49 -> N94: [Return edge from good50 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad50 to main}-> N95
Message  : the heap object @H(bad50::call1) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: good50, On N93 -> N50 (call good50)
> Entering function: staticReturnsTrue, On N54 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N55 (Return edge from staticReturnsTrue to good50)
> takes the true branch, At N56 of Function good50
> takes the true branch, At N62 of Function good50
> Leaving function: good50, On N49 -> N94 (Return edge from good50 to main)
> Entering function: bad50, On N94 -> N1 (call bad50)
> Entering function: staticReturnsTrue, On N5 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N6 (Return edge from staticReturnsTrue to bad50)
> takes the true branch, At N7 of Function bad50
> takes the false branch, At N13 of Function bad50
> Entering function: printIntLine, On N21 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N23 (Return edge from printIntLine to bad50)
> Entering function: staticReturnsTrue, On N23 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N24 (Return edge from staticReturnsTrue to bad50)
> takes the true branch, At N25 of Function bad50
<Defect> : N0 -> N95: [Return edge from bad50 to main]
N0 -> N95: [Return edge from bad50 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N79
On edge  : N79 -{call void @free(i8* %6, i8* @free)}-> N81
Message  : null pointer dereference
> Start from entry function: main, At N90 of Function main
> Entering function: good50, On N93 -> N50 (call good50)
> Entering function: staticReturnsTrue, On N54 -> N126 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N125 -> N55 (Return edge from staticReturnsTrue to good50)
> takes the false branch, At N56 of Function good50
> Entering function: staticReturnsFalse, On N72 -> N122 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N121 -> N73 (Return edge from staticReturnsFalse to good50)
> takes the false branch, At N74 of Function good50
<Defect> : N79 -> N81: [call void @free(i8* %6, i8* @free)]
N79 -> N81: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./401_50.c 111] good50 		[N49 -{Return edge from good50 to main}-> N94]	(the heap object @H(good50::call1) is not referenced any more)
	[./401_50.c 112] bad50 		[N0 -{Return edge from bad50 to main}-> N95]	(the heap object @H(bad50::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_50.c 104] good50 		[N79 -{call void @free(i8* %6, i8* @free)}-> N81]	(null pointer dereference)

Found 3 defects in all (18 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good10, On N84 -> N46 (call good10)
> takes the false branch, At N52 of Function good10
> takes the false branch, At N66 of Function good10
<Defect> : N70 -> N72: [call void @free(i8* %5, i8* @free)]
N70 -> N72: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good10 to main}-> N85
Message  : the heap object @H(good10::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good10, On N84 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the false branch, At N57 of Function good10
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good10)
> takes the true branch, At N66 of Function good10
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good10)
<Defect> : N45 -> N85: [Return edge from good10 to main]
N45 -> N85: [Return edge from good10 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad10 to main}-> N86
Message  : the heap object @H(bad10::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good10, On N84 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the true branch, At N57 of Function good10
> Leaving function: good10, On N45 -> N85 (Return edge from good10 to main)
> Entering function: bad10, On N85 -> N1 (call bad10)
> takes the true branch, At N7 of Function bad10
> takes the false branch, At N12 of Function bad10
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad10)
> takes the true branch, At N21 of Function bad10
<Defect> : N0 -> N86: [Return edge from bad10 to main]
N0 -> N86: [Return edge from bad10 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_10.c 94] good10 		[N70 -{call void @free(i8* %5, i8* @free)}-> N72]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_10.c 102] good10 		[N45 -{Return edge from good10 to main}-> N85]	(the heap object @H(good10::call) is not referenced any more)
	[./401_10.c 103] bad10 		[N0 -{Return edge from bad10 to main}-> N86]	(the heap object @H(bad10::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad35 to main}-> N64
Message  : the heap object @H(bad35::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good35, On N62 -> N36 (call good35)
> takes the true branch, At N45 of Function good35
> Leaving function: good35, On N35 -> N63 (Return edge from good35 to main)
> Entering function: bad35, On N63 -> N1 (call bad35)
> takes the false branch, At N10 of Function bad35
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad35)
<Defect> : N0 -> N64: [Return edge from bad35 to main]
N0 -> N64: [Return edge from bad35 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_35.c 105] bad35 		[N0 -{Return edge from bad35 to main}-> N64]	(the heap object @H(bad35::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad2 to main}-> N62
Message  : the heap object @H(bad2::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good2, On N60 -> N35 (call good2)
> takes the true branch, At N43 of Function good2
> Leaving function: good2, On N34 -> N61 (Return edge from good2 to main)
> Entering function: bad2, On N61 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad2)
<Defect> : N0 -> N62: [Return edge from bad2 to main]
N0 -> N62: [Return edge from bad2 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_2.c 102] bad2 		[N0 -{Return edge from bad2 to main}-> N62]	(the heap object @H(bad2::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N46
On edge  : N46 -{Return edge from good39 to main}-> N87
Message  : the heap object @H(good39::call1) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good39, On N86 -> N47 (call good39)
> Entering function: staticReturnsTrue, On N51 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N52 (Return edge from staticReturnsTrue to good39)
> takes the true branch, At N53 of Function good39
> takes the false branch, At N59 of Function good39
> Entering function: printLine, On N64 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N66 (Return edge from printLine to good39)
> Entering function: staticReturnsFalse, On N66 -> N115 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N114 -> N67 (Return edge from staticReturnsFalse to good39)
> takes the true branch, At N68 of Function good39
> Entering function: printLine, On N80 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N74 (Return edge from printLine to good39)
<Defect> : N46 -> N87: [Return edge from good39 to main]
N46 -> N87: [Return edge from good39 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad39 to main}-> N88
Message  : the heap object @H(bad39::call1) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good39, On N86 -> N47 (call good39)
> Entering function: staticReturnsTrue, On N51 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N52 (Return edge from staticReturnsTrue to good39)
> takes the true branch, At N53 of Function good39
> takes the true branch, At N59 of Function good39
> Leaving function: good39, On N46 -> N87 (Return edge from good39 to main)
> Entering function: bad39, On N87 -> N1 (call bad39)
> Entering function: staticReturnsTrue, On N5 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N6 (Return edge from staticReturnsTrue to bad39)
> takes the true branch, At N7 of Function bad39
> takes the false branch, At N13 of Function bad39
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad39)
> Entering function: staticReturnsTrue, On N20 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N21 (Return edge from staticReturnsTrue to bad39)
> takes the true branch, At N22 of Function bad39
<Defect> : N0 -> N88: [Return edge from bad39 to main]
N0 -> N88: [Return edge from bad39 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N72
On edge  : N72 -{call void @free(i8* %4, i8* @free)}-> N74
Message  : null pointer dereference
> Start from entry function: main, At N83 of Function main
> Entering function: good39, On N86 -> N47 (call good39)
> Entering function: staticReturnsTrue, On N51 -> N119 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N118 -> N52 (Return edge from staticReturnsTrue to good39)
> takes the false branch, At N53 of Function good39
> Entering function: staticReturnsFalse, On N66 -> N115 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N114 -> N67 (Return edge from staticReturnsFalse to good39)
> takes the false branch, At N68 of Function good39
<Defect> : N72 -> N74: [call void @free(i8* %4, i8* @free)]
N72 -> N74: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./401_39.c 111] good39 		[N46 -{Return edge from good39 to main}-> N87]	(the heap object @H(good39::call1) is not referenced any more)
	[./401_39.c 112] bad39 		[N0 -{Return edge from bad39 to main}-> N88]	(the heap object @H(bad39::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_39.c 104] good39 		[N72 -{call void @free(i8* %4, i8* @free)}-> N74]	(null pointer dereference)

Found 3 defects in all (15 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.138s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good11 to main}-> N85
Message  : the heap object @H(good11::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good11, On N84 -> N46 (call good11)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good11)
> takes the true branch, At N52 of Function good11
> takes the false branch, At N57 of Function good11
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good11)
> Entering function: globalReturnsFalse, On N64 -> N32 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N31 -> N65 (Return edge from globalReturnsFalse to good11)
> takes the true branch, At N66 of Function good11
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good11)
<Defect> : N45 -> N85: [Return edge from good11 to main]
N45 -> N85: [Return edge from good11 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad11 to main}-> N86
Message  : the heap object @H(bad11::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good11, On N84 -> N46 (call good11)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good11)
> takes the true branch, At N52 of Function good11
> takes the true branch, At N57 of Function good11
> Leaving function: good11, On N45 -> N85 (Return edge from good11 to main)
> Entering function: bad11, On N85 -> N1 (call bad11)
> Entering function: globalReturnsTrue, On N5 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N6 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N7 of Function bad11
> takes the false branch, At N12 of Function bad11
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad11)
> Entering function: globalReturnsTrue, On N19 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N20 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N21 of Function bad11
<Defect> : N0 -> N86: [Return edge from bad11 to main]
N0 -> N86: [Return edge from bad11 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %3, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good11, On N84 -> N46 (call good11)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good11)
> takes the false branch, At N52 of Function good11
> Entering function: globalReturnsFalse, On N64 -> N32 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N31 -> N65 (Return edge from globalReturnsFalse to good11)
> takes the false branch, At N66 of Function good11
<Defect> : N70 -> N72: [call void @free(i8* %3, i8* @free)]
N70 -> N72: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./401_11.c 103] good11 		[N45 -{Return edge from good11 to main}-> N85]	(the heap object @H(good11::call1) is not referenced any more)
	[./401_11.c 104] bad11 		[N0 -{Return edge from bad11 to main}-> N86]	(the heap object @H(bad11::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_11.c 94] good11 		[N70 -{call void @free(i8* %3, i8* @free)}-> N72]	(null pointer dereference)

Found 3 defects in all (15 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad37 to main}-> N64
Message  : the heap object @H(bad37::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good37, On N62 -> N36 (call good37)
> takes the true branch, At N45 of Function good37
> Leaving function: good37, On N35 -> N63 (Return edge from good37 to main)
> Entering function: bad37, On N63 -> N1 (call bad37)
> takes the false branch, At N10 of Function bad37
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad37)
<Defect> : N0 -> N64: [Return edge from bad37 to main]
N0 -> N64: [Return edge from bad37 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_37.c 104] bad37 		[N0 -{Return edge from bad37 to main}-> N64]	(the heap object @H(bad37::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good22, On N84 -> N46 (call good22)
> takes the false branch, At N52 of Function good22
> takes the false branch, At N66 of Function good22
<Defect> : N70 -> N72: [call void @free(i8* %5, i8* @free)]
N70 -> N72: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good22 to main}-> N85
Message  : the heap object @H(good22::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good22, On N84 -> N46 (call good22)
> takes the true branch, At N52 of Function good22
> takes the false branch, At N57 of Function good22
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good22)
> takes the true branch, At N66 of Function good22
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good22)
<Defect> : N45 -> N85: [Return edge from good22 to main]
N45 -> N85: [Return edge from good22 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad22 to main}-> N86
Message  : the heap object @H(bad22::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good22, On N84 -> N46 (call good22)
> takes the true branch, At N52 of Function good22
> takes the true branch, At N57 of Function good22
> Leaving function: good22, On N45 -> N85 (Return edge from good22 to main)
> Entering function: bad22, On N85 -> N1 (call bad22)
> takes the true branch, At N7 of Function bad22
> takes the false branch, At N12 of Function bad22
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad22)
> takes the true branch, At N21 of Function bad22
<Defect> : N0 -> N86: [Return edge from bad22 to main]
N0 -> N86: [Return edge from bad22 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_22.c 96] good22 		[N70 -{call void @free(i8* %5, i8* @free)}-> N72]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_22.c 103] good22 		[N45 -{Return edge from good22 to main}-> N85]	(the heap object @H(good22::call) is not referenced any more)
	[./401_22.c 104] bad22 		[N0 -{Return edge from bad22 to main}-> N86]	(the heap object @H(bad22::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad21 to main}-> N62
Message  : the heap object @H(bad21::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good21, On N60 -> N35 (call good21)
> takes the true branch, At N43 of Function good21
> Leaving function: good21, On N34 -> N61 (Return edge from good21 to main)
> Entering function: bad21, On N61 -> N1 (call bad21)
> takes the false branch, At N9 of Function bad21
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad21)
<Defect> : N0 -> N62: [Return edge from bad21 to main]
N0 -> N62: [Return edge from bad21 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_21.c 104] bad21 		[N0 -{Return edge from bad21 to main}-> N62]	(the heap object @H(bad21::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.098s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad1 to main}-> N60
Message  : the heap object @H(bad1::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good1, On N58 -> N35 (call good1)
> takes the false branch, At N43 of Function good1
> Entering function: printLine, On N48 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N50 (Return edge from printLine to good1)
> Leaving function: good1, On N34 -> N59 (Return edge from good1 to main)
> Entering function: bad1, On N59 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
> Entering function: printLine, On N14 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N16 (Return edge from printLine to bad1)
<Defect> : N0 -> N60: [Return edge from bad1 to main]
N0 -> N60: [Return edge from bad1 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_1.c 86] bad1 		[N0 -{Return edge from bad1 to main}-> N60]	(the heap object @H(bad1::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.143s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good8 to main}-> N85
Message  : the heap object @H(good8::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good8, On N84 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the false branch, At N57 of Function good8
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good8)
> Entering function: staticReturnsFalse, On N64 -> N113 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N112 -> N65 (Return edge from staticReturnsFalse to good8)
> takes the true branch, At N66 of Function good8
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good8)
<Defect> : N45 -> N85: [Return edge from good8 to main]
N45 -> N85: [Return edge from good8 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad8 to main}-> N86
Message  : the heap object @H(bad8::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good8, On N84 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the true branch, At N57 of Function good8
> Leaving function: good8, On N45 -> N85 (Return edge from good8 to main)
> Entering function: bad8, On N85 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N7 of Function bad8
> takes the false branch, At N12 of Function bad8
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad8)
> Entering function: staticReturnsTrue, On N19 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N20 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N21 of Function bad8
<Defect> : N0 -> N86: [Return edge from bad8 to main]
N0 -> N86: [Return edge from bad8 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %3, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good8, On N84 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N117 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N116 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the false branch, At N52 of Function good8
> Entering function: staticReturnsFalse, On N64 -> N113 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N112 -> N65 (Return edge from staticReturnsFalse to good8)
> takes the false branch, At N66 of Function good8
<Defect> : N70 -> N72: [call void @free(i8* %3, i8* @free)]
N70 -> N72: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./401_8.c 111] good8 		[N45 -{Return edge from good8 to main}-> N85]	(the heap object @H(good8::call1) is not referenced any more)
	[./401_8.c 112] bad8 		[N0 -{Return edge from bad8 to main}-> N86]	(the heap object @H(bad8::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_8.c 104] good8 		[N70 -{call void @free(i8* %3, i8* @free)}-> N72]	(null pointer dereference)

Found 3 defects in all (15 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N72
On edge  : N72 -{call void @free(i8* %6, i8* @free)}-> N74
Message  : null pointer dereference
> Start from entry function: main, At N83 of Function main
> Entering function: good41, On N86 -> N47 (call good41)
> takes the false branch, At N53 of Function good41
> takes the false branch, At N68 of Function good41
<Defect> : N72 -> N74: [call void @free(i8* %6, i8* @free)]
N72 -> N74: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N46
On edge  : N46 -{Return edge from good41 to main}-> N87
Message  : the heap object @H(good41::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good41, On N86 -> N47 (call good41)
> takes the true branch, At N53 of Function good41
> takes the false branch, At N59 of Function good41
> Entering function: printLine, On N64 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N66 (Return edge from printLine to good41)
> takes the true branch, At N68 of Function good41
> Entering function: printLine, On N80 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N74 (Return edge from printLine to good41)
<Defect> : N46 -> N87: [Return edge from good41 to main]
N46 -> N87: [Return edge from good41 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad41 to main}-> N88
Message  : the heap object @H(bad41::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good41, On N86 -> N47 (call good41)
> takes the true branch, At N53 of Function good41
> takes the true branch, At N59 of Function good41
> Leaving function: good41, On N46 -> N87 (Return edge from good41 to main)
> Entering function: bad41, On N87 -> N1 (call bad41)
> takes the true branch, At N7 of Function bad41
> takes the false branch, At N13 of Function bad41
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad41)
> takes the true branch, At N22 of Function bad41
<Defect> : N0 -> N88: [Return edge from bad41 to main]
N0 -> N88: [Return edge from bad41 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_41.c 94] good41 		[N72 -{call void @free(i8* %6, i8* @free)}-> N74]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_41.c 100] good41 		[N46 -{Return edge from good41 to main}-> N87]	(the heap object @H(good41::call) is not referenced any more)
	[./401_41.c 101] bad41 		[N0 -{Return edge from bad41 to main}-> N88]	(the heap object @H(bad41::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good7 to main}-> N85
Message  : the heap object @H(good7::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good7, On N84 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the false branch, At N57 of Function good7
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good7)
> takes the true branch, At N66 of Function good7
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good7)
<Defect> : N45 -> N85: [Return edge from good7 to main]
N45 -> N85: [Return edge from good7 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad7 to main}-> N86
Message  : the heap object @H(bad7::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good7, On N84 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the true branch, At N57 of Function good7
> Leaving function: good7, On N45 -> N85 (Return edge from good7 to main)
> Entering function: bad7, On N85 -> N1 (call bad7)
> takes the true branch, At N7 of Function bad7
> takes the false branch, At N12 of Function bad7
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad7)
> takes the true branch, At N21 of Function bad7
<Defect> : N0 -> N86: [Return edge from bad7 to main]
N0 -> N86: [Return edge from bad7 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good7, On N84 -> N46 (call good7)
> takes the false branch, At N52 of Function good7
> takes the false branch, At N66 of Function good7
<Defect> : N70 -> N72: [call void @free(i8* %5, i8* @free)]
N70 -> N72: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./401_7.c 104] good7 		[N45 -{Return edge from good7 to main}-> N85]	(the heap object @H(good7::call) is not referenced any more)
	[./401_7.c 105] bad7 		[N0 -{Return edge from bad7 to main}-> N86]	(the heap object @H(bad7::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_7.c 96] good7 		[N70 -{call void @free(i8* %5, i8* @free)}-> N72]	(null pointer dereference)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N56): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad32 to main}-> N61
Message  : the heap object @H(bad32::call) is not referenced any more
> Start from entry function: main, At N56 of Function main
> Entering function: good32, On N59 -> N36 (call good32)
> takes the false branch, At N44 of Function good32
> Entering function: printLine, On N49 -> N73 (call printLine)
> takes the true branch, At N79 of Function printLine
> Leaving function: printLine, On N72 -> N51 (Return edge from printLine to good32)
> Leaving function: good32, On N35 -> N60 (Return edge from good32 to main)
> Entering function: bad32, On N60 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
> Entering function: printLine, On N15 -> N73 (call printLine)
> takes the true branch, At N79 of Function printLine
> Leaving function: printLine, On N72 -> N17 (Return edge from printLine to bad32)
<Defect> : N0 -> N61: [Return edge from bad32 to main]
N0 -> N61: [Return edge from bad32 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_32.c 85] bad32 		[N0 -{Return edge from bad32 to main}-> N61]	(the heap object @H(bad32::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad6 to main}-> N62
Message  : the heap object @H(bad6::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good6, On N60 -> N35 (call good6)
> takes the true branch, At N43 of Function good6
> Leaving function: good6, On N34 -> N61 (Return edge from good6 to main)
> Entering function: bad6, On N61 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad6)
<Defect> : N0 -> N62: [Return edge from bad6 to main]
N0 -> N62: [Return edge from bad6 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_6.c 105] bad6 		[N0 -{Return edge from bad6 to main}-> N62]	(the heap object @H(bad6::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad17 to main}-> N62
Message  : the heap object @H(bad17::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good17, On N60 -> N35 (call good17)
> takes the true branch, At N43 of Function good17
> Leaving function: good17, On N34 -> N61 (Return edge from good17 to main)
> Entering function: bad17, On N61 -> N1 (call bad17)
> takes the false branch, At N9 of Function bad17
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad17)
<Defect> : N0 -> N62: [Return edge from bad17 to main]
N0 -> N62: [Return edge from bad17 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_17.c 102] bad17 		[N0 -{Return edge from bad17 to main}-> N62]	(the heap object @H(bad17::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad31 to main}-> N62
Message  : the heap object @H(bad31::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good31, On N60 -> N35 (call good31)
> takes the true branch, At N43 of Function good31
> Leaving function: good31, On N34 -> N61 (Return edge from good31 to main)
> Entering function: bad31, On N61 -> N1 (call bad31)
> takes the false branch, At N9 of Function bad31
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad31)
<Defect> : N0 -> N62: [Return edge from bad31 to main]
N0 -> N62: [Return edge from bad31 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_31.c 120] bad31 		[N0 -{Return edge from bad31 to main}-> N62]	(the heap object @H(bad31::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad19 to main}-> N62
Message  : the heap object @H(bad19::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good19, On N60 -> N35 (call good19)
> takes the true branch, At N43 of Function good19
> Leaving function: good19, On N34 -> N61 (Return edge from good19 to main)
> Entering function: bad19, On N61 -> N1 (call bad19)
> takes the false branch, At N9 of Function bad19
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad19)
<Defect> : N0 -> N62: [Return edge from bad19 to main]
N0 -> N62: [Return edge from bad19 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_19.c 105] bad19 		[N0 -{Return edge from bad19 to main}-> N62]	(the heap object @H(bad19::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.123s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N79
On edge  : N79 -{call void @free(i8* %8, i8* @free)}-> N81
Message  : null pointer dereference
> Start from entry function: main, At N90 of Function main
> Entering function: good49, On N93 -> N50 (call good49)
> takes the false branch, At N56 of Function good49
> takes the false branch, At N74 of Function good49
<Defect> : N79 -> N81: [call void @free(i8* %8, i8* @free)]
N79 -> N81: [call void @free(i8* %8, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N49
On edge  : N49 -{Return edge from good49 to main}-> N94
Message  : the heap object @H(good49::call) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: good49, On N93 -> N50 (call good49)
> takes the true branch, At N56 of Function good49
> takes the false branch, At N62 of Function good49
> Entering function: printIntLine, On N70 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N72 (Return edge from printIntLine to good49)
> takes the true branch, At N74 of Function good49
> Entering function: printLine, On N87 -> N107 (call printLine)
> takes the true branch, At N113 of Function printLine
> Leaving function: printLine, On N106 -> N81 (Return edge from printLine to good49)
<Defect> : N49 -> N94: [Return edge from good49 to main]
N49 -> N94: [Return edge from good49 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad49 to main}-> N95
Message  : the heap object @H(bad49::call) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: good49, On N93 -> N50 (call good49)
> takes the true branch, At N56 of Function good49
> takes the true branch, At N62 of Function good49
> Leaving function: good49, On N49 -> N94 (Return edge from good49 to main)
> Entering function: bad49, On N94 -> N1 (call bad49)
> takes the true branch, At N7 of Function bad49
> takes the false branch, At N13 of Function bad49
> Entering function: printIntLine, On N21 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N23 (Return edge from printIntLine to bad49)
> takes the true branch, At N25 of Function bad49
<Defect> : N0 -> N95: [Return edge from bad49 to main]
N0 -> N95: [Return edge from bad49 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_49.c 96] good49 		[N79 -{call void @free(i8* %8, i8* @free)}-> N81]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_49.c 103] good49 		[N49 -{Return edge from good49 to main}-> N94]	(the heap object @H(good49::call) is not referenced any more)
	[./401_49.c 104] bad49 		[N0 -{Return edge from bad49 to main}-> N95]	(the heap object @H(bad49::call) is not referenced any more)

Found 3 defects in all (15 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad16 to main}-> N60
Message  : the heap object @H(bad16::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good16, On N58 -> N35 (call good16)
> takes the false branch, At N43 of Function good16
> Entering function: printLine, On N48 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N50 (Return edge from printLine to good16)
> Leaving function: good16, On N34 -> N59 (Return edge from good16 to main)
> Entering function: bad16, On N59 -> N1 (call bad16)
> takes the false branch, At N9 of Function bad16
> Entering function: printLine, On N14 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N16 (Return edge from printLine to bad16)
<Defect> : N0 -> N60: [Return edge from bad16 to main]
N0 -> N60: [Return edge from bad16 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_16.c 87] bad16 		[N0 -{Return edge from bad16 to main}-> N60]	(the heap object @H(bad16::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good20, On N84 -> N46 (call good20)
> takes the false branch, At N52 of Function good20
> takes the false branch, At N66 of Function good20
<Defect> : N70 -> N72: [call void @free(i8* %5, i8* @free)]
N70 -> N72: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good20 to main}-> N85
Message  : the heap object @H(good20::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good20, On N84 -> N46 (call good20)
> takes the true branch, At N52 of Function good20
> takes the false branch, At N57 of Function good20
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good20)
> takes the true branch, At N66 of Function good20
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good20)
<Defect> : N45 -> N85: [Return edge from good20 to main]
N45 -> N85: [Return edge from good20 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad20 to main}-> N86
Message  : the heap object @H(bad20::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good20, On N84 -> N46 (call good20)
> takes the true branch, At N52 of Function good20
> takes the true branch, At N57 of Function good20
> Leaving function: good20, On N45 -> N85 (Return edge from good20 to main)
> Entering function: bad20, On N85 -> N1 (call bad20)
> takes the true branch, At N7 of Function bad20
> takes the false branch, At N12 of Function bad20
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad20)
> takes the true branch, At N21 of Function bad20
<Defect> : N0 -> N86: [Return edge from bad20 to main]
N0 -> N86: [Return edge from bad20 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_20.c 97] good20 		[N70 -{call void @free(i8* %5, i8* @free)}-> N72]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_20.c 103] good20 		[N45 -{Return edge from good20 to main}-> N85]	(the heap object @H(good20::call) is not referenced any more)
	[./401_20.c 104] bad20 		[N0 -{Return edge from bad20 to main}-> N86]	(the heap object @H(bad20::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N66): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad45 to main}-> N71
Message  : the heap object @H(bad45::call) is not referenced any more
> Start from entry function: main, At N66 of Function main
> Entering function: good45, On N69 -> N39 (call good45)
> takes the true branch, At N48 of Function good45
> Leaving function: good45, On N38 -> N70 (Return edge from good45 to main)
> Entering function: bad45, On N70 -> N1 (call bad45)
> takes the false branch, At N10 of Function bad45
> Entering function: printIntLine, On N18 -> N74 (call printIntLine)
> Leaving function: printIntLine, On N73 -> N20 (Return edge from printIntLine to bad45)
<Defect> : N0 -> N71: [Return edge from bad45 to main]
N0 -> N71: [Return edge from bad45 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_45.c 102] bad45 		[N0 -{Return edge from bad45 to main}-> N71]	(the heap object @H(bad45::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good27 to main}-> N85
Message  : the heap object @H(good27::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good27, On N84 -> N46 (call good27)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good27)
> takes the true branch, At N52 of Function good27
> takes the false branch, At N57 of Function good27
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good27)
> Entering function: globalReturnsFalse, On N64 -> N32 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N31 -> N65 (Return edge from globalReturnsFalse to good27)
> takes the true branch, At N66 of Function good27
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good27)
<Defect> : N45 -> N85: [Return edge from good27 to main]
N45 -> N85: [Return edge from good27 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad27 to main}-> N86
Message  : the heap object @H(bad27::call1) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good27, On N84 -> N46 (call good27)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good27)
> takes the true branch, At N52 of Function good27
> takes the true branch, At N57 of Function good27
> Leaving function: good27, On N45 -> N85 (Return edge from good27 to main)
> Entering function: bad27, On N85 -> N1 (call bad27)
> Entering function: globalReturnsTrue, On N5 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N6 (Return edge from globalReturnsTrue to bad27)
> takes the true branch, At N7 of Function bad27
> takes the false branch, At N12 of Function bad27
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad27)
> Entering function: globalReturnsTrue, On N19 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N20 (Return edge from globalReturnsTrue to bad27)
> takes the true branch, At N21 of Function bad27
<Defect> : N0 -> N86: [Return edge from bad27 to main]
N0 -> N86: [Return edge from bad27 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %3, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good27, On N84 -> N46 (call good27)
> Entering function: globalReturnsTrue, On N50 -> N36 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N35 -> N51 (Return edge from globalReturnsTrue to good27)
> takes the false branch, At N52 of Function good27
> Entering function: globalReturnsFalse, On N64 -> N32 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N31 -> N65 (Return edge from globalReturnsFalse to good27)
> takes the false branch, At N66 of Function good27
<Defect> : N70 -> N72: [call void @free(i8* %3, i8* @free)]
N70 -> N72: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./401_27.c 101] good27 		[N45 -{Return edge from good27 to main}-> N85]	(the heap object @H(good27::call1) is not referenced any more)
	[./401_27.c 102] bad27 		[N0 -{Return edge from bad27 to main}-> N86]	(the heap object @H(bad27::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_27.c 94] good27 		[N70 -{call void @free(i8* %3, i8* @free)}-> N72]	(null pointer dereference)

Found 3 defects in all (15 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N46
On edge  : N46 -{Return edge from good36 to main}-> N87
Message  : the heap object @H(good36::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good36, On N86 -> N47 (call good36)
> takes the true branch, At N53 of Function good36
> takes the false branch, At N59 of Function good36
> Entering function: printLine, On N64 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N66 (Return edge from printLine to good36)
> takes the true branch, At N68 of Function good36
> Entering function: printLine, On N80 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N74 (Return edge from printLine to good36)
<Defect> : N46 -> N87: [Return edge from good36 to main]
N46 -> N87: [Return edge from good36 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad36 to main}-> N88
Message  : the heap object @H(bad36::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good36, On N86 -> N47 (call good36)
> takes the true branch, At N53 of Function good36
> takes the true branch, At N59 of Function good36
> Leaving function: good36, On N46 -> N87 (Return edge from good36 to main)
> Entering function: bad36, On N87 -> N1 (call bad36)
> takes the true branch, At N7 of Function bad36
> takes the false branch, At N13 of Function bad36
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad36)
> takes the true branch, At N22 of Function bad36
<Defect> : N0 -> N88: [Return edge from bad36 to main]
N0 -> N88: [Return edge from bad36 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N72
On edge  : N72 -{call void @free(i8* %6, i8* @free)}-> N74
Message  : null pointer dereference
> Start from entry function: main, At N83 of Function main
> Entering function: good36, On N86 -> N47 (call good36)
> takes the false branch, At N53 of Function good36
> takes the false branch, At N68 of Function good36
<Defect> : N72 -> N74: [call void @free(i8* %6, i8* @free)]
N72 -> N74: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./401_36.c 105] good36 		[N46 -{Return edge from good36 to main}-> N87]	(the heap object @H(good36::call) is not referenced any more)
	[./401_36.c 106] bad36 		[N0 -{Return edge from bad36 to main}-> N88]	(the heap object @H(bad36::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_36.c 98] good36 		[N72 -{call void @free(i8* %6, i8* @free)}-> N74]	(null pointer dereference)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N111): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad28 to main}-> N116
Message  : the heap object @H(bad28::call1) is not referenced any more
> Start from entry function: main, At N111 of Function main
> Entering function: good28, On N114 -> N62 (call good28)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good28)
> takes the false branch, At N68 of Function good28
> takes the true branch, At N84 of Function good28
> Leaving function: good28, On N61 -> N115 (Return edge from good28 to main)
> Entering function: bad28, On N115 -> N1 (call bad28)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the true branch, At N7 of Function bad28
> takes the false branch, At N12 of Function bad28
> Entering function: printLine, On N17 -> N128 (call printLine)
> takes the true branch, At N134 of Function printLine
> Leaving function: printLine, On N127 -> N30 (Return edge from printLine to bad28)
> Entering function: globalReturnsTrueOrFalse, On N30 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N31 (Return edge from globalReturnsTrueOrFalse to bad28)
> takes the true branch, At N32 of Function bad28
<Defect> : N0 -> N116: [Return edge from bad28 to main]
N0 -> N116: [Return edge from bad28 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_28.c 123] bad28 		[N0 -{Return edge from bad28 to main}-> N116]	(the heap object @H(bad28::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad9 to main}-> N62
Message  : the heap object @H(bad9::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good9, On N60 -> N35 (call good9)
> takes the true branch, At N43 of Function good9
> Leaving function: good9, On N34 -> N61 (Return edge from good9 to main)
> Entering function: bad9, On N61 -> N1 (call bad9)
> takes the false branch, At N9 of Function bad9
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad9)
<Defect> : N0 -> N62: [Return edge from bad9 to main]
N0 -> N62: [Return edge from bad9 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_9.c 102] bad9 		[N0 -{Return edge from bad9 to main}-> N62]	(the heap object @H(bad9::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad43 to main}-> N68
Message  : the heap object @H(bad43::call) is not referenced any more
> Start from entry function: main, At N63 of Function main
> Entering function: good43, On N66 -> N39 (call good43)
> takes the false branch, At N48 of Function good43
> Entering function: printIntLine, On N56 -> N71 (call printIntLine)
> Leaving function: printIntLine, On N70 -> N58 (Return edge from printIntLine to good43)
> Leaving function: good43, On N38 -> N67 (Return edge from good43 to main)
> Entering function: bad43, On N67 -> N1 (call bad43)
> takes the false branch, At N10 of Function bad43
> Entering function: printIntLine, On N18 -> N71 (call printIntLine)
> Leaving function: printIntLine, On N70 -> N20 (Return edge from printIntLine to bad43)
<Defect> : N0 -> N68: [Return edge from bad43 to main]
N0 -> N68: [Return edge from bad43 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_43.c 84] bad43 		[N0 -{Return edge from bad43 to main}-> N68]	(the heap object @H(bad43::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad4 to main}-> N62
Message  : the heap object @H(bad4::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good4, On N60 -> N35 (call good4)
> takes the true branch, At N43 of Function good4
> Leaving function: good4, On N34 -> N61 (Return edge from good4 to main)
> Entering function: bad4, On N61 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad4)
<Defect> : N0 -> N62: [Return edge from bad4 to main]
N0 -> N62: [Return edge from bad4 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_4.c 106] bad4 		[N0 -{Return edge from bad4 to main}-> N62]	(the heap object @H(bad4::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N83): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N72
On edge  : N72 -{call void @free(i8* %6, i8* @free)}-> N74
Message  : null pointer dereference
> Start from entry function: main, At N83 of Function main
> Entering function: good38, On N86 -> N47 (call good38)
> takes the false branch, At N53 of Function good38
> takes the false branch, At N68 of Function good38
<Defect> : N72 -> N74: [call void @free(i8* %6, i8* @free)]
N72 -> N74: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N46
On edge  : N46 -{Return edge from good38 to main}-> N87
Message  : the heap object @H(good38::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good38, On N86 -> N47 (call good38)
> takes the true branch, At N53 of Function good38
> takes the false branch, At N59 of Function good38
> Entering function: printLine, On N64 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N66 (Return edge from printLine to good38)
> takes the true branch, At N68 of Function good38
> Entering function: printLine, On N80 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N74 (Return edge from printLine to good38)
<Defect> : N46 -> N87: [Return edge from good38 to main]
N46 -> N87: [Return edge from good38 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad38 to main}-> N88
Message  : the heap object @H(bad38::call) is not referenced any more
> Start from entry function: main, At N83 of Function main
> Entering function: good38, On N86 -> N47 (call good38)
> takes the true branch, At N53 of Function good38
> takes the true branch, At N59 of Function good38
> Leaving function: good38, On N46 -> N87 (Return edge from good38 to main)
> Entering function: bad38, On N87 -> N1 (call bad38)
> takes the true branch, At N7 of Function bad38
> takes the false branch, At N13 of Function bad38
> Entering function: printLine, On N18 -> N100 (call printLine)
> takes the true branch, At N106 of Function printLine
> Leaving function: printLine, On N99 -> N20 (Return edge from printLine to bad38)
> takes the true branch, At N22 of Function bad38
<Defect> : N0 -> N88: [Return edge from bad38 to main]
N0 -> N88: [Return edge from bad38 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_38.c 96] good38 		[N72 -{call void @free(i8* %6, i8* @free)}-> N74]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_38.c 104] good38 		[N46 -{Return edge from good38 to main}-> N87]	(the heap object @H(good38::call) is not referenced any more)
	[./401_38.c 105] bad38 		[N0 -{Return edge from bad38 to main}-> N88]	(the heap object @H(bad38::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.153s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good14, On N84 -> N46 (call good14)
> takes the false branch, At N52 of Function good14
> takes the false branch, At N66 of Function good14
<Defect> : N70 -> N72: [call void @free(i8* %5, i8* @free)]
N70 -> N72: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good14 to main}-> N85
Message  : the heap object @H(good14::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good14, On N84 -> N46 (call good14)
> takes the true branch, At N52 of Function good14
> takes the false branch, At N57 of Function good14
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good14)
> takes the true branch, At N66 of Function good14
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good14)
<Defect> : N45 -> N85: [Return edge from good14 to main]
N45 -> N85: [Return edge from good14 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad14 to main}-> N86
Message  : the heap object @H(bad14::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good14, On N84 -> N46 (call good14)
> takes the true branch, At N52 of Function good14
> takes the true branch, At N57 of Function good14
> Leaving function: good14, On N45 -> N85 (Return edge from good14 to main)
> Entering function: bad14, On N85 -> N1 (call bad14)
> takes the true branch, At N7 of Function bad14
> takes the false branch, At N12 of Function bad14
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad14)
> takes the true branch, At N21 of Function bad14
<Defect> : N0 -> N86: [Return edge from bad14 to main]
N0 -> N86: [Return edge from bad14 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_14.c 94] good14 		[N70 -{call void @free(i8* %5, i8* @free)}-> N72]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_14.c 103] good14 		[N45 -{Return edge from good14 to main}-> N85]	(the heap object @H(good14::call) is not referenced any more)
	[./401_14.c 104] bad14 		[N0 -{Return edge from bad14 to main}-> N86]	(the heap object @H(bad14::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N99): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad12 to main}-> N104
Message  : the heap object @H(bad12::call1) is not referenced any more
> Start from entry function: main, At N99 of Function main
> Entering function: good12, On N102 -> N62 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N68 of Function good12
> Entering function: printLine, On N81 -> N116 (call printLine)
> takes the true branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N83 (Return edge from printLine to good12)
> Entering function: globalReturnsTrueOrFalse, On N83 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N84 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N85 of Function good12
> Leaving function: good12, On N61 -> N103 (Return edge from good12 to main)
> Entering function: bad12, On N103 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N6 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N7 of Function bad12
> takes the false branch, At N12 of Function bad12
> Entering function: printLine, On N17 -> N116 (call printLine)
> takes the true branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N30 (Return edge from printLine to bad12)
> Entering function: globalReturnsTrueOrFalse, On N30 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N31 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N32 of Function bad12
<Defect> : N0 -> N104: [Return edge from bad12 to main]
N0 -> N104: [Return edge from bad12 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N90
On edge  : N90 -{call void @free(i8* %5, i8* @free)}-> N92
Message  : null pointer dereference
> Start from entry function: main, At N99 of Function main
> Entering function: good12, On N102 -> N62 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N68 of Function good12
> Entering function: printLine, On N81 -> N116 (call printLine)
> takes the false branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N83 (Return edge from printLine to good12)
> Entering function: globalReturnsTrueOrFalse, On N83 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N84 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N85 of Function good12
<Defect> : N90 -> N92: [call void @free(i8* %5, i8* @free)]
N90 -> N92: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N87
On edge  : N87 -{call void @free(i8* %4, i8* @free)}-> N92
Message  : null pointer dereference
> Start from entry function: main, At N99 of Function main
> Entering function: good12, On N102 -> N62 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N66 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N67 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N68 of Function good12
> Entering function: printLine, On N81 -> N116 (call printLine)
> takes the false branch, At N122 of Function printLine
> Leaving function: printLine, On N115 -> N83 (Return edge from printLine to good12)
> Entering function: globalReturnsTrueOrFalse, On N83 -> N56 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N55 -> N84 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the true branch, At N85 of Function good12
<Defect> : N87 -> N92: [call void @free(i8* %4, i8* @free)]
N87 -> N92: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_12.c 124] bad12 		[N0 -{Return edge from bad12 to main}-> N104]	(the heap object @H(bad12::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 2
	[./401_12.c 115] good12 		[N90 -{call void @free(i8* %5, i8* @free)}-> N92]	(null pointer dereference)
	[./401_12.c 110] good12 		[N87 -{call void @free(i8* %4, i8* @free)}-> N92]	(null pointer dereference)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.146s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good5, On N84 -> N46 (call good5)
> takes the false branch, At N52 of Function good5
> takes the false branch, At N66 of Function good5
<Defect> : N70 -> N72: [call void @free(i8* %5, i8* @free)]
N70 -> N72: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good5 to main}-> N85
Message  : the heap object @H(good5::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good5, On N84 -> N46 (call good5)
> takes the true branch, At N52 of Function good5
> takes the false branch, At N57 of Function good5
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good5)
> takes the true branch, At N66 of Function good5
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good5)
<Defect> : N45 -> N85: [Return edge from good5 to main]
N45 -> N85: [Return edge from good5 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad5 to main}-> N86
Message  : the heap object @H(bad5::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good5, On N84 -> N46 (call good5)
> takes the true branch, At N52 of Function good5
> takes the true branch, At N57 of Function good5
> Leaving function: good5, On N45 -> N85 (Return edge from good5 to main)
> Entering function: bad5, On N85 -> N1 (call bad5)
> takes the true branch, At N7 of Function bad5
> takes the false branch, At N12 of Function bad5
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad5)
> takes the true branch, At N21 of Function bad5
<Defect> : N0 -> N86: [Return edge from bad5 to main]
N0 -> N86: [Return edge from bad5 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_5.c 97] good5 		[N70 -{call void @free(i8* %5, i8* @free)}-> N72]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_5.c 104] good5 		[N45 -{Return edge from good5 to main}-> N85]	(the heap object @H(good5::call) is not referenced any more)
	[./401_5.c 105] bad5 		[N0 -{Return edge from bad5 to main}-> N86]	(the heap object @H(bad5::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.116s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad18 to main}-> N62
Message  : the heap object @H(bad18::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good18, On N60 -> N35 (call good18)
> takes the true branch, At N43 of Function good18
> Leaving function: good18, On N34 -> N61 (Return edge from good18 to main)
> Entering function: bad18, On N61 -> N1 (call bad18)
> takes the false branch, At N9 of Function bad18
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad18)
<Defect> : N0 -> N62: [Return edge from bad18 to main]
N0 -> N62: [Return edge from bad18 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_18.c 102] bad18 		[N0 -{Return edge from bad18 to main}-> N62]	(the heap object @H(bad18::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad24 to main}-> N62
Message  : the heap object @H(bad24::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good24, On N60 -> N35 (call good24)
> takes the true branch, At N43 of Function good24
> Leaving function: good24, On N34 -> N61 (Return edge from good24 to main)
> Entering function: bad24, On N61 -> N1 (call bad24)
> takes the false branch, At N9 of Function bad24
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad24)
<Defect> : N0 -> N62: [Return edge from bad24 to main]
N0 -> N62: [Return edge from bad24 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_24.c 102] bad24 		[N0 -{Return edge from bad24 to main}-> N62]	(the heap object @H(bad24::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad34 to main}-> N64
Message  : the heap object @H(bad34::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good34, On N62 -> N36 (call good34)
> takes the true branch, At N45 of Function good34
> Leaving function: good34, On N35 -> N63 (Return edge from good34 to main)
> Entering function: bad34, On N63 -> N1 (call bad34)
> takes the false branch, At N10 of Function bad34
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad34)
<Defect> : N0 -> N64: [Return edge from bad34 to main]
N0 -> N64: [Return edge from bad34 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_34.c 101] bad34 		[N0 -{Return edge from bad34 to main}-> N64]	(the heap object @H(bad34::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.088s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad29 to main}-> N62
Message  : the heap object @H(bad29::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good29, On N60 -> N35 (call good29)
> takes the true branch, At N43 of Function good29
> Leaving function: good29, On N34 -> N61 (Return edge from good29 to main)
> Entering function: bad29, On N61 -> N1 (call bad29)
> takes the false branch, At N9 of Function bad29
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad29)
<Defect> : N0 -> N62: [Return edge from bad29 to main]
N0 -> N62: [Return edge from bad29 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_29.c 102] bad29 		[N0 -{Return edge from bad29 to main}-> N62]	(the heap object @H(bad29::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N59): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad33 to main}-> N64
Message  : the heap object @H(bad33::call) is not referenced any more
> Start from entry function: main, At N59 of Function main
> Entering function: good33, On N62 -> N36 (call good33)
> takes the true branch, At N45 of Function good33
> Leaving function: good33, On N35 -> N63 (Return edge from good33 to main)
> Entering function: bad33, On N63 -> N1 (call bad33)
> takes the false branch, At N10 of Function bad33
> Entering function: printLine, On N15 -> N76 (call printLine)
> takes the true branch, At N82 of Function printLine
> Leaving function: printLine, On N75 -> N17 (Return edge from printLine to bad33)
<Defect> : N0 -> N64: [Return edge from bad33 to main]
N0 -> N64: [Return edge from bad33 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_33.c 101] bad33 		[N0 -{Return edge from bad33 to main}-> N64]	(the heap object @H(bad33::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad3 to main}-> N62
Message  : the heap object @H(bad3::call) is not referenced any more
> Start from entry function: main, At N57 of Function main
> Entering function: good3, On N60 -> N35 (call good3)
> takes the true branch, At N43 of Function good3
> Leaving function: good3, On N34 -> N61 (Return edge from good3 to main)
> Entering function: bad3, On N61 -> N1 (call bad3)
> takes the false branch, At N9 of Function bad3
> Entering function: printLine, On N14 -> N74 (call printLine)
> takes the true branch, At N80 of Function printLine
> Leaving function: printLine, On N73 -> N16 (Return edge from printLine to bad3)
<Defect> : N0 -> N62: [Return edge from bad3 to main]
N0 -> N62: [Return edge from bad3 to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_3.c 102] bad3 		[N0 -{Return edge from bad3 to main}-> N62]	(the heap object @H(bad3::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.139s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N72
Message  : null pointer dereference
> Start from entry function: main, At N81 of Function main
> Entering function: good26, On N84 -> N46 (call good26)
> takes the false branch, At N52 of Function good26
> takes the false branch, At N66 of Function good26
<Defect> : N70 -> N72: [call void @free(i8* %5, i8* @free)]
N70 -> N72: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N45
On edge  : N45 -{Return edge from good26 to main}-> N85
Message  : the heap object @H(good26::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good26, On N84 -> N46 (call good26)
> takes the true branch, At N52 of Function good26
> takes the false branch, At N57 of Function good26
> Entering function: printLine, On N62 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N64 (Return edge from printLine to good26)
> takes the true branch, At N66 of Function good26
> Entering function: printLine, On N78 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N72 (Return edge from printLine to good26)
<Defect> : N45 -> N85: [Return edge from good26 to main]
N45 -> N85: [Return edge from good26 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad26 to main}-> N86
Message  : the heap object @H(bad26::call) is not referenced any more
> Start from entry function: main, At N81 of Function main
> Entering function: good26, On N84 -> N46 (call good26)
> takes the true branch, At N52 of Function good26
> takes the true branch, At N57 of Function good26
> Leaving function: good26, On N45 -> N85 (Return edge from good26 to main)
> Entering function: bad26, On N85 -> N1 (call bad26)
> takes the true branch, At N7 of Function bad26
> takes the false branch, At N12 of Function bad26
> Entering function: printLine, On N17 -> N98 (call printLine)
> takes the true branch, At N104 of Function printLine
> Leaving function: printLine, On N97 -> N19 (Return edge from printLine to bad26)
> takes the true branch, At N21 of Function bad26
<Defect> : N0 -> N86: [Return edge from bad26 to main]
N0 -> N86: [Return edge from bad26 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_26.c 94] good26 		[N70 -{call void @free(i8* %5, i8* @free)}-> N72]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_26.c 101] good26 		[N45 -{Return edge from good26 to main}-> N85]	(the heap object @H(good26::call) is not referenced any more)
	[./401_26.c 102] bad26 		[N0 -{Return edge from bad26 to main}-> N86]	(the heap object @H(bad26::call) is not referenced any more)

Found 3 defects in all (12 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/401/401_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N90): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N79
On edge  : N79 -{call void @free(i8* %8, i8* @free)}-> N81
Message  : null pointer dereference
> Start from entry function: main, At N90 of Function main
> Entering function: bad47, On N93 -> N1 (call bad47)
> takes the true branch, At N7 of Function bad47
> takes the true branch, At N13 of Function bad47
> Leaving function: bad47, On N0 -> N94 (Return edge from bad47 to main)
> Entering function: good47, On N94 -> N50 (call good47)
> takes the false branch, At N56 of Function good47
> takes the false branch, At N74 of Function good47
<Defect> : N79 -> N81: [call void @free(i8* %8, i8* @free)]
N79 -> N81: [call void @free(i8* %8, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad47 to main}-> N94
Message  : the heap object @H(bad47::call) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: bad47, On N93 -> N1 (call bad47)
> takes the true branch, At N7 of Function bad47
> takes the false branch, At N13 of Function bad47
> Entering function: printIntLine, On N21 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N23 (Return edge from printIntLine to bad47)
> takes the true branch, At N25 of Function bad47
<Defect> : N0 -> N94: [Return edge from bad47 to main]
N0 -> N94: [Return edge from bad47 to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N49
On edge  : N49 -{Return edge from good47 to main}-> N95
Message  : the heap object @H(good47::call) is not referenced any more
> Start from entry function: main, At N90 of Function main
> Entering function: bad47, On N93 -> N1 (call bad47)
> takes the true branch, At N7 of Function bad47
> takes the true branch, At N13 of Function bad47
> Leaving function: bad47, On N0 -> N94 (Return edge from bad47 to main)
> Entering function: good47, On N94 -> N50 (call good47)
> takes the true branch, At N56 of Function good47
> takes the false branch, At N62 of Function good47
> Entering function: printIntLine, On N70 -> N98 (call printIntLine)
> Leaving function: printIntLine, On N97 -> N72 (Return edge from printIntLine to good47)
> takes the true branch, At N74 of Function good47
> Entering function: printLine, On N87 -> N107 (call printLine)
> takes the true branch, At N113 of Function printLine
> Leaving function: printLine, On N106 -> N81 (Return edge from printLine to good47)
<Defect> : N49 -> N95: [Return edge from good47 to main]
N49 -> N95: [Return edge from good47 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_47.c 97] good47 		[N79 -{call void @free(i8* %8, i8* @free)}-> N81]	(null pointer dereference)

CWE_401(Memory Leak): 2
	[./401_47.c 104] bad47 		[N0 -{Return edge from bad47 to main}-> N94]	(the heap object @H(bad47::call) is not referenced any more)
	[./401_47.c 105] good47 		[N49 -{Return edge from good47 to main}-> N95]	(the heap object @H(good47::call) is not referenced any more)

Found 3 defects in all (18 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{store i32 5, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N55 of Function main
> Entering function: good46, On N58 -> N41 (call good46)
> takes the true branch, At N47 of Function good46
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good46)
> Leaving function: good46, On N40 -> N59 (Return edge from good46 to main)
> Entering function: bad46, On N59 -> N1 (call bad46)
<Defect> : N9 -> N10: [store i32 5, i32* %1, align 4]
N9 -> N10: [store i32 5, i32* %1, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad46 to main}-> N60
Message  : the heap object @H(bad46::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good46, On N58 -> N41 (call good46)
> takes the true branch, At N47 of Function good46
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good46)
> Leaving function: good46, On N40 -> N59 (Return edge from good46 to main)
> Entering function: bad46, On N59 -> N1 (call bad46)
> Entering function: printIntLine, On N12 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N13 (Return edge from printIntLine to bad46)
> takes the true branch, At N15 of Function bad46
> Entering function: printIntLine, On N21 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N22 (Return edge from printIntLine to bad46)
<Defect> : N0 -> N60: [Return edge from bad46 to main]
N0 -> N60: [Return edge from bad46 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_46.c 68] bad46 		[N9 -{store i32 5, i32* %1, align 4}-> N10]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./476_46.c 108] bad46 		[N0 -{Return edge from bad46 to main}-> N60]	(the heap object @H(bad46::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.093s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good21, On N46 -> N25 (call good21)
> takes the false branch, At N31 of Function good21
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good21)
> Leaving function: good21, On N24 -> N47 (Return edge from good21 to main)
> Entering function: bad21, On N47 -> N1 (call bad21)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_21.c 70] bad21 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good24, On N46 -> N25 (call good24)
> takes the false branch, At N31 of Function good24
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good24)
> Leaving function: good24, On N24 -> N47 (Return edge from good24 to main)
> Entering function: bad24, On N47 -> N1 (call bad24)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_24.c 72] bad24 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N60): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N10
On edge  : N10 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N11
Message  : null pointer dereference
> Start from entry function: main, At N60 of Function main
> Entering function: good18, On N63 -> N38 (call good18)
> takes the false branch, At N45 of Function good18
> Leaving function: good18, On N37 -> N64 (Return edge from good18 to main)
> Entering function: bad18, On N64 -> N1 (call bad18)
<Defect> : N10 -> N11: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N10 -> N11: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_18.c 67] bad18 		[N10 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N11]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i64, i64* %2, align 8}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good37, On N72 -> N37 (call good37)
> takes the false branch, At N42 of Function good37
> takes the false branch, At N47 of Function good37
> takes the false branch, At N52 of Function good37
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good37)
> Leaving function: good37, On N36 -> N73 (Return edge from good37 to main)
> Entering function: bad37, On N73 -> N1 (call bad37)
> takes the false branch, At N6 of Function bad37
> takes the true branch, At N11 of Function bad37
<Defect> : N13 -> N14: [%3 = load i64, i64* %2, align 8]
N13 -> N14: [%3 = load i64, i64* %2, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_37.c 72] bad37 		[N13 -{%3 = load i64, i64* %2, align 8}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good15, On N61 -> N37 (call good15)
> takes the false branch, At N43 of Function good15
> Leaving function: good15, On N36 -> N62 (Return edge from good15 to main)
> Entering function: bad15, On N62 -> N1 (call bad15)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_15.c 68] bad15 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good33, On N46 -> N25 (call good33)
> takes the false branch, At N31 of Function good33
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good33)
> Leaving function: good33, On N24 -> N47 (Return edge from good33 to main)
> Entering function: bad33, On N47 -> N1 (call bad33)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_33.c 70] bad33 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.15s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N38): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N38 of Function main
> Entering function: good19, On N41 -> N25 (call good19)
> Entering function: printIntLine, On N34 -> N56 (call printIntLine)
> Leaving function: printIntLine, On N55 -> N35 (Return edge from printIntLine to good19)
> Leaving function: good19, On N24 -> N42 (Return edge from good19 to main)
> Entering function: bad19, On N42 -> N1 (call bad19)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_19.c 65] bad19 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good3, On N61 -> N37 (call good3)
> takes the false branch, At N43 of Function good3
> Leaving function: good3, On N36 -> N62 (Return edge from good3 to main)
> Entering function: bad3, On N62 -> N1 (call bad3)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_3.c 67] bad3 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good4, On N61 -> N37 (call good4)
> takes the false branch, At N43 of Function good4
> Leaving function: good4, On N36 -> N62 (Return edge from good4 to main)
> Entering function: bad4, On N62 -> N1 (call bad4)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_4.c 70] bad4 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good7, On N75 -> N43 (call good7)
> takes the false branch, At N47 of Function good7
> takes the false branch, At N54 of Function good7
> Leaving function: good7, On N42 -> N76 (Return edge from good7 to main)
> Entering function: bad7, On N76 -> N1 (call bad7)
> takes the true branch, At N5 of Function bad7
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_7.c 69] bad7 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good27, On N46 -> N25 (call good27)
> takes the false branch, At N31 of Function good27
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good27)
> Leaving function: good27, On N24 -> N47 (Return edge from good27 to main)
> Entering function: bad27, On N47 -> N1 (call bad27)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_27.c 70] bad27 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%1 = load i64, i64* %0, align 8}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good38, On N72 -> N37 (call good38)
> Entering function: staticReturnsTrue, On N40 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N41 (Return edge from staticReturnsTrue to good38)
> takes the false branch, At N42 of Function good38
> Entering function: staticReturnsFalse, On N45 -> N120 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N119 -> N46 (Return edge from staticReturnsFalse to good38)
> takes the false branch, At N47 of Function good38
> takes the false branch, At N52 of Function good38
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good38)
> Leaving function: good38, On N36 -> N73 (Return edge from good38 to main)
> Entering function: bad38, On N73 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N4 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N5 (Return edge from staticReturnsTrue to bad38)
> takes the false branch, At N6 of Function bad38
> Entering function: staticReturnsTrue, On N9 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N10 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N11 of Function bad38
<Defect> : N13 -> N14: [%1 = load i64, i64* %0, align 8]
N13 -> N14: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_38.c 80] bad38 		[N13 -{%1 = load i64, i64* %0, align 8}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N45): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%2 = load i32, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N45 of Function main
> Entering function: good41, On N48 -> N31 (call good41)
> takes the true branch, At N37 of Function good41
> Entering function: printLine, On N42 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N40 (Return edge from printLine to good41)
> Leaving function: good41, On N30 -> N49 (Return edge from good41 to main)
> Entering function: bad41, On N49 -> N1 (call bad41)
> takes the true branch, At N7 of Function bad41
<Defect> : N9 -> N10: [%2 = load i32, i32* %1, align 4]
N9 -> N10: [%2 = load i32, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_41.c 66] bad41 		[N9 -{%2 = load i32, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad49 to main}-> N60
Message  : the heap object @H(bad49::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good49, On N58 -> N41 (call good49)
> takes the true branch, At N47 of Function good49
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good49)
> Leaving function: good49, On N40 -> N59 (Return edge from good49 to main)
> Entering function: bad49, On N59 -> N1 (call bad49)
> Entering function: printIntLine, On N12 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N13 (Return edge from printIntLine to bad49)
> takes the true branch, At N15 of Function bad49
> Entering function: printIntLine, On N21 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N22 (Return edge from printIntLine to bad49)
<Defect> : N0 -> N60: [Return edge from bad49 to main]
N0 -> N60: [Return edge from bad49 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{store i32 5, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N55 of Function main
> Entering function: good49, On N58 -> N41 (call good49)
> takes the true branch, At N47 of Function good49
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good49)
> Leaving function: good49, On N40 -> N59 (Return edge from good49 to main)
> Entering function: bad49, On N59 -> N1 (call bad49)
<Defect> : N9 -> N10: [store i32 5, i32* %1, align 4]
N9 -> N10: [store i32 5, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_49.c 105] bad49 		[N0 -{Return edge from bad49 to main}-> N60]	(the heap object @H(bad49::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_49.c 66] bad49 		[N9 -{store i32 5, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N36
On edge  : N36 -{Return edge from good50 to main}-> N69
Message  : the heap object @H(good50::call) is not referenced any more
> Start from entry function: main, At N65 of Function main
> Entering function: good50, On N68 -> N37 (call good50)
> takes the false branch, At N41 of Function good50
> Entering function: printIntLine, On N53 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N54 (Return edge from printIntLine to good50)
> Entering function: printIntLine, On N58 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N60 (Return edge from printIntLine to good50)
<Defect> : N36 -> N69: [Return edge from good50 to main]
N36 -> N69: [Return edge from good50 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N50
On edge  : N50 -{store i32 5, i32* %2, align 4}-> N51
Message  : null pointer dereference
> Start from entry function: main, At N65 of Function main
> Entering function: good50, On N68 -> N37 (call good50)
> takes the false branch, At N41 of Function good50
<Defect> : N50 -> N51: [store i32 5, i32* %2, align 4]
N50 -> N51: [store i32 5, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_50.c 106] good50 		[N36 -{Return edge from good50 to main}-> N69]	(the heap object @H(good50::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_50.c 95] good50 		[N50 -{store i32 5, i32* %2, align 4}-> N51]	(null pointer dereference)

Found 2 defects in all (7 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good39, On N46 -> N25 (call good39)
> takes the false branch, At N31 of Function good39
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good39)
> Leaving function: good39, On N24 -> N47 (Return edge from good39 to main)
> Entering function: bad39, On N47 -> N1 (call bad39)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_39.c 70] bad39 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good34, On N46 -> N25 (call good34)
> takes the false branch, At N31 of Function good34
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good34)
> Leaving function: good34, On N24 -> N47 (Return edge from good34 to main)
> Entering function: bad34, On N47 -> N1 (call bad34)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_34.c 73] bad34 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.14s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good20, On N46 -> N25 (call good20)
> takes the false branch, At N31 of Function good20
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good20)
> Leaving function: good20, On N24 -> N47 (Return edge from good20 to main)
> Entering function: bad20, On N47 -> N1 (call bad20)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_20.c 70] bad20 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i32, i32* %2, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good28, On N72 -> N37 (call good28)
> takes the false branch, At N42 of Function good28
> takes the false branch, At N47 of Function good28
> takes the false branch, At N52 of Function good28
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good28)
> Leaving function: good28, On N36 -> N73 (Return edge from good28 to main)
> Entering function: bad28, On N73 -> N1 (call bad28)
> takes the false branch, At N6 of Function bad28
> takes the true branch, At N11 of Function bad28
<Defect> : N13 -> N14: [%3 = load i32, i32* %2, align 4]
N13 -> N14: [%3 = load i32, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_28.c 70] bad28 		[N13 -{%3 = load i32, i32* %2, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i32, i32* %0, align 4}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good22, On N46 -> N25 (call good22)
> takes the false branch, At N31 of Function good22
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good22)
> Leaving function: good22, On N24 -> N47 (Return edge from good22 to main)
> Entering function: bad22, On N47 -> N1 (call bad22)
<Defect> : N6 -> N7: [%1 = load i32, i32* %0, align 4]
N6 -> N7: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_22.c 73] bad22 		[N6 -{%1 = load i32, i32* %0, align 4}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.136s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad47 to main}-> N74
Message  : the heap object @H(bad47::call) is not referenced any more
> Start from entry function: main, At N69 of Function main
> Entering function: good47, On N72 -> N47 (call good47)
> takes the false branch, At N51 of Function good47
> takes the true branch, At N58 of Function good47
> Entering function: printLine, On N66 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N62 (Return edge from printLine to good47)
> Leaving function: good47, On N46 -> N73 (Return edge from good47 to main)
> Entering function: bad47, On N73 -> N1 (call bad47)
> takes the true branch, At N5 of Function bad47
> Entering function: printIntLine, On N15 -> N87 (call printIntLine)
> Leaving function: printIntLine, On N86 -> N16 (Return edge from printIntLine to bad47)
> takes the true branch, At N18 of Function bad47
> Entering function: printIntLine, On N24 -> N87 (call printIntLine)
> Leaving function: printIntLine, On N86 -> N26 (Return edge from printIntLine to bad47)
<Defect> : N0 -> N74: [Return edge from bad47 to main]
N0 -> N74: [Return edge from bad47 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{store i32 5, i32* %2, align 4}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good47, On N72 -> N47 (call good47)
> takes the false branch, At N51 of Function good47
> takes the true branch, At N58 of Function good47
> Entering function: printLine, On N66 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N62 (Return edge from printLine to good47)
> Leaving function: good47, On N46 -> N73 (Return edge from good47 to main)
> Entering function: bad47, On N73 -> N1 (call bad47)
> takes the true branch, At N5 of Function bad47
<Defect> : N12 -> N13: [store i32 5, i32* %2, align 4]
N12 -> N13: [store i32 5, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_47.c 108] bad47 		[N0 -{Return edge from bad47 to main}-> N74]	(the heap object @H(bad47::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_47.c 68] bad47 		[N12 -{store i32 5, i32* %2, align 4}-> N13]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.162s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good8, On N75 -> N43 (call good8)
> Entering function: staticReturnsFalse, On N45 -> N123 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N122 -> N46 (Return edge from staticReturnsFalse to good8)
> takes the false branch, At N47 of Function good8
> takes the false branch, At N54 of Function good8
> Leaving function: good8, On N42 -> N76 (Return edge from good8 to main)
> Entering function: bad8, On N76 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N3 -> N127 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N126 -> N4 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N5 of Function bad8
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_8.c 77] bad8 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N36
On edge  : N36 -{Return edge from good48 to main}-> N69
Message  : the heap object @H(good48::call1) is not referenced any more
> Start from entry function: main, At N65 of Function main
> Entering function: good48, On N68 -> N37 (call good48)
> Entering function: staticReturnsFalse, On N39 -> N116 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N115 -> N40 (Return edge from staticReturnsFalse to good48)
> takes the false branch, At N41 of Function good48
> Entering function: printIntLine, On N53 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N54 (Return edge from printIntLine to good48)
> Entering function: printIntLine, On N58 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N60 (Return edge from printIntLine to good48)
<Defect> : N36 -> N69: [Return edge from good48 to main]
N36 -> N69: [Return edge from good48 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N50
On edge  : N50 -{store i32 5, i32* %1, align 4}-> N51
Message  : null pointer dereference
> Start from entry function: main, At N65 of Function main
> Entering function: good48, On N68 -> N37 (call good48)
> Entering function: staticReturnsFalse, On N39 -> N116 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N115 -> N40 (Return edge from staticReturnsFalse to good48)
> takes the false branch, At N41 of Function good48
<Defect> : N50 -> N51: [store i32 5, i32* %1, align 4]
N50 -> N51: [store i32 5, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_48.c 116] good48 		[N36 -{Return edge from good48 to main}-> N69]	(the heap object @H(good48::call1) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_48.c 105] good48 		[N50 -{store i32 5, i32* %1, align 4}-> N51]	(null pointer dereference)

Found 2 defects in all (8 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%1 = load i32, i32* %0, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good29, On N72 -> N37 (call good29)
> Entering function: globalReturnsTrue, On N40 -> N27 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N26 -> N41 (Return edge from globalReturnsTrue to good29)
> takes the false branch, At N42 of Function good29
> Entering function: globalReturnsFalse, On N45 -> N23 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N22 -> N46 (Return edge from globalReturnsFalse to good29)
> takes the false branch, At N47 of Function good29
> takes the false branch, At N52 of Function good29
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good29)
> Leaving function: good29, On N36 -> N73 (Return edge from good29 to main)
> Entering function: bad29, On N73 -> N1 (call bad29)
> Entering function: globalReturnsTrue, On N4 -> N27 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N26 -> N5 (Return edge from globalReturnsTrue to bad29)
> takes the false branch, At N6 of Function bad29
> Entering function: globalReturnsTrue, On N9 -> N27 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N26 -> N10 (Return edge from globalReturnsTrue to bad29)
> takes the true branch, At N11 of Function bad29
<Defect> : N13 -> N14: [%1 = load i32, i32* %0, align 4]
N13 -> N14: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_29.c 70] bad29 		[N13 -{%1 = load i32, i32* %0, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.112s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good36, On N46 -> N25 (call good36)
> takes the false branch, At N31 of Function good36
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good36)
> Leaving function: good36, On N24 -> N47 (Return edge from good36 to main)
> Entering function: bad36, On N47 -> N1 (call bad36)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_36.c 72] bad36 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good5, On N75 -> N43 (call good5)
> takes the false branch, At N47 of Function good5
> takes the false branch, At N54 of Function good5
> Leaving function: good5, On N42 -> N76 (Return edge from good5 to main)
> Entering function: bad5, On N76 -> N1 (call bad5)
> takes the true branch, At N5 of Function bad5
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_5.c 70] bad5 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N10
On edge  : N10 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N11
Message  : null pointer dereference
> Start from entry function: main, At N62 of Function main
> Entering function: good16, On N65 -> N39 (call good16)
> takes the false branch, At N46 of Function good16
> Leaving function: good16, On N38 -> N66 (Return edge from good16 to main)
> Entering function: bad16, On N66 -> N1 (call bad16)
<Defect> : N10 -> N11: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N10 -> N11: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_16.c 67] bad16 		[N10 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N11]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good9, On N61 -> N37 (call good9)
> takes the false branch, At N43 of Function good9
> Leaving function: good9, On N36 -> N62 (Return edge from good9 to main)
> Entering function: bad9, On N62 -> N1 (call bad9)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_9.c 67] bad9 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.107s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad45 to main}-> N70
Message  : the heap object @H(bad45::call) is not referenced any more
> Start from entry function: main, At N65 of Function main
> Entering function: good45, On N68 -> N43 (call good45)
> takes the false branch, At N47 of Function good45
> takes the true branch, At N54 of Function good45
> Entering function: printLine, On N62 -> N92 (call printLine)
> takes the true branch, At N98 of Function printLine
> Leaving function: printLine, On N91 -> N58 (Return edge from printLine to good45)
> Leaving function: good45, On N42 -> N69 (Return edge from good45 to main)
> Entering function: bad45, On N69 -> N1 (call bad45)
> takes the false branch, At N5 of Function bad45
> Entering function: printIntLine, On N17 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N18 (Return edge from printIntLine to bad45)
> Entering function: printIntLine, On N22 -> N83 (call printIntLine)
> Leaving function: printIntLine, On N82 -> N24 (Return edge from printIntLine to bad45)
<Defect> : N0 -> N70: [Return edge from bad45 to main]
N0 -> N70: [Return edge from bad45 to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N14
On edge  : N14 -{store i32 5, i32* %2, align 4}-> N15
Message  : null pointer dereference
> Start from entry function: main, At N65 of Function main
> Entering function: good45, On N68 -> N43 (call good45)
> takes the false branch, At N47 of Function good45
> takes the true branch, At N54 of Function good45
> Entering function: printLine, On N62 -> N92 (call printLine)
> takes the true branch, At N98 of Function printLine
> Leaving function: printLine, On N91 -> N58 (Return edge from printLine to good45)
> Leaving function: good45, On N42 -> N69 (Return edge from good45 to main)
> Entering function: bad45, On N69 -> N1 (call bad45)
> takes the false branch, At N5 of Function bad45
<Defect> : N14 -> N15: [store i32 5, i32* %2, align 4]
N14 -> N15: [store i32 5, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./476_45.c 110] bad45 		[N0 -{Return edge from bad45 to main}-> N70]	(the heap object @H(bad45::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./476_45.c 98] bad45 		[N14 -{store i32 5, i32* %2, align 4}-> N15]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.123s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good6, On N61 -> N37 (call good6)
> takes the false branch, At N43 of Function good6
> Leaving function: good6, On N36 -> N62 (Return edge from good6 to main)
> Entering function: bad6, On N62 -> N1 (call bad6)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_6.c 69] bad6 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.117s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i64, i64* %2, align 8}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good35, On N72 -> N37 (call good35)
> takes the false branch, At N42 of Function good35
> takes the false branch, At N47 of Function good35
> takes the false branch, At N52 of Function good35
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good35)
> Leaving function: good35, On N36 -> N73 (Return edge from good35 to main)
> Entering function: bad35, On N73 -> N1 (call bad35)
> takes the false branch, At N6 of Function bad35
> takes the true branch, At N11 of Function bad35
<Defect> : N13 -> N14: [%3 = load i64, i64* %2, align 8]
N13 -> N14: [%3 = load i64, i64* %2, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_35.c 73] bad35 		[N13 -{%3 = load i64, i64* %2, align 8}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.133s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N106 of Function main
> Entering function: good12, On N109 -> N61 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N64 -> N55 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N54 -> N65 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N66 of Function good12
> takes the false branch, At N84 of Function good12
> Leaving function: good12, On N60 -> N110 (Return edge from good12 to main)
> Entering function: bad12, On N110 -> N1 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N4 -> N55 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N54 -> N5 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N6 of Function bad12
<Defect> : N13 -> N14: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N13 -> N14: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_12.c 67] bad12 		[N13 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i32, i32* %2, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good23, On N72 -> N37 (call good23)
> takes the false branch, At N42 of Function good23
> takes the false branch, At N47 of Function good23
> takes the false branch, At N52 of Function good23
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good23)
> Leaving function: good23, On N36 -> N73 (Return edge from good23 to main)
> Entering function: bad23, On N73 -> N1 (call bad23)
> takes the false branch, At N6 of Function bad23
> takes the true branch, At N11 of Function bad23
<Defect> : N13 -> N14: [%3 = load i32, i32* %2, align 4]
N13 -> N14: [%3 = load i32, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_23.c 73] bad23 		[N13 -{%3 = load i32, i32* %2, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%1 = load i32, i32* %0, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good26, On N72 -> N37 (call good26)
> Entering function: staticReturnsTrue, On N40 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N41 (Return edge from staticReturnsTrue to good26)
> takes the false branch, At N42 of Function good26
> Entering function: staticReturnsFalse, On N45 -> N120 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N119 -> N46 (Return edge from staticReturnsFalse to good26)
> takes the false branch, At N47 of Function good26
> takes the false branch, At N52 of Function good26
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good26)
> Leaving function: good26, On N36 -> N73 (Return edge from good26 to main)
> Entering function: bad26, On N73 -> N1 (call bad26)
> Entering function: staticReturnsTrue, On N4 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N5 (Return edge from staticReturnsTrue to bad26)
> takes the false branch, At N6 of Function bad26
> Entering function: staticReturnsTrue, On N9 -> N124 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N123 -> N10 (Return edge from staticReturnsTrue to bad26)
> takes the true branch, At N11 of Function bad26
<Defect> : N13 -> N14: [%1 = load i32, i32* %0, align 4]
N13 -> N14: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_26.c 80] bad26 		[N13 -{%1 = load i32, i32* %0, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.127s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N98): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N25
On edge  : N25 -{%4 = load i32, i32* %3, align 4}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N98 of Function main
> Entering function: good30, On N101 -> N54 (call good30)
> Entering function: globalReturnsTrueOrFalse, On N57 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N58 (Return edge from globalReturnsTrueOrFalse to good30)
> takes the false branch, At N59 of Function good30
> Entering function: globalReturnsTrueOrFalse, On N64 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N65 (Return edge from globalReturnsTrueOrFalse to good30)
> takes the false branch, At N66 of Function good30
> takes the false branch, At N79 of Function good30
> Entering function: printLine, On N96 -> N125 (call printLine)
> takes the true branch, At N131 of Function printLine
> Leaving function: printLine, On N124 -> N87 (Return edge from printLine to good30)
> Leaving function: good30, On N53 -> N102 (Return edge from good30 to main)
> Entering function: bad30, On N102 -> N1 (call bad30)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N6 (Return edge from globalReturnsTrueOrFalse to bad30)
> takes the true branch, At N7 of Function bad30
> Entering function: globalReturnsTrueOrFalse, On N14 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N15 (Return edge from globalReturnsTrueOrFalse to bad30)
> takes the false branch, At N16 of Function bad30
> takes the true branch, At N23 of Function bad30
<Defect> : N25 -> N26: [%4 = load i32, i32* %3, align 4]
N25 -> N26: [%4 = load i32, i32* %3, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N18
On edge  : N18 -{%1 = load i32, i32* %0, align 4}-> N19
Message  : null pointer dereference
> Start from entry function: main, At N98 of Function main
> Entering function: good30, On N101 -> N54 (call good30)
> Entering function: globalReturnsTrueOrFalse, On N57 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N58 (Return edge from globalReturnsTrueOrFalse to good30)
> takes the false branch, At N59 of Function good30
> Entering function: globalReturnsTrueOrFalse, On N64 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N65 (Return edge from globalReturnsTrueOrFalse to good30)
> takes the false branch, At N66 of Function good30
> takes the false branch, At N79 of Function good30
> Entering function: printLine, On N96 -> N125 (call printLine)
> takes the true branch, At N131 of Function printLine
> Leaving function: printLine, On N124 -> N87 (Return edge from printLine to good30)
> Leaving function: good30, On N53 -> N102 (Return edge from good30 to main)
> Entering function: bad30, On N102 -> N1 (call bad30)
> Entering function: globalReturnsTrueOrFalse, On N5 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N6 (Return edge from globalReturnsTrueOrFalse to bad30)
> takes the true branch, At N7 of Function bad30
> Entering function: globalReturnsTrueOrFalse, On N14 -> N48 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N47 -> N15 (Return edge from globalReturnsTrueOrFalse to bad30)
> takes the true branch, At N16 of Function bad30
<Defect> : N18 -> N19: [%1 = load i32, i32* %0, align 4]
N18 -> N19: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 2
	[./476_30.c 85] bad30 		[N25 -{%4 = load i32, i32* %3, align 4}-> N26]	(null pointer dereference)
	[./476_30.c 78] bad30 		[N18 -{%1 = load i32, i32* %0, align 4}-> N19]	(null pointer dereference)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N55): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{store i32 5, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N55 of Function main
> Entering function: good44, On N58 -> N41 (call good44)
> takes the true branch, At N47 of Function good44
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good44)
> Leaving function: good44, On N40 -> N59 (Return edge from good44 to main)
> Entering function: bad44, On N59 -> N1 (call bad44)
<Defect> : N9 -> N10: [store i32 5, i32* %1, align 4]
N9 -> N10: [store i32 5, i32* %1, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from bad44 to main}-> N60
Message  : the heap object @H(bad44::call) is not referenced any more
> Start from entry function: main, At N55 of Function main
> Entering function: good44, On N58 -> N41 (call good44)
> takes the true branch, At N47 of Function good44
> Entering function: printLine, On N52 -> N82 (call printLine)
> takes the true branch, At N88 of Function printLine
> Leaving function: printLine, On N81 -> N50 (Return edge from printLine to good44)
> Leaving function: good44, On N40 -> N59 (Return edge from good44 to main)
> Entering function: bad44, On N59 -> N1 (call bad44)
> Entering function: printIntLine, On N12 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N13 (Return edge from printIntLine to bad44)
> takes the true branch, At N15 of Function bad44
> Entering function: printIntLine, On N21 -> N73 (call printIntLine)
> Leaving function: printIntLine, On N72 -> N22 (Return edge from printIntLine to bad44)
<Defect> : N0 -> N60: [Return edge from bad44 to main]
N0 -> N60: [Return edge from bad44 to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_44.c 69] bad44 		[N9 -{store i32 5, i32* %1, align 4}-> N10]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./476_44.c 108] bad44 		[N0 -{Return edge from bad44 to main}-> N60]	(the heap object @H(bad44::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good1, On N61 -> N37 (call good1)
> takes the false branch, At N43 of Function good1
> Leaving function: good1, On N36 -> N62 (Return edge from good1 to main)
> Entering function: bad1, On N62 -> N1 (call bad1)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_1.c 65] bad1 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLine]
 +printLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.109s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good11, On N75 -> N43 (call good11)
> Entering function: globalReturnsFalse, On N45 -> N29 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N28 -> N46 (Return edge from globalReturnsFalse to good11)
> takes the false branch, At N47 of Function good11
> takes the false branch, At N54 of Function good11
> Leaving function: good11, On N42 -> N76 (Return edge from good11 to main)
> Entering function: bad11, On N76 -> N1 (call bad11)
> Entering function: globalReturnsTrue, On N3 -> N33 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N32 -> N4 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N5 of Function bad11
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_11.c 67] bad11 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good14, On N75 -> N43 (call good14)
> takes the false branch, At N47 of Function good14
> takes the false branch, At N54 of Function good14
> Leaving function: good14, On N42 -> N76 (Return edge from good14 to main)
> Entering function: bad14, On N76 -> N1 (call bad14)
> takes the true branch, At N5 of Function bad14
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_14.c 67] bad14 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.161s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N86): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N16
On edge  : N16 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N17
Message  : null pointer dereference
> Start from entry function: main, At N86 of Function main
> Entering function: good17, On N89 -> N51 (call good17)
> takes the false branch, At N59 of Function good17
> Leaving function: good17, On N50 -> N90 (Return edge from good17 to main)
> Entering function: bad17, On N90 -> N1 (call bad17)
> takes the true branch, At N9 of Function bad17
<Defect> : N16 -> N17: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N16 -> N17: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_17.c 68] bad17 		[N16 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N17]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good13, On N61 -> N37 (call good13)
> takes the false branch, At N43 of Function good13
> Leaving function: good13, On N36 -> N62 (Return edge from good13 to main)
> Entering function: bad13, On N62 -> N1 (call bad13)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_13.c 67] bad13 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N45): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%2 = load i32, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N45 of Function main
> Entering function: good42, On N48 -> N31 (call good42)
> takes the true branch, At N37 of Function good42
> Entering function: printLine, On N42 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N40 (Return edge from printLine to good42)
> Leaving function: good42, On N30 -> N49 (Return edge from good42 to main)
> Entering function: bad42, On N49 -> N1 (call bad42)
> takes the true branch, At N7 of Function bad42
<Defect> : N9 -> N10: [%2 = load i32, i32* %1, align 4]
N9 -> N10: [%2 = load i32, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_42.c 68] bad42 		[N9 -{%2 = load i32, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N72): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N12
On edge  : N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13
Message  : null pointer dereference
> Start from entry function: main, At N72 of Function main
> Entering function: good10, On N75 -> N43 (call good10)
> takes the false branch, At N47 of Function good10
> takes the false branch, At N54 of Function good10
> Leaving function: good10, On N42 -> N76 (Return edge from good10 to main)
> Entering function: bad10, On N76 -> N1 (call bad10)
> takes the true branch, At N5 of Function bad10
<Defect> : N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0]
N12 -> N13: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_10.c 67] bad10 		[N12 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %2, i32 0, i32 0}-> N13]	(null pointer dereference)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N43 of Function main
> Entering function: good32, On N46 -> N25 (call good32)
> takes the false branch, At N31 of Function good32
> Entering function: printLine, On N41 -> N70 (call printLine)
> takes the true branch, At N76 of Function printLine
> Leaving function: printLine, On N69 -> N38 (Return edge from printLine to good32)
> Leaving function: good32, On N24 -> N47 (Return edge from good32 to main)
> Entering function: bad32, On N47 -> N1 (call bad32)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_32.c 70] bad32 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.143s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i64, i64* %2, align 8}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good40, On N72 -> N37 (call good40)
> takes the false branch, At N42 of Function good40
> takes the false branch, At N47 of Function good40
> takes the false branch, At N52 of Function good40
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good40)
> Leaving function: good40, On N36 -> N73 (Return edge from good40 to main)
> Entering function: bad40, On N73 -> N1 (call bad40)
> takes the false branch, At N6 of Function bad40
> takes the true branch, At N11 of Function bad40
<Defect> : N13 -> N14: [%3 = load i64, i64* %2, align 8]
N13 -> N14: [%3 = load i64, i64* %2, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_40.c 70] bad40 		[N13 -{%3 = load i64, i64* %2, align 8}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N38): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6
On edge  : N6 -{%1 = load i64, i64* %0, align 8}-> N7
Message  : null pointer dereference
> Start from entry function: main, At N38 of Function main
> Entering function: good31, On N41 -> N25 (call good31)
> Entering function: printLongLine, On N34 -> N80 (call printLongLine)
> Leaving function: printLongLine, On N79 -> N35 (Return edge from printLongLine to good31)
> Leaving function: good31, On N24 -> N42 (Return edge from good31 to main)
> Entering function: bad31, On N42 -> N1 (call bad31)
<Defect> : N6 -> N7: [%1 = load i64, i64* %0, align 8]
N6 -> N7: [%1 = load i64, i64* %0, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_31.c 65] bad31 		[N6 -{%1 = load i64, i64* %0, align 8}-> N7]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N58 of Function main
> Entering function: good2, On N61 -> N37 (call good2)
> takes the false branch, At N43 of Function good2
> Leaving function: good2, On N36 -> N62 (Return edge from good2 to main)
> Entering function: bad2, On N62 -> N1 (call bad2)
<Defect> : N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0]
N9 -> N10: [%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_2.c 67] bad2 		[N9 -{%intOne = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %1, i32 0, i32 0}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N45): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N9
On edge  : N9 -{%2 = load i32, i32* %1, align 4}-> N10
Message  : null pointer dereference
> Start from entry function: main, At N45 of Function main
> Entering function: good43, On N48 -> N31 (call good43)
> takes the true branch, At N37 of Function good43
> Entering function: printLine, On N42 -> N72 (call printLine)
> takes the true branch, At N78 of Function printLine
> Leaving function: printLine, On N71 -> N40 (Return edge from printLine to good43)
> Leaving function: good43, On N30 -> N49 (Return edge from good43 to main)
> Entering function: bad43, On N49 -> N1 (call bad43)
> takes the true branch, At N7 of Function bad43
<Defect> : N9 -> N10: [%2 = load i32, i32* %1, align 4]
N9 -> N10: [%2 = load i32, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_43.c 68] bad43 		[N9 -{%2 = load i32, i32* %1, align 4}-> N10]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/476/476_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N69): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N13
On edge  : N13 -{%3 = load i32, i32* %2, align 4}-> N14
Message  : null pointer dereference
> Start from entry function: main, At N69 of Function main
> Entering function: good25, On N72 -> N37 (call good25)
> takes the false branch, At N42 of Function good25
> takes the false branch, At N47 of Function good25
> takes the false branch, At N52 of Function good25
> Entering function: printLine, On N67 -> N96 (call printLine)
> takes the true branch, At N102 of Function printLine
> Leaving function: printLine, On N95 -> N60 (Return edge from printLine to good25)
> Leaving function: good25, On N36 -> N73 (Return edge from good25 to main)
> Entering function: bad25, On N73 -> N1 (call bad25)
> takes the false branch, At N6 of Function bad25
> takes the true branch, At N11 of Function bad25
<Defect> : N13 -> N14: [%3 = load i32, i32* %2, align 4]
N13 -> N14: [%3 = load i32, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_25.c 72] bad25 		[N13 -{%3 = load i32, i32* %2, align 4}-> N14]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good9, On N56 -> N35 (call good9)
> takes the true branch, At N43 of Function good9
> Leaving function: good9, On N34 -> N57 (Return edge from good9 to main)
> Entering function: bad9, On N57 -> N1 (call bad9)
> takes the false branch, At N9 of Function bad9
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good9, On N56 -> N35 (call good9)
> takes the true branch, At N43 of Function good9
> Leaving function: good9, On N34 -> N57 (Return edge from good9 to main)
> Entering function: bad9, On N57 -> N1 (call bad9)
> takes the false branch, At N9 of Function bad9
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_9.c 74] bad9 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_9.c 74] bad9 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.133s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : null pointer dereference
> Start from entry function: main, At N77 of Function main
> Entering function: good7, On N80 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the true branch, At N57 of Function good7
> Leaving function: good7, On N45 -> N81 (Return edge from good7 to main)
> Entering function: bad7, On N81 -> N1 (call bad7)
> takes the false branch, At N7 of Function bad7
> takes the true branch, At N19 of Function bad7
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good7, On N80 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the true branch, At N57 of Function good7
> Leaving function: good7, On N45 -> N81 (Return edge from good7 to main)
> Entering function: bad7, On N81 -> N1 (call bad7)
> takes the false branch, At N7 of Function bad7
> takes the true branch, At N19 of Function bad7
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good7, On N80 -> N46 (call good7)
> takes the true branch, At N52 of Function good7
> takes the true branch, At N57 of Function good7
> Leaving function: good7, On N45 -> N81 (Return edge from good7 to main)
> Entering function: bad7, On N81 -> N1 (call bad7)
> takes the false branch, At N7 of Function bad7
> takes the true branch, At N19 of Function bad7
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./415_7.c 76] bad7 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_7.c 76] bad7 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_7.c 76] bad7 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good22, On N61 -> N38 (call good22)
> takes the true branch, At N47 of Function good22
> Leaving function: good22, On N37 -> N62 (Return edge from good22 to main)
> Entering function: bad22, On N62 -> N1 (call bad22)
> takes the false branch, At N10 of Function bad22
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good22, On N61 -> N38 (call good22)
> takes the true branch, At N47 of Function good22
> Leaving function: good22, On N37 -> N62 (Return edge from good22 to main)
> Entering function: bad22, On N62 -> N1 (call bad22)
> takes the false branch, At N10 of Function bad22
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_22.c 74] bad22 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_22.c 74] bad22 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good4, On N56 -> N35 (call good4)
> takes the true branch, At N43 of Function good4
> Leaving function: good4, On N34 -> N57 (Return edge from good4 to main)
> Entering function: bad4, On N57 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good4, On N56 -> N35 (call good4)
> takes the true branch, At N43 of Function good4
> Leaving function: good4, On N34 -> N57 (Return edge from good4 to main)
> Entering function: bad4, On N57 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_4.c 77] bad4 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_4.c 77] bad4 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good41, On N61 -> N38 (call good41)
> takes the true branch, At N47 of Function good41
> Leaving function: good41, On N37 -> N62 (Return edge from good41 to main)
> Entering function: bad41, On N62 -> N1 (call bad41)
> takes the false branch, At N10 of Function bad41
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good41, On N61 -> N38 (call good41)
> takes the true branch, At N47 of Function good41
> Leaving function: good41, On N37 -> N62 (Return edge from good41 to main)
> Entering function: bad41, On N62 -> N1 (call bad41)
> takes the false branch, At N10 of Function bad41
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_41.c 69] bad41 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_41.c 69] bad41 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good21, On N61 -> N38 (call good21)
> takes the true branch, At N47 of Function good21
> Leaving function: good21, On N37 -> N62 (Return edge from good21 to main)
> Entering function: bad21, On N62 -> N1 (call bad21)
> takes the false branch, At N10 of Function bad21
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good21, On N61 -> N38 (call good21)
> takes the true branch, At N47 of Function good21
> Leaving function: good21, On N37 -> N62 (Return edge from good21 to main)
> Entering function: bad21, On N62 -> N1 (call bad21)
> takes the false branch, At N10 of Function bad21
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_21.c 69] bad21 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_21.c 69] bad21 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.13s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good20, On N85 -> N49 (call good20)
> takes the true branch, At N55 of Function good20
> takes the true branch, At N61 of Function good20
> Leaving function: good20, On N48 -> N86 (Return edge from good20 to main)
> Entering function: bad20, On N86 -> N1 (call bad20)
> takes the false branch, At N7 of Function bad20
> takes the true branch, At N21 of Function bad20
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good20, On N85 -> N49 (call good20)
> takes the true branch, At N55 of Function good20
> takes the true branch, At N61 of Function good20
> Leaving function: good20, On N48 -> N86 (Return edge from good20 to main)
> Entering function: bad20, On N86 -> N1 (call bad20)
> takes the false branch, At N7 of Function bad20
> takes the true branch, At N21 of Function bad20
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good20, On N85 -> N49 (call good20)
> takes the true branch, At N55 of Function good20
> takes the true branch, At N61 of Function good20
> Leaving function: good20, On N48 -> N86 (Return edge from good20 to main)
> Entering function: bad20, On N86 -> N1 (call bad20)
> takes the false branch, At N7 of Function bad20
> takes the true branch, At N21 of Function bad20
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_20.c 74] bad20 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_20.c 74] bad20 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_20.c 74] bad20 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good45, On N85 -> N49 (call good45)
> takes the true branch, At N55 of Function good45
> takes the true branch, At N61 of Function good45
> Leaving function: good45, On N48 -> N86 (Return edge from good45 to main)
> Entering function: bad45, On N86 -> N1 (call bad45)
> takes the false branch, At N7 of Function bad45
> takes the true branch, At N21 of Function bad45
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good45, On N85 -> N49 (call good45)
> takes the true branch, At N55 of Function good45
> takes the true branch, At N61 of Function good45
> Leaving function: good45, On N48 -> N86 (Return edge from good45 to main)
> Entering function: bad45, On N86 -> N1 (call bad45)
> takes the false branch, At N7 of Function bad45
> takes the true branch, At N21 of Function bad45
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good45, On N85 -> N49 (call good45)
> takes the true branch, At N55 of Function good45
> takes the true branch, At N61 of Function good45
> Leaving function: good45, On N48 -> N86 (Return edge from good45 to main)
> Entering function: bad45, On N86 -> N1 (call bad45)
> takes the false branch, At N7 of Function bad45
> takes the true branch, At N21 of Function bad45
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./415_45.c 77] bad45 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_45.c 77] bad45 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_45.c 77] bad45 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good39, On N61 -> N38 (call good39)
> takes the true branch, At N47 of Function good39
> Leaving function: good39, On N37 -> N62 (Return edge from good39 to main)
> Entering function: bad39, On N62 -> N1 (call bad39)
> takes the false branch, At N10 of Function bad39
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good39, On N61 -> N38 (call good39)
> takes the true branch, At N47 of Function good39
> Leaving function: good39, On N37 -> N62 (Return edge from good39 to main)
> Entering function: bad39, On N62 -> N1 (call bad39)
> takes the false branch, At N10 of Function bad39
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_39.c 74] bad39 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_39.c 74] bad39 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good26, On N61 -> N38 (call good26)
> takes the true branch, At N47 of Function good26
> Leaving function: good26, On N37 -> N62 (Return edge from good26 to main)
> Entering function: bad26, On N62 -> N1 (call bad26)
> takes the false branch, At N10 of Function bad26
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good26, On N61 -> N38 (call good26)
> takes the true branch, At N47 of Function good26
> Leaving function: good26, On N37 -> N62 (Return edge from good26 to main)
> Entering function: bad26, On N62 -> N1 (call bad26)
> takes the false branch, At N10 of Function bad26
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_26.c 76] bad26 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_26.c 76] bad26 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.199s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good17, On N85 -> N49 (call good17)
> takes the true branch, At N55 of Function good17
> takes the true branch, At N61 of Function good17
> Leaving function: good17, On N48 -> N86 (Return edge from good17 to main)
> Entering function: bad17, On N86 -> N1 (call bad17)
> takes the false branch, At N7 of Function bad17
> takes the true branch, At N21 of Function bad17
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good17, On N85 -> N49 (call good17)
> takes the true branch, At N55 of Function good17
> takes the true branch, At N61 of Function good17
> Leaving function: good17, On N48 -> N86 (Return edge from good17 to main)
> Entering function: bad17, On N86 -> N1 (call bad17)
> takes the false branch, At N7 of Function bad17
> takes the true branch, At N21 of Function bad17
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good17, On N85 -> N49 (call good17)
> takes the true branch, At N55 of Function good17
> takes the true branch, At N61 of Function good17
> Leaving function: good17, On N48 -> N86 (Return edge from good17 to main)
> Entering function: bad17, On N86 -> N1 (call bad17)
> takes the false branch, At N7 of Function bad17
> takes the true branch, At N21 of Function bad17
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_17.c 76] bad17 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_17.c 76] bad17 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_17.c 76] bad17 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good29, On N61 -> N38 (call good29)
> takes the true branch, At N47 of Function good29
> Leaving function: good29, On N37 -> N62 (Return edge from good29 to main)
> Entering function: bad29, On N62 -> N1 (call bad29)
> takes the false branch, At N10 of Function bad29
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good29, On N61 -> N38 (call good29)
> takes the true branch, At N47 of Function good29
> Leaving function: good29, On N37 -> N62 (Return edge from good29 to main)
> Entering function: bad29, On N62 -> N1 (call bad29)
> takes the false branch, At N10 of Function bad29
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_29.c 74] bad29 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_29.c 74] bad29 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : null pointer dereference
> Start from entry function: main, At N77 of Function main
> Entering function: good5, On N80 -> N46 (call good5)
> takes the true branch, At N52 of Function good5
> takes the true branch, At N57 of Function good5
> Leaving function: good5, On N45 -> N81 (Return edge from good5 to main)
> Entering function: bad5, On N81 -> N1 (call bad5)
> takes the false branch, At N7 of Function bad5
> takes the true branch, At N19 of Function bad5
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good5, On N80 -> N46 (call good5)
> takes the true branch, At N52 of Function good5
> takes the true branch, At N57 of Function good5
> Leaving function: good5, On N45 -> N81 (Return edge from good5 to main)
> Entering function: bad5, On N81 -> N1 (call bad5)
> takes the false branch, At N7 of Function bad5
> takes the true branch, At N19 of Function bad5
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good5, On N80 -> N46 (call good5)
> takes the true branch, At N52 of Function good5
> takes the true branch, At N57 of Function good5
> Leaving function: good5, On N45 -> N81 (Return edge from good5 to main)
> Entering function: bad5, On N81 -> N1 (call bad5)
> takes the false branch, At N7 of Function bad5
> takes the true branch, At N19 of Function bad5
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./415_5.c 77] bad5 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(null pointer dereference)

CWE_415(Double Free): 1
	[./415_5.c 77] bad5 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_5.c 77] bad5 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.143s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good15, On N85 -> N49 (call good15)
> takes the true branch, At N55 of Function good15
> takes the true branch, At N61 of Function good15
> Leaving function: good15, On N48 -> N86 (Return edge from good15 to main)
> Entering function: bad15, On N86 -> N1 (call bad15)
> takes the false branch, At N7 of Function bad15
> takes the true branch, At N21 of Function bad15
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good15, On N85 -> N49 (call good15)
> takes the true branch, At N55 of Function good15
> takes the true branch, At N61 of Function good15
> Leaving function: good15, On N48 -> N86 (Return edge from good15 to main)
> Entering function: bad15, On N86 -> N1 (call bad15)
> takes the false branch, At N7 of Function bad15
> takes the true branch, At N21 of Function bad15
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good15, On N85 -> N49 (call good15)
> takes the true branch, At N55 of Function good15
> takes the true branch, At N61 of Function good15
> Leaving function: good15, On N48 -> N86 (Return edge from good15 to main)
> Entering function: bad15, On N86 -> N1 (call bad15)
> takes the false branch, At N7 of Function bad15
> takes the true branch, At N21 of Function bad15
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_15.c 77] bad15 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_15.c 77] bad15 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_15.c 77] bad15 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good3, On N56 -> N35 (call good3)
> takes the true branch, At N43 of Function good3
> Leaving function: good3, On N34 -> N57 (Return edge from good3 to main)
> Entering function: bad3, On N57 -> N1 (call bad3)
> takes the false branch, At N9 of Function bad3
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good3, On N56 -> N35 (call good3)
> takes the true branch, At N43 of Function good3
> Leaving function: good3, On N34 -> N57 (Return edge from good3 to main)
> Entering function: bad3, On N57 -> N1 (call bad3)
> takes the false branch, At N9 of Function bad3
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_3.c 74] bad3 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_3.c 74] bad3 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good2, On N56 -> N35 (call good2)
> takes the true branch, At N43 of Function good2
> Leaving function: good2, On N34 -> N57 (Return edge from good2 to main)
> Entering function: bad2, On N57 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good2, On N56 -> N35 (call good2)
> takes the true branch, At N43 of Function good2
> Leaving function: good2, On N34 -> N57 (Return edge from good2 to main)
> Entering function: bad2, On N57 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_2.c 74] bad2 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_2.c 74] bad2 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.122s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good25, On N85 -> N49 (call good25)
> takes the true branch, At N55 of Function good25
> takes the true branch, At N61 of Function good25
> Leaving function: good25, On N48 -> N86 (Return edge from good25 to main)
> Entering function: bad25, On N86 -> N1 (call bad25)
> takes the false branch, At N7 of Function bad25
> takes the true branch, At N21 of Function bad25
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good25, On N85 -> N49 (call good25)
> takes the true branch, At N55 of Function good25
> takes the true branch, At N61 of Function good25
> Leaving function: good25, On N48 -> N86 (Return edge from good25 to main)
> Entering function: bad25, On N86 -> N1 (call bad25)
> takes the false branch, At N7 of Function bad25
> takes the true branch, At N21 of Function bad25
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good25, On N85 -> N49 (call good25)
> takes the true branch, At N55 of Function good25
> takes the true branch, At N61 of Function good25
> Leaving function: good25, On N48 -> N86 (Return edge from good25 to main)
> Entering function: bad25, On N86 -> N1 (call bad25)
> takes the false branch, At N7 of Function bad25
> takes the true branch, At N21 of Function bad25
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_25.c 77] bad25 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_25.c 77] bad25 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_25.c 77] bad25 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good27, On N85 -> N49 (call good27)
> takes the true branch, At N55 of Function good27
> takes the true branch, At N61 of Function good27
> Leaving function: good27, On N48 -> N86 (Return edge from good27 to main)
> Entering function: bad27, On N86 -> N1 (call bad27)
> takes the false branch, At N7 of Function bad27
> takes the true branch, At N21 of Function bad27
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good27, On N85 -> N49 (call good27)
> takes the true branch, At N55 of Function good27
> takes the true branch, At N61 of Function good27
> Leaving function: good27, On N48 -> N86 (Return edge from good27 to main)
> Entering function: bad27, On N86 -> N1 (call bad27)
> takes the false branch, At N7 of Function bad27
> takes the true branch, At N21 of Function bad27
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good27, On N85 -> N49 (call good27)
> takes the true branch, At N55 of Function good27
> takes the true branch, At N61 of Function good27
> Leaving function: good27, On N48 -> N86 (Return edge from good27 to main)
> Entering function: bad27, On N86 -> N1 (call bad27)
> takes the false branch, At N7 of Function bad27
> takes the true branch, At N21 of Function bad27
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_27.c 76] bad27 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_27.c 76] bad27 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_27.c 76] bad27 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.139s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good33, On N61 -> N38 (call good33)
> takes the true branch, At N47 of Function good33
> Leaving function: good33, On N37 -> N62 (Return edge from good33 to main)
> Entering function: bad33, On N62 -> N1 (call bad33)
> takes the false branch, At N10 of Function bad33
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good33, On N61 -> N38 (call good33)
> takes the true branch, At N47 of Function good33
> Leaving function: good33, On N37 -> N62 (Return edge from good33 to main)
> Entering function: bad33, On N62 -> N1 (call bad33)
> takes the false branch, At N10 of Function bad33
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_33.c 74] bad33 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_33.c 74] bad33 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.098s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good42, On N61 -> N38 (call good42)
> takes the true branch, At N47 of Function good42
> Leaving function: good42, On N37 -> N62 (Return edge from good42 to main)
> Entering function: bad42, On N62 -> N1 (call bad42)
> takes the false branch, At N10 of Function bad42
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good42, On N61 -> N38 (call good42)
> takes the true branch, At N47 of Function good42
> Leaving function: good42, On N37 -> N62 (Return edge from good42 to main)
> Entering function: bad42, On N62 -> N1 (call bad42)
> takes the false branch, At N10 of Function bad42
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_42.c 74] bad42 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_42.c 74] bad42 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good16, On N61 -> N38 (call good16)
> takes the true branch, At N47 of Function good16
> Leaving function: good16, On N37 -> N62 (Return edge from good16 to main)
> Entering function: bad16, On N62 -> N1 (call bad16)
> takes the false branch, At N10 of Function bad16
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good16, On N61 -> N38 (call good16)
> takes the true branch, At N47 of Function good16
> Leaving function: good16, On N37 -> N62 (Return edge from good16 to main)
> Entering function: bad16, On N62 -> N1 (call bad16)
> takes the false branch, At N10 of Function bad16
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_16.c 76] bad16 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_16.c 76] bad16 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.141s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N38 (call good32)
> takes the true branch, At N47 of Function good32
> Leaving function: good32, On N37 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N38 (call good32)
> takes the true branch, At N47 of Function good32
> Leaving function: good32, On N37 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_31.c 74] bad32 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_31.c 74] bad32 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.162s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N21
On edge  : N21 -{call void @free(i8* %2, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good8, On N80 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the true branch, At N57 of Function good8
> Leaving function: good8, On N45 -> N81 (Return edge from good8 to main)
> Entering function: bad8, On N81 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the false branch, At N7 of Function bad8
> Entering function: staticReturnsTrue, On N17 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N18 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N19 of Function bad8
<Defect> : N21 -> N23: [call void @free(i8* %2, i8* @free)]
N21 -> N23: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N21
On edge  : N21 -{call void @free(i8* %2, i8* @free)}-> N23
Message  : null pointer dereference
> Start from entry function: main, At N77 of Function main
> Entering function: good8, On N80 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the true branch, At N57 of Function good8
> Leaving function: good8, On N45 -> N81 (Return edge from good8 to main)
> Entering function: bad8, On N81 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the false branch, At N7 of Function bad8
> Entering function: staticReturnsTrue, On N17 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N18 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N19 of Function bad8
<Defect> : N21 -> N23: [call void @free(i8* %2, i8* @free)]
N21 -> N23: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{call void @free(i8* %2, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good8, On N80 -> N46 (call good8)
> Entering function: staticReturnsTrue, On N50 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N51 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N52 of Function good8
> takes the true branch, At N57 of Function good8
> Leaving function: good8, On N45 -> N81 (Return edge from good8 to main)
> Entering function: bad8, On N81 -> N1 (call bad8)
> Entering function: staticReturnsTrue, On N5 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N6 (Return edge from staticReturnsTrue to bad8)
> takes the false branch, At N7 of Function bad8
> Entering function: staticReturnsTrue, On N17 -> N132 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N131 -> N18 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N19 of Function bad8
<Defect> : N21 -> N23: [call void @free(i8* %2, i8* @free)]
N21 -> N23: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_8.c 84] bad8 		[N21 -{call void @free(i8* %2, i8* @free)}-> N23]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_8.c 84] bad8 		[N21 -{call void @free(i8* %2, i8* @free)}-> N23]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_8.c 84] bad8 		[N21 -{call void @free(i8* %2, i8* @free)}-> N23]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good19, On N61 -> N38 (call good19)
> takes the true branch, At N47 of Function good19
> Leaving function: good19, On N37 -> N62 (Return edge from good19 to main)
> Entering function: bad19, On N62 -> N1 (call bad19)
> takes the false branch, At N10 of Function bad19
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good19, On N61 -> N38 (call good19)
> takes the true branch, At N47 of Function good19
> Leaving function: good19, On N37 -> N62 (Return edge from good19 to main)
> Entering function: bad19, On N62 -> N1 (call bad19)
> takes the false branch, At N10 of Function bad19
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_19.c 74] bad19 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_19.c 74] bad19 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good1, On N56 -> N35 (call good1)
> takes the true branch, At N43 of Function good1
> Leaving function: good1, On N34 -> N57 (Return edge from good1 to main)
> Entering function: bad1, On N57 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good1, On N56 -> N35 (call good1)
> takes the true branch, At N43 of Function good1
> Leaving function: good1, On N34 -> N57 (Return edge from good1 to main)
> Entering function: bad1, On N57 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_1.c 68] bad1 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_1.c 68] bad1 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.151s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good40, On N85 -> N49 (call good40)
> takes the true branch, At N55 of Function good40
> takes the true branch, At N61 of Function good40
> Leaving function: good40, On N48 -> N86 (Return edge from good40 to main)
> Entering function: bad40, On N86 -> N1 (call bad40)
> takes the false branch, At N7 of Function bad40
> takes the true branch, At N21 of Function bad40
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good40, On N85 -> N49 (call good40)
> takes the true branch, At N55 of Function good40
> takes the true branch, At N61 of Function good40
> Leaving function: good40, On N48 -> N86 (Return edge from good40 to main)
> Entering function: bad40, On N86 -> N1 (call bad40)
> takes the false branch, At N7 of Function bad40
> takes the true branch, At N21 of Function bad40
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good40, On N85 -> N49 (call good40)
> takes the true branch, At N55 of Function good40
> takes the true branch, At N61 of Function good40
> Leaving function: good40, On N48 -> N86 (Return edge from good40 to main)
> Entering function: bad40, On N86 -> N1 (call bad40)
> takes the false branch, At N7 of Function bad40
> takes the true branch, At N21 of Function bad40
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_40.c 74] bad40 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_40.c 74] bad40 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_40.c 74] bad40 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.124s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good47, On N85 -> N49 (call good47)
> takes the true branch, At N55 of Function good47
> takes the true branch, At N61 of Function good47
> Leaving function: good47, On N48 -> N86 (Return edge from good47 to main)
> Entering function: bad47, On N86 -> N1 (call bad47)
> takes the false branch, At N7 of Function bad47
> takes the true branch, At N21 of Function bad47
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good47, On N85 -> N49 (call good47)
> takes the true branch, At N55 of Function good47
> takes the true branch, At N61 of Function good47
> Leaving function: good47, On N48 -> N86 (Return edge from good47 to main)
> Entering function: bad47, On N86 -> N1 (call bad47)
> takes the false branch, At N7 of Function bad47
> takes the true branch, At N21 of Function bad47
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good47, On N85 -> N49 (call good47)
> takes the true branch, At N55 of Function good47
> takes the true branch, At N61 of Function good47
> Leaving function: good47, On N48 -> N86 (Return edge from good47 to main)
> Entering function: bad47, On N86 -> N1 (call bad47)
> takes the false branch, At N7 of Function bad47
> takes the true branch, At N21 of Function bad47
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_47.c 76] bad47 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_47.c 76] bad47 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_47.c 76] bad47 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good36, On N61 -> N38 (call good36)
> takes the true branch, At N47 of Function good36
> Leaving function: good36, On N37 -> N62 (Return edge from good36 to main)
> Entering function: bad36, On N62 -> N1 (call bad36)
> takes the false branch, At N10 of Function bad36
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good36, On N61 -> N38 (call good36)
> takes the true branch, At N47 of Function good36
> Leaving function: good36, On N37 -> N62 (Return edge from good36 to main)
> Entering function: bad36, On N62 -> N1 (call bad36)
> takes the false branch, At N10 of Function bad36
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_36.c 76] bad36 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_36.c 76] bad36 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.147s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good35, On N85 -> N49 (call good35)
> takes the true branch, At N55 of Function good35
> takes the true branch, At N61 of Function good35
> Leaving function: good35, On N48 -> N86 (Return edge from good35 to main)
> Entering function: bad35, On N86 -> N1 (call bad35)
> takes the false branch, At N7 of Function bad35
> takes the true branch, At N21 of Function bad35
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good35, On N85 -> N49 (call good35)
> takes the true branch, At N55 of Function good35
> takes the true branch, At N61 of Function good35
> Leaving function: good35, On N48 -> N86 (Return edge from good35 to main)
> Entering function: bad35, On N86 -> N1 (call bad35)
> takes the false branch, At N7 of Function bad35
> takes the true branch, At N21 of Function bad35
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good35, On N85 -> N49 (call good35)
> takes the true branch, At N55 of Function good35
> takes the true branch, At N61 of Function good35
> Leaving function: good35, On N48 -> N86 (Return edge from good35 to main)
> Entering function: bad35, On N86 -> N1 (call bad35)
> takes the false branch, At N7 of Function bad35
> takes the true branch, At N21 of Function bad35
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_35.c 77] bad35 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_35.c 77] bad35 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_35.c 77] bad35 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.177s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good44, On N61 -> N38 (call good44)
> takes the true branch, At N47 of Function good44
> Leaving function: good44, On N37 -> N62 (Return edge from good44 to main)
> Entering function: bad44, On N62 -> N1 (call bad44)
> takes the false branch, At N10 of Function bad44
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good44, On N61 -> N38 (call good44)
> takes the true branch, At N47 of Function good44
> Leaving function: good44, On N37 -> N62 (Return edge from good44 to main)
> Entering function: bad44, On N62 -> N1 (call bad44)
> takes the false branch, At N10 of Function bad44
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_44.c 77] bad44 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_44.c 77] bad44 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good48, On N85 -> N49 (call good48)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good48)
> takes the true branch, At N55 of Function good48
> takes the true branch, At N61 of Function good48
> Leaving function: good48, On N48 -> N86 (Return edge from good48 to main)
> Entering function: bad48, On N86 -> N1 (call bad48)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad48)
> takes the false branch, At N7 of Function bad48
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N21 of Function bad48
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good48, On N85 -> N49 (call good48)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good48)
> takes the true branch, At N55 of Function good48
> takes the true branch, At N61 of Function good48
> Leaving function: good48, On N48 -> N86 (Return edge from good48 to main)
> Entering function: bad48, On N86 -> N1 (call bad48)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad48)
> takes the false branch, At N7 of Function bad48
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N21 of Function bad48
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good48, On N85 -> N49 (call good48)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good48)
> takes the true branch, At N55 of Function good48
> takes the true branch, At N61 of Function good48
> Leaving function: good48, On N48 -> N86 (Return edge from good48 to main)
> Entering function: bad48, On N86 -> N1 (call bad48)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad48)
> takes the false branch, At N7 of Function bad48
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N21 of Function bad48
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_48.c 84] bad48 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_48.c 84] bad48 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_48.c 84] bad48 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.166s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N77): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : null pointer dereference
> Start from entry function: main, At N77 of Function main
> Entering function: good10, On N80 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the true branch, At N57 of Function good10
> Leaving function: good10, On N45 -> N81 (Return edge from good10 to main)
> Entering function: bad10, On N81 -> N1 (call bad10)
> takes the false branch, At N7 of Function bad10
> takes the true branch, At N19 of Function bad10
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good10, On N80 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the true branch, At N57 of Function good10
> Leaving function: good10, On N45 -> N81 (Return edge from good10 to main)
> Entering function: bad10, On N81 -> N1 (call bad10)
> takes the false branch, At N7 of Function bad10
> takes the true branch, At N19 of Function bad10
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N21
On edge  : N21 -{call void @free(i8* %4, i8* @free)}-> N23
Message  : the memory is already freed
> Start from entry function: main, At N77 of Function main
> Entering function: good10, On N80 -> N46 (call good10)
> takes the true branch, At N52 of Function good10
> takes the true branch, At N57 of Function good10
> Leaving function: good10, On N45 -> N81 (Return edge from good10 to main)
> Entering function: bad10, On N81 -> N1 (call bad10)
> takes the false branch, At N7 of Function bad10
> takes the true branch, At N19 of Function bad10
<Defect> : N21 -> N23: [call void @free(i8* %4, i8* @free)]
N21 -> N23: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./415_10.c 74] bad10 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_10.c 74] bad10 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_10.c 74] bad10 		[N21 -{call void @free(i8* %4, i8* @free)}-> N23]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good30, On N85 -> N49 (call good30)
> takes the true branch, At N55 of Function good30
> takes the true branch, At N61 of Function good30
> Leaving function: good30, On N48 -> N86 (Return edge from good30 to main)
> Entering function: bad30, On N86 -> N1 (call bad30)
> takes the false branch, At N7 of Function bad30
> takes the true branch, At N21 of Function bad30
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good30, On N85 -> N49 (call good30)
> takes the true branch, At N55 of Function good30
> takes the true branch, At N61 of Function good30
> Leaving function: good30, On N48 -> N86 (Return edge from good30 to main)
> Entering function: bad30, On N86 -> N1 (call bad30)
> takes the false branch, At N7 of Function bad30
> takes the true branch, At N21 of Function bad30
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good30, On N85 -> N49 (call good30)
> takes the true branch, At N55 of Function good30
> takes the true branch, At N61 of Function good30
> Leaving function: good30, On N48 -> N86 (Return edge from good30 to main)
> Entering function: bad30, On N86 -> N1 (call bad30)
> takes the false branch, At N7 of Function bad30
> takes the true branch, At N21 of Function bad30
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_30.c 74] bad30 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_30.c 74] bad30 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_30.c 74] bad30 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.1s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good13, On N61 -> N38 (call good13)
> takes the true branch, At N47 of Function good13
> Leaving function: good13, On N37 -> N62 (Return edge from good13 to main)
> Entering function: bad13, On N62 -> N1 (call bad13)
> takes the false branch, At N10 of Function bad13
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good13, On N61 -> N38 (call good13)
> takes the true branch, At N47 of Function good13
> Leaving function: good13, On N37 -> N62 (Return edge from good13 to main)
> Entering function: bad13, On N62 -> N1 (call bad13)
> takes the false branch, At N10 of Function bad13
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_13.c 74] bad13 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_13.c 74] bad13 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.105s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good49, On N61 -> N38 (call good49)
> takes the true branch, At N47 of Function good49
> Leaving function: good49, On N37 -> N62 (Return edge from good49 to main)
> Entering function: bad49, On N62 -> N1 (call bad49)
> takes the false branch, At N10 of Function bad49
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good49, On N61 -> N38 (call good49)
> takes the true branch, At N47 of Function good49
> Leaving function: good49, On N37 -> N62 (Return edge from good49 to main)
> Entering function: bad49, On N62 -> N1 (call bad49)
> takes the false branch, At N10 of Function bad49
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_49.c 74] bad49 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_49.c 74] bad49 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.095s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good34, On N61 -> N38 (call good34)
> takes the true branch, At N47 of Function good34
> Leaving function: good34, On N37 -> N62 (Return edge from good34 to main)
> Entering function: bad34, On N62 -> N1 (call bad34)
> takes the false branch, At N10 of Function bad34
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good34, On N61 -> N38 (call good34)
> takes the true branch, At N47 of Function good34
> Leaving function: good34, On N37 -> N62 (Return edge from good34 to main)
> Entering function: bad34, On N62 -> N1 (call bad34)
> takes the false branch, At N10 of Function bad34
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_34.c 77] bad34 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_34.c 77] bad34 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.148s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good38, On N85 -> N49 (call good38)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N55 of Function good38
> takes the true branch, At N61 of Function good38
> Leaving function: good38, On N48 -> N86 (Return edge from good38 to main)
> Entering function: bad38, On N86 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad38)
> takes the false branch, At N7 of Function bad38
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N21 of Function bad38
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good38, On N85 -> N49 (call good38)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N55 of Function good38
> takes the true branch, At N61 of Function good38
> Leaving function: good38, On N48 -> N86 (Return edge from good38 to main)
> Entering function: bad38, On N86 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad38)
> takes the false branch, At N7 of Function bad38
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N21 of Function bad38
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good38, On N85 -> N49 (call good38)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N55 of Function good38
> takes the true branch, At N61 of Function good38
> Leaving function: good38, On N48 -> N86 (Return edge from good38 to main)
> Entering function: bad38, On N86 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad38)
> takes the false branch, At N7 of Function bad38
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N21 of Function bad38
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./415_38.c 84] bad38 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(null pointer dereference)

CWE_415(Double Free): 1
	[./415_38.c 84] bad38 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_38.c 84] bad38 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.123s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good28, On N85 -> N49 (call good28)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good28)
> takes the true branch, At N55 of Function good28
> takes the true branch, At N61 of Function good28
> Leaving function: good28, On N48 -> N86 (Return edge from good28 to main)
> Entering function: bad28, On N86 -> N1 (call bad28)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad28)
> takes the false branch, At N7 of Function bad28
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N21 of Function bad28
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good28, On N85 -> N49 (call good28)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good28)
> takes the true branch, At N55 of Function good28
> takes the true branch, At N61 of Function good28
> Leaving function: good28, On N48 -> N86 (Return edge from good28 to main)
> Entering function: bad28, On N86 -> N1 (call bad28)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad28)
> takes the false branch, At N7 of Function bad28
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N21 of Function bad28
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good28, On N85 -> N49 (call good28)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good28)
> takes the true branch, At N55 of Function good28
> takes the true branch, At N61 of Function good28
> Leaving function: good28, On N48 -> N86 (Return edge from good28 to main)
> Entering function: bad28, On N86 -> N1 (call bad28)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad28)
> takes the false branch, At N7 of Function bad28
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N21 of Function bad28
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./415_28.c 84] bad28 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(null pointer dereference)

CWE_415(Double Free): 1
	[./415_28.c 84] bad28 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_28.c 84] bad28 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good18, On N85 -> N49 (call good18)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good18)
> takes the true branch, At N55 of Function good18
> takes the true branch, At N61 of Function good18
> Leaving function: good18, On N48 -> N86 (Return edge from good18 to main)
> Entering function: bad18, On N86 -> N1 (call bad18)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad18)
> takes the false branch, At N7 of Function bad18
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N21 of Function bad18
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good18, On N85 -> N49 (call good18)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good18)
> takes the true branch, At N55 of Function good18
> takes the true branch, At N61 of Function good18
> Leaving function: good18, On N48 -> N86 (Return edge from good18 to main)
> Entering function: bad18, On N86 -> N1 (call bad18)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad18)
> takes the false branch, At N7 of Function bad18
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N21 of Function bad18
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %5, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good18, On N85 -> N49 (call good18)
> Entering function: staticReturnsTrue, On N53 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N54 (Return edge from staticReturnsTrue to good18)
> takes the true branch, At N55 of Function good18
> takes the true branch, At N61 of Function good18
> Leaving function: good18, On N48 -> N86 (Return edge from good18 to main)
> Entering function: bad18, On N86 -> N1 (call bad18)
> Entering function: staticReturnsTrue, On N5 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N6 (Return edge from staticReturnsTrue to bad18)
> takes the false branch, At N7 of Function bad18
> Entering function: staticReturnsTrue, On N19 -> N137 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N136 -> N20 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N21 of Function bad18
<Defect> : N24 -> N26: [call void @free(i8* %5, i8* @free)]
N24 -> N26: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./415_18.c 84] bad18 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_18.c 84] bad18 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_18.c 84] bad18 		[N24 -{call void @free(i8* %5, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good50, On N85 -> N49 (call good50)
> takes the true branch, At N55 of Function good50
> takes the true branch, At N61 of Function good50
> Leaving function: good50, On N48 -> N86 (Return edge from good50 to main)
> Entering function: bad50, On N86 -> N1 (call bad50)
> takes the false branch, At N7 of Function bad50
> takes the true branch, At N21 of Function bad50
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good50, On N85 -> N49 (call good50)
> takes the true branch, At N55 of Function good50
> takes the true branch, At N61 of Function good50
> Leaving function: good50, On N48 -> N86 (Return edge from good50 to main)
> Entering function: bad50, On N86 -> N1 (call bad50)
> takes the false branch, At N7 of Function bad50
> takes the true branch, At N21 of Function bad50
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good50, On N85 -> N49 (call good50)
> takes the true branch, At N55 of Function good50
> takes the true branch, At N61 of Function good50
> Leaving function: good50, On N48 -> N86 (Return edge from good50 to main)
> Entering function: bad50, On N86 -> N1 (call bad50)
> takes the false branch, At N7 of Function bad50
> takes the true branch, At N21 of Function bad50
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_50.c 74] bad50 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_50.c 74] bad50 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_50.c 74] bad50 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good23, On N61 -> N38 (call good23)
> takes the true branch, At N47 of Function good23
> Leaving function: good23, On N37 -> N62 (Return edge from good23 to main)
> Entering function: bad23, On N62 -> N1 (call bad23)
> takes the false branch, At N10 of Function bad23
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good23, On N61 -> N38 (call good23)
> takes the true branch, At N47 of Function good23
> Leaving function: good23, On N37 -> N62 (Return edge from good23 to main)
> Entering function: bad23, On N62 -> N1 (call bad23)
> takes the false branch, At N10 of Function bad23
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_23.c 74] bad23 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_23.c 74] bad23 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good46, On N61 -> N38 (call good46)
> takes the true branch, At N47 of Function good46
> Leaving function: good46, On N37 -> N62 (Return edge from good46 to main)
> Entering function: bad46, On N62 -> N1 (call bad46)
> takes the false branch, At N10 of Function bad46
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good46, On N61 -> N38 (call good46)
> takes the true branch, At N47 of Function good46
> Leaving function: good46, On N37 -> N62 (Return edge from good46 to main)
> Entering function: bad46, On N62 -> N1 (call bad46)
> takes the false branch, At N10 of Function bad46
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_46.c 76] bad46 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_46.c 76] bad46 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good12, On N61 -> N38 (call good12)
> takes the true branch, At N47 of Function good12
> Leaving function: good12, On N37 -> N62 (Return edge from good12 to main)
> Entering function: bad12, On N62 -> N1 (call bad12)
> takes the false branch, At N10 of Function bad12
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good12, On N61 -> N38 (call good12)
> takes the true branch, At N47 of Function good12
> Leaving function: good12, On N37 -> N62 (Return edge from good12 to main)
> Entering function: bad12, On N62 -> N1 (call bad12)
> takes the false branch, At N10 of Function bad12
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_12.c 74] bad12 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_12.c 74] bad12 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good14, On N61 -> N38 (call good14)
> takes the true branch, At N47 of Function good14
> Leaving function: good14, On N37 -> N62 (Return edge from good14 to main)
> Entering function: bad14, On N62 -> N1 (call bad14)
> takes the false branch, At N10 of Function bad14
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good14, On N61 -> N38 (call good14)
> takes the true branch, At N47 of Function good14
> Leaving function: good14, On N37 -> N62 (Return edge from good14 to main)
> Entering function: bad14, On N62 -> N1 (call bad14)
> takes the false branch, At N10 of Function bad14
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_14.c 77] bad14 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_14.c 77] bad14 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.145s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good43, On N61 -> N38 (call good43)
> takes the true branch, At N47 of Function good43
> Leaving function: good43, On N37 -> N62 (Return edge from good43 to main)
> Entering function: bad43, On N62 -> N1 (call bad43)
> takes the false branch, At N10 of Function bad43
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good43, On N61 -> N38 (call good43)
> takes the true branch, At N47 of Function good43
> Leaving function: good43, On N37 -> N62 (Return edge from good43 to main)
> Entering function: bad43, On N62 -> N1 (call bad43)
> takes the false branch, At N10 of Function bad43
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_43.c 74] bad43 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_43.c 74] bad43 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.11s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good24, On N61 -> N38 (call good24)
> takes the true branch, At N47 of Function good24
> Leaving function: good24, On N37 -> N62 (Return edge from good24 to main)
> Entering function: bad24, On N62 -> N1 (call bad24)
> takes the false branch, At N10 of Function bad24
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good24, On N61 -> N38 (call good24)
> takes the true branch, At N47 of Function good24
> Leaving function: good24, On N37 -> N62 (Return edge from good24 to main)
> Entering function: bad24, On N62 -> N1 (call bad24)
> takes the false branch, At N10 of Function bad24
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_24.c 77] bad24 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_24.c 77] bad24 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.115s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N38 (call good32)
> takes the true branch, At N47 of Function good32
> Leaving function: good32, On N37 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good32, On N61 -> N38 (call good32)
> takes the true branch, At N47 of Function good32
> Leaving function: good32, On N37 -> N62 (Return edge from good32 to main)
> Entering function: bad32, On N62 -> N1 (call bad32)
> takes the false branch, At N10 of Function bad32
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_32.c 74] bad32 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_32.c 74] bad32 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N82): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good37, On N85 -> N49 (call good37)
> takes the true branch, At N55 of Function good37
> takes the true branch, At N61 of Function good37
> Leaving function: good37, On N48 -> N86 (Return edge from good37 to main)
> Entering function: bad37, On N86 -> N1 (call bad37)
> takes the false branch, At N7 of Function bad37
> takes the true branch, At N21 of Function bad37
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N82 of Function main
> Entering function: good37, On N85 -> N49 (call good37)
> takes the true branch, At N55 of Function good37
> takes the true branch, At N61 of Function good37
> Leaving function: good37, On N48 -> N86 (Return edge from good37 to main)
> Entering function: bad37, On N86 -> N1 (call bad37)
> takes the false branch, At N7 of Function bad37
> takes the true branch, At N21 of Function bad37
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %7, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N82 of Function main
> Entering function: good37, On N85 -> N49 (call good37)
> takes the true branch, At N55 of Function good37
> takes the true branch, At N61 of Function good37
> Leaving function: good37, On N48 -> N86 (Return edge from good37 to main)
> Entering function: bad37, On N86 -> N1 (call bad37)
> takes the false branch, At N7 of Function bad37
> takes the true branch, At N21 of Function bad37
<Defect> : N24 -> N26: [call void @free(i8* %7, i8* @free)]
N24 -> N26: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_37.c 76] bad37 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_37.c 76] bad37 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_37.c 76] bad37 		[N24 -{call void @free(i8* %7, i8* @free)}-> N26]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.162s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N58): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good11, On N61 -> N38 (call good11)
> takes the true branch, At N47 of Function good11
> Leaving function: good11, On N37 -> N62 (Return edge from good11 to main)
> Entering function: bad11, On N62 -> N1 (call bad11)
> takes the false branch, At N10 of Function bad11
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N17
On edge  : N17 -{call void @free(i8* %5, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N58 of Function main
> Entering function: good11, On N61 -> N38 (call good11)
> takes the true branch, At N47 of Function good11
> Leaving function: good11, On N37 -> N62 (Return edge from good11 to main)
> Entering function: bad11, On N62 -> N1 (call bad11)
> takes the false branch, At N10 of Function bad11
<Defect> : N17 -> N19: [call void @free(i8* %5, i8* @free)]
N17 -> N19: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_11.c 69] bad11 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_11.c 69] bad11 		[N17 -{call void @free(i8* %5, i8* @free)}-> N19]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/415/415_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good6, On N56 -> N35 (call good6)
> takes the true branch, At N43 of Function good6
> Leaving function: good6, On N34 -> N57 (Return edge from good6 to main)
> Entering function: bad6, On N57 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good6, On N56 -> N35 (call good6)
> takes the true branch, At N43 of Function good6
> Leaving function: good6, On N34 -> N57 (Return edge from good6 to main)
> Entering function: bad6, On N57 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_6.c 76] bad6 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_6.c 76] bad6 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.123s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good2, On N66 -> N40 (call good2)
> takes the true branch, At N48 of Function good2
> Leaving function: good2, On N39 -> N67 (Return edge from good2 to main)
> Entering function: bad2, On N67 -> N1 (call bad2)
> takes the false branch, At N9 of Function bad2
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_2.c 76] bad2 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_46.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.144s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N101): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N36
On edge  : N36 -{%9 = load i64, i64* %arrayidx3, align 8}-> N37
Message  : the memory is already freed
> Start from entry function: main, At N101 of Function main
> Entering function: good46, On N104 -> N60 (call good46)
> takes the true branch, At N71 of Function good46
> Leaving function: good46, On N59 -> N105 (Return edge from good46 to main)
> Entering function: bad46, On N105 -> N1 (call bad46)
> takes the false branch, At N12 of Function bad46
> takes the false branch, At N19 of Function bad46
<Defect> : N36 -> N37: [%9 = load i64, i64* %arrayidx3, align 8]
N36 -> N37: [%9 = load i64, i64* %arrayidx3, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_46.c 82] bad46 		[N36 -{%9 = load i64, i64* %arrayidx3, align 8}-> N37]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_32.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.153s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good32, On N194 -> N32 (call good32)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good32)
> takes the true branch, At N39 of Function good32
> Leaving function: good32, On N31 -> N195 (Return edge from good32 to main)
> Entering function: bad32, On N195 -> N1 (call bad32)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the true branch, At N76 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad32)
> takes the false branch, At N8 of Function bad32
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_32.c 116] bad32 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_28.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.15s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N130): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N46
On edge  : N46 -{call printStructLine}-> N181
Message  : the memory is already freed
> Start from entry function: main, At N130 of Function main
> Entering function: good28, On N133 -> N73 (call good28)
> takes the true branch, At N80 of Function good28
> takes the true branch, At N86 of Function good28
> Leaving function: good28, On N72 -> N134 (Return edge from good28 to main)
> Entering function: bad28, On N134 -> N1 (call bad28)
> takes the false branch, At N8 of Function bad28
> takes the true branch, At N43 of Function bad28
<Defect> : N46 -> N181: [call printStructLine]
N46 -> N181: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N45
On edge  : N45 -{%arrayidx8 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %12, i64 0}-> N46
Message  : null pointer dereference
> Start from entry function: main, At N130 of Function main
> Entering function: good28, On N133 -> N73 (call good28)
> takes the true branch, At N80 of Function good28
> takes the true branch, At N86 of Function good28
> Leaving function: good28, On N72 -> N134 (Return edge from good28 to main)
> Entering function: bad28, On N134 -> N1 (call bad28)
> takes the false branch, At N8 of Function bad28
> takes the true branch, At N43 of Function bad28
<Defect> : N45 -> N46: [%arrayidx8 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %12, i64 0]
N45 -> N46: [%arrayidx8 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %12, i64 0] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_28.c 88] bad28 		[N46 -{call printStructLine}-> N181]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./416_28.c 88] bad28 		[N45 -{%arrayidx8 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %12, i64 0}-> N46]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.173s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N99): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N99 of Function main
> Entering function: good13, On N102 -> N57 (call good13)
> takes the true branch, At N67 of Function good13
> Leaving function: good13, On N56 -> N103 (Return edge from good13 to main)
> Entering function: bad13, On N103 -> N1 (call bad13)
> takes the false branch, At N11 of Function bad13
> takes the false branch, At N18 of Function bad13
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_13.c 76] bad13 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_23.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.156s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good23, On N109 -> N62 (call good23)
> takes the true branch, At N72 of Function good23
> Leaving function: good23, On N61 -> N110 (Return edge from good23 to main)
> Entering function: bad23, On N110 -> N1 (call bad23)
> takes the false branch, At N11 of Function bad23
> takes the false branch, At N18 of Function bad23
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_23.c 86] bad23 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_25.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.162s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good25, On N109 -> N62 (call good25)
> takes the true branch, At N72 of Function good25
> Leaving function: good25, On N61 -> N110 (Return edge from good25 to main)
> Entering function: bad25, On N110 -> N1 (call bad25)
> takes the false branch, At N11 of Function bad25
> takes the false branch, At N18 of Function bad25
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_25.c 89] bad25 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N87): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N26
On edge  : N26 -{call printLine}-> N114
Message  : the memory is already freed
> Start from entry function: main, At N87 of Function main
> Entering function: good5, On N90 -> N51 (call good5)
> takes the true branch, At N57 of Function good5
> takes the true branch, At N62 of Function good5
> Leaving function: good5, On N50 -> N91 (Return edge from good5 to main)
> Entering function: bad5, On N91 -> N1 (call bad5)
> takes the false branch, At N7 of Function bad5
> takes the true branch, At N24 of Function bad5
<Defect> : N26 -> N114: [call printLine]
N26 -> N114: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_5.c 79] bad5 		[N26 -{call printLine}-> N114]	(the memory is already freed)

Found 1 defects in all (1 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.156s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N97): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N32
On edge  : N32 -{%9 = load i32, i32* %arrayidx2, align 4}-> N33
Message  : the memory is already freed
> Start from entry function: main, At N97 of Function main
> Entering function: good7, On N100 -> N56 (call good7)
> takes the false branch, At N66 of Function good7
> Leaving function: good7, On N55 -> N101 (Return edge from good7 to main)
> Entering function: bad7, On N101 -> N1 (call bad7)
> takes the true branch, At N11 of Function bad7
> takes the false branch, At N17 of Function bad7
<Defect> : N32 -> N33: [%9 = load i32, i32* %arrayidx2, align 4]
N32 -> N33: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_7.c 75] bad7 		[N32 -{%9 = load i32, i32* %arrayidx2, align 4}-> N33]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_19.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.166s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N119): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N40
On edge  : N40 -{%11 = load i64, i64* %arrayidx7, align 8}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N119 of Function main
> Entering function: good19, On N122 -> N68 (call good19)
> takes the true branch, At N75 of Function good19
> takes the true branch, At N81 of Function good19
> Leaving function: good19, On N67 -> N123 (Return edge from good19 to main)
> Entering function: bad19, On N123 -> N1 (call bad19)
> takes the false branch, At N8 of Function bad19
> takes the true branch, At N37 of Function bad19
<Defect> : N40 -> N41: [%11 = load i64, i64* %arrayidx7, align 8]
N40 -> N41: [%11 = load i64, i64* %arrayidx7, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N39
On edge  : N39 -{%arrayidx7 = getelementptr inbounds i64, i64* %10, i64 0}-> N40
Message  : null pointer dereference
> Start from entry function: main, At N119 of Function main
> Entering function: good19, On N122 -> N68 (call good19)
> takes the true branch, At N75 of Function good19
> takes the true branch, At N81 of Function good19
> Leaving function: good19, On N67 -> N123 (Return edge from good19 to main)
> Entering function: bad19, On N123 -> N1 (call bad19)
> takes the false branch, At N8 of Function bad19
> takes the true branch, At N37 of Function bad19
<Defect> : N39 -> N40: [%arrayidx7 = getelementptr inbounds i64, i64* %10, i64 0]
N39 -> N40: [%arrayidx7 = getelementptr inbounds i64, i64* %10, i64 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N40
On edge  : N40 -{%11 = load i64, i64* %arrayidx7, align 8}-> N41
Message  : null pointer dereference
> Start from entry function: main, At N119 of Function main
> Entering function: good19, On N122 -> N68 (call good19)
> takes the true branch, At N75 of Function good19
> takes the true branch, At N81 of Function good19
> Leaving function: good19, On N67 -> N123 (Return edge from good19 to main)
> Entering function: bad19, On N123 -> N1 (call bad19)
> takes the false branch, At N8 of Function bad19
> takes the true branch, At N37 of Function bad19
<Defect> : N40 -> N41: [%11 = load i64, i64* %arrayidx7, align 8]
N40 -> N41: [%11 = load i64, i64* %arrayidx7, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_19.c 83] bad19 		[N40 -{%11 = load i64, i64* %arrayidx7, align 8}-> N41]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 2
	[./416_19.c 83] bad19 		[N39 -{%arrayidx7 = getelementptr inbounds i64, i64* %10, i64 0}-> N40]	(null pointer dereference)
	[./416_19.c 83] bad19 		[N40 -{%11 = load i64, i64* %arrayidx7, align 8}-> N41]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_24.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.164s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good24, On N109 -> N62 (call good24)
> takes the true branch, At N72 of Function good24
> Leaving function: good24, On N61 -> N110 (Return edge from good24 to main)
> Entering function: bad24, On N110 -> N1 (call bad24)
> takes the false branch, At N11 of Function bad24
> takes the false branch, At N18 of Function bad24
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_24.c 86] bad24 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_33.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.159s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good33, On N194 -> N32 (call good33)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good33)
> takes the true branch, At N39 of Function good33
> Leaving function: good33, On N31 -> N195 (Return edge from good33 to main)
> Entering function: bad33, On N195 -> N1 (call bad33)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the true branch, At N76 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad33)
> takes the false branch, At N8 of Function bad33
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_33.c 116] bad33 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N39
On edge  : N39 -{Return edge from good1 to main}-> N67
Message  : the heap object @H(good1::call) is not referenced any more
> Start from entry function: main, At N63 of Function main
> Entering function: good1, On N66 -> N40 (call good1)
> takes the false branch, At N48 of Function good1
> Entering function: printLine, On N56 -> N90 (call printLine)
> takes the true branch, At N96 of Function printLine
> Leaving function: printLine, On N89 -> N58 (Return edge from printLine to good1)
<Defect> : N39 -> N67: [Return edge from good1 to main]
N39 -> N67: [Return edge from good1 to main] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good1, On N66 -> N40 (call good1)
> takes the true branch, At N48 of Function good1
> Leaving function: good1, On N39 -> N67 (Return edge from good1 to main)
> Entering function: bad1, On N67 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./416_1.c 105] good1 		[N39 -{Return edge from good1 to main}-> N67]	(the heap object @H(good1::call) is not referenced any more)

CWE_416(Use After Free): 1
	[./416_1.c 75] bad1 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 2 defects in all (5 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_21.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.157s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good21, On N98 -> N57 (call good21)
> takes the true branch, At N67 of Function good21
> Leaving function: good21, On N56 -> N99 (Return edge from good21 to main)
> Entering function: bad21, On N99 -> N1 (call bad21)
> takes the false branch, At N11 of Function bad21
> takes the false branch, At N18 of Function bad21
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_21.c 81] bad21 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_48.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.146s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N98): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N35
On edge  : N35 -{%9 = load i64, i64* %arrayidx2, align 8}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N98 of Function main
> Entering function: bad48, On N101 -> N1 (call bad48)
> takes the false branch, At N12 of Function bad48
> takes the false branch, At N19 of Function bad48
<Defect> : N35 -> N36: [%9 = load i64, i64* %arrayidx2, align 8]
N35 -> N36: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_48.c 80] bad48 		[N35 -{%9 = load i64, i64* %arrayidx2, align 8}-> N36]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_29.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
13 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.177s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N130): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N46
On edge  : N46 -{call printStructLine}-> N181
Message  : the memory is already freed
> Start from entry function: main, At N130 of Function main
> Entering function: good29, On N133 -> N73 (call good29)
> Entering function: staticReturnsTrue, On N78 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N79 (Return edge from staticReturnsTrue to good29)
> takes the true branch, At N80 of Function good29
> takes the true branch, At N86 of Function good29
> Leaving function: good29, On N72 -> N134 (Return edge from good29 to main)
> Entering function: bad29, On N134 -> N1 (call bad29)
> Entering function: staticReturnsTrue, On N6 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N7 (Return edge from staticReturnsTrue to bad29)
> takes the false branch, At N8 of Function bad29
> Entering function: staticReturnsTrue, On N41 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N42 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N43 of Function bad29
<Defect> : N46 -> N181: [call printStructLine]
N46 -> N181: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N45
On edge  : N45 -{%arrayidx9 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %10, i64 0}-> N46
Message  : null pointer dereference
> Start from entry function: main, At N130 of Function main
> Entering function: good29, On N133 -> N73 (call good29)
> Entering function: staticReturnsTrue, On N78 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N79 (Return edge from staticReturnsTrue to good29)
> takes the true branch, At N80 of Function good29
> takes the true branch, At N86 of Function good29
> Leaving function: good29, On N72 -> N134 (Return edge from good29 to main)
> Entering function: bad29, On N134 -> N1 (call bad29)
> Entering function: staticReturnsTrue, On N6 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N7 (Return edge from staticReturnsTrue to bad29)
> takes the false branch, At N8 of Function bad29
> Entering function: staticReturnsTrue, On N41 -> N199 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N198 -> N42 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N43 of Function bad29
<Defect> : N45 -> N46: [%arrayidx9 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %10, i64 0]
N45 -> N46: [%arrayidx9 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %10, i64 0] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_29.c 97] bad29 		[N46 -{call printStructLine}-> N181]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./416_29.c 97] bad29 		[N45 -{%arrayidx9 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %10, i64 0}-> N46]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_39.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.168s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good39, On N194 -> N32 (call good39)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good39)
> takes the true branch, At N39 of Function good39
> Leaving function: good39, On N31 -> N195 (Return edge from good39 to main)
> Entering function: bad39, On N195 -> N1 (call bad39)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the true branch, At N76 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad39)
> takes the false branch, At N8 of Function bad39
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_39.c 116] bad39 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_36.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.202s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good36, On N194 -> N32 (call good36)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good36)
> takes the true branch, At N39 of Function good36
> Leaving function: good36, On N31 -> N195 (Return edge from good36 to main)
> Entering function: bad36, On N195 -> N1 (call bad36)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the true branch, At N76 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad36)
> takes the false branch, At N8 of Function bad36
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_36.c 121] bad36 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_37.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.173s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N203): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call printLine}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N203 of Function main
> Entering function: good37, On N206 -> N37 (call good37)
> takes the false branch, At N41 of Function good37
> Entering function: helperGood, On N59 -> N134 (call helperGood)
> takes the true branch, At N149 of Function helperGood
> takes the true branch, At N159 of Function helperGood
> Leaving function: helperGood, On N133 -> N46 (Return edge from helperGood to good37)
> takes the true branch, At N49 of Function good37
> Leaving function: good37, On N36 -> N207 (Return edge from good37 to main)
> Entering function: bad37, On N207 -> N1 (call bad37)
> takes the true branch, At N5 of Function bad37
> Entering function: helperBad, On N18 -> N63 (call helperBad)
> takes the true branch, At N78 of Function helperBad
> takes the true branch, At N88 of Function helperBad
> Leaving function: helperBad, On N62 -> N8 (Return edge from helperBad to bad37)
> takes the false branch, At N11 of Function bad37
<Defect> : N14 -> N230: [call printLine]
N14 -> N230: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_37.c 121] bad37 		[N14 -{call printLine}-> N230]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_22.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.179s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N109): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N160
Message  : the memory is already freed
> Start from entry function: main, At N109 of Function main
> Entering function: good22, On N112 -> N62 (call good22)
> takes the true branch, At N72 of Function good22
> Leaving function: good22, On N61 -> N113 (Return edge from good22 to main)
> Entering function: bad22, On N113 -> N1 (call bad22)
> takes the false branch, At N11 of Function bad22
> takes the false branch, At N18 of Function bad22
<Defect> : N39 -> N160: [call printStructLine]
N39 -> N160: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_22.c 81] bad22 		[N39 -{call printStructLine}-> N160]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_34.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.172s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good34, On N194 -> N32 (call good34)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good34)
> takes the true branch, At N39 of Function good34
> Leaving function: good34, On N31 -> N195 (Return edge from good34 to main)
> Entering function: bad34, On N195 -> N1 (call bad34)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the true branch, At N76 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad34)
> takes the false branch, At N8 of Function bad34
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_34.c 122] bad34 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_41.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.15s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: bad41, On N98 -> N1 (call bad41)
> takes the false branch, At N11 of Function bad41
> takes the false branch, At N18 of Function bad41
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_41.c 88] bad41 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_16.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.157s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good16, On N98 -> N57 (call good16)
> takes the true branch, At N67 of Function good16
> Leaving function: good16, On N56 -> N99 (Return edge from good16 to main)
> Entering function: bad16, On N99 -> N1 (call bad16)
> takes the false branch, At N11 of Function bad16
> takes the false branch, At N18 of Function bad16
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_16.c 84] bad16 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good9, On N98 -> N57 (call good9)
> takes the true branch, At N67 of Function good9
> Leaving function: good9, On N56 -> N99 (Return edge from good9 to main)
> Entering function: bad9, On N99 -> N1 (call bad9)
> takes the false branch, At N11 of Function bad9
> takes the false branch, At N18 of Function bad9
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_9.c 81] bad9 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.144s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good15, On N98 -> N57 (call good15)
> takes the true branch, At N67 of Function good15
> Leaving function: good15, On N56 -> N99 (Return edge from good15 to main)
> Entering function: bad15, On N99 -> N1 (call bad15)
> takes the false branch, At N11 of Function bad15
> takes the false branch, At N18 of Function bad15
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_15.c 81] bad15 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.156s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good6, On N66 -> N40 (call good6)
> takes the true branch, At N48 of Function good6
> Leaving function: good6, On N39 -> N67 (Return edge from good6 to main)
> Entering function: bad6, On N67 -> N1 (call bad6)
> takes the false branch, At N9 of Function bad6
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_6.c 78] bad6 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.142s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good12, On N98 -> N57 (call good12)
> takes the true branch, At N67 of Function good12
> Leaving function: good12, On N56 -> N99 (Return edge from good12 to main)
> Entering function: bad12, On N99 -> N1 (call bad12)
> takes the false branch, At N11 of Function bad12
> takes the false branch, At N18 of Function bad12
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_12.c 83] bad12 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_27.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.172s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good27, On N109 -> N62 (call good27)
> takes the true branch, At N72 of Function good27
> Leaving function: good27, On N61 -> N110 (Return edge from good27 to main)
> Entering function: bad27, On N110 -> N1 (call bad27)
> takes the false branch, At N11 of Function bad27
> takes the false branch, At N18 of Function bad27
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_27.c 88] bad27 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_42.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.149s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N101): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N36
On edge  : N36 -{%9 = load i32, i32* %arrayidx3, align 4}-> N37
Message  : the memory is already freed
> Start from entry function: main, At N101 of Function main
> Entering function: good42, On N104 -> N60 (call good42)
> takes the true branch, At N71 of Function good42
> Leaving function: good42, On N59 -> N105 (Return edge from good42 to main)
> Entering function: bad42, On N105 -> N1 (call bad42)
> takes the false branch, At N12 of Function bad42
> takes the false branch, At N19 of Function bad42
<Defect> : N36 -> N37: [%9 = load i32, i32* %arrayidx3, align 4]
N36 -> N37: [%9 = load i32, i32* %arrayidx3, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_42.c 82] bad42 		[N36 -{%9 = load i32, i32* %arrayidx3, align 4}-> N37]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_40.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.153s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N203): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call printLine}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N203 of Function main
> Entering function: good40, On N206 -> N37 (call good40)
> takes the false branch, At N41 of Function good40
> Entering function: helperGood, On N59 -> N134 (call helperGood)
> takes the true branch, At N149 of Function helperGood
> takes the true branch, At N159 of Function helperGood
> Leaving function: helperGood, On N133 -> N46 (Return edge from helperGood to good40)
> takes the true branch, At N49 of Function good40
> Leaving function: good40, On N36 -> N207 (Return edge from good40 to main)
> Entering function: bad40, On N207 -> N1 (call bad40)
> takes the true branch, At N5 of Function bad40
> Entering function: helperBad, On N18 -> N63 (call helperBad)
> takes the true branch, At N78 of Function helperBad
> takes the true branch, At N88 of Function helperBad
> Leaving function: helperBad, On N62 -> N8 (Return edge from helperBad to bad40)
> takes the false branch, At N11 of Function bad40
<Defect> : N14 -> N230: [call printLine]
N14 -> N230: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_40.c 116] bad40 		[N14 -{call printLine}-> N230]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_31.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.199s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good31, On N194 -> N32 (call good31)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good31)
> takes the true branch, At N39 of Function good31
> Leaving function: good31, On N31 -> N195 (Return edge from good31 to main)
> Entering function: bad31, On N195 -> N1 (call bad31)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the true branch, At N76 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad31)
> takes the false branch, At N8 of Function bad31
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_31.c 115] bad31 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_35.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.174s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N203): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call printLine}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N203 of Function main
> Entering function: good35, On N206 -> N37 (call good35)
> takes the false branch, At N41 of Function good35
> Entering function: helperGood, On N59 -> N134 (call helperGood)
> takes the true branch, At N149 of Function helperGood
> takes the true branch, At N159 of Function helperGood
> Leaving function: helperGood, On N133 -> N46 (Return edge from helperGood to good35)
> takes the true branch, At N49 of Function good35
> Leaving function: good35, On N36 -> N207 (Return edge from good35 to main)
> Entering function: bad35, On N207 -> N1 (call bad35)
> takes the true branch, At N5 of Function bad35
> Entering function: helperBad, On N18 -> N63 (call helperBad)
> takes the true branch, At N78 of Function helperBad
> takes the true branch, At N88 of Function helperBad
> Leaving function: helperBad, On N62 -> N8 (Return edge from helperBad to bad35)
> takes the false branch, At N11 of Function bad35
<Defect> : N14 -> N230: [call printLine]
N14 -> N230: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_35.c 122] bad35 		[N14 -{call printLine}-> N230]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_26.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.174s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N130): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N46
On edge  : N46 -{call printStructLine}-> N181
Message  : the memory is already freed
> Start from entry function: main, At N130 of Function main
> Entering function: good26, On N133 -> N73 (call good26)
> takes the true branch, At N80 of Function good26
> takes the true branch, At N86 of Function good26
> Leaving function: good26, On N72 -> N134 (Return edge from good26 to main)
> Entering function: bad26, On N134 -> N1 (call bad26)
> takes the false branch, At N8 of Function bad26
> takes the true branch, At N43 of Function bad26
<Defect> : N46 -> N181: [call printStructLine]
N46 -> N181: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N45
On edge  : N45 -{%arrayidx7 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %12, i64 0}-> N46
Message  : null pointer dereference
> Start from entry function: main, At N130 of Function main
> Entering function: good26, On N133 -> N73 (call good26)
> takes the true branch, At N80 of Function good26
> takes the true branch, At N86 of Function good26
> Leaving function: good26, On N72 -> N134 (Return edge from good26 to main)
> Entering function: bad26, On N134 -> N1 (call bad26)
> takes the false branch, At N8 of Function bad26
> takes the true branch, At N43 of Function bad26
<Defect> : N45 -> N46: [%arrayidx7 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %12, i64 0]
N45 -> N46: [%arrayidx7 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %12, i64 0] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_26.c 89] bad26 		[N46 -{call printStructLine}-> N181]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./416_26.c 89] bad26 		[N45 -{%arrayidx7 = getelementptr inbounds %struct._twoIntsStruct, %struct._twoIntsStruct* %12, i64 0}-> N46]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_50.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.191s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N193): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N12
On edge  : N12 -{call printLine}-> N220
Message  : the memory is already freed
> Start from entry function: main, At N193 of Function main
> Entering function: good50, On N196 -> N33 (call good50)
> Entering function: helperGood, On N37 -> N124 (call helperGood)
> takes the true branch, At N139 of Function helperGood
> takes the true branch, At N149 of Function helperGood
> Leaving function: helperGood, On N123 -> N38 (Return edge from helperGood to good50)
> takes the true branch, At N41 of Function good50
> Leaving function: good50, On N32 -> N197 (Return edge from good50 to main)
> Entering function: bad50, On N197 -> N1 (call bad50)
> Entering function: helperBad, On N5 -> N53 (call helperBad)
> takes the true branch, At N68 of Function helperBad
> takes the true branch, At N78 of Function helperBad
> Leaving function: helperBad, On N52 -> N6 (Return edge from helperBad to bad50)
> takes the false branch, At N9 of Function bad50
<Defect> : N12 -> N220: [call printLine]
N12 -> N220: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_50.c 116] bad50 		[N12 -{call printLine}-> N220]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_47.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.173s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N149): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N52
On edge  : N52 -{%12 = load i64, i64* %arrayidx12, align 8}-> N53
Message  : the memory is already freed
> Start from entry function: main, At N149 of Function main
> Entering function: good47, On N152 -> N84 (call good47)
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the true branch, At N103 of Function good47
> Leaving function: good47, On N83 -> N153 (Return edge from good47 to main)
> Entering function: bad47, On N153 -> N1 (call bad47)
> takes the false branch, At N14 of Function bad47
> takes the true branch, At N49 of Function bad47
<Defect> : N52 -> N53: [%12 = load i64, i64* %arrayidx12, align 8]
N52 -> N53: [%12 = load i64, i64* %arrayidx12, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N51
On edge  : N51 -{%arrayidx12 = getelementptr inbounds i64, i64* %11, i64 0}-> N52
Message  : null pointer dereference
> Start from entry function: main, At N149 of Function main
> Entering function: good47, On N152 -> N84 (call good47)
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the true branch, At N103 of Function good47
> Leaving function: good47, On N83 -> N153 (Return edge from good47 to main)
> Entering function: bad47, On N153 -> N1 (call bad47)
> takes the false branch, At N14 of Function bad47
> takes the true branch, At N49 of Function bad47
<Defect> : N51 -> N52: [%arrayidx12 = getelementptr inbounds i64, i64* %11, i64 0]
N51 -> N52: [%arrayidx12 = getelementptr inbounds i64, i64* %11, i64 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N52
On edge  : N52 -{%12 = load i64, i64* %arrayidx12, align 8}-> N53
Message  : null pointer dereference
> Start from entry function: main, At N149 of Function main
> Entering function: good47, On N152 -> N84 (call good47)
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the false branch, At N103 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the true branch, At N110 of Function good47
> takes the false branch, At N110 of Function good47
> takes the true branch, At N97 of Function good47
> takes the true branch, At N103 of Function good47
> Leaving function: good47, On N83 -> N153 (Return edge from good47 to main)
> Entering function: bad47, On N153 -> N1 (call bad47)
> takes the false branch, At N14 of Function bad47
> takes the true branch, At N49 of Function bad47
<Defect> : N52 -> N53: [%12 = load i64, i64* %arrayidx12, align 8]
N52 -> N53: [%12 = load i64, i64* %arrayidx12, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_47.c 82] bad47 		[N52 -{%12 = load i64, i64* %arrayidx12, align 8}-> N53]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 2
	[./416_47.c 82] bad47 		[N51 -{%arrayidx12 = getelementptr inbounds i64, i64* %11, i64 0}-> N52]	(null pointer dereference)
	[./416_47.c 82] bad47 		[N52 -{%12 = load i64, i64* %arrayidx12, align 8}-> N53]	(null pointer dereference)

Found 3 defects in all (60 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_20.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.162s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N119): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N39
On edge  : N39 -{%arrayidx8 = getelementptr inbounds i64, i64* %8, i64 0}-> N40
Message  : null pointer dereference
> Start from entry function: main, At N119 of Function main
> Entering function: good20, On N122 -> N68 (call good20)
> Entering function: staticReturnsTrue, On N73 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N74 (Return edge from staticReturnsTrue to good20)
> takes the true branch, At N75 of Function good20
> takes the true branch, At N81 of Function good20
> Leaving function: good20, On N67 -> N123 (Return edge from good20 to main)
> Entering function: bad20, On N123 -> N1 (call bad20)
> Entering function: staticReturnsTrue, On N6 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N7 (Return edge from staticReturnsTrue to bad20)
> takes the false branch, At N8 of Function bad20
> Entering function: staticReturnsTrue, On N35 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N36 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N37 of Function bad20
<Defect> : N39 -> N40: [%arrayidx8 = getelementptr inbounds i64, i64* %8, i64 0]
N39 -> N40: [%arrayidx8 = getelementptr inbounds i64, i64* %8, i64 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N40
On edge  : N40 -{%9 = load i64, i64* %arrayidx8, align 8}-> N41
Message  : null pointer dereference
> Start from entry function: main, At N119 of Function main
> Entering function: good20, On N122 -> N68 (call good20)
> Entering function: staticReturnsTrue, On N73 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N74 (Return edge from staticReturnsTrue to good20)
> takes the true branch, At N75 of Function good20
> takes the true branch, At N81 of Function good20
> Leaving function: good20, On N67 -> N123 (Return edge from good20 to main)
> Entering function: bad20, On N123 -> N1 (call bad20)
> Entering function: staticReturnsTrue, On N6 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N7 (Return edge from staticReturnsTrue to bad20)
> takes the false branch, At N8 of Function bad20
> Entering function: staticReturnsTrue, On N35 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N36 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N37 of Function bad20
<Defect> : N40 -> N41: [%9 = load i64, i64* %arrayidx8, align 8]
N40 -> N41: [%9 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N40
On edge  : N40 -{%9 = load i64, i64* %arrayidx8, align 8}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N119 of Function main
> Entering function: good20, On N122 -> N68 (call good20)
> Entering function: staticReturnsTrue, On N73 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N74 (Return edge from staticReturnsTrue to good20)
> takes the true branch, At N75 of Function good20
> takes the true branch, At N81 of Function good20
> Leaving function: good20, On N67 -> N123 (Return edge from good20 to main)
> Entering function: bad20, On N123 -> N1 (call bad20)
> Entering function: staticReturnsTrue, On N6 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N7 (Return edge from staticReturnsTrue to bad20)
> takes the false branch, At N8 of Function bad20
> Entering function: staticReturnsTrue, On N35 -> N174 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N173 -> N36 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N37 of Function bad20
<Defect> : N40 -> N41: [%9 = load i64, i64* %arrayidx8, align 8]
N40 -> N41: [%9 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 2
	[./416_20.c 91] bad20 		[N39 -{%arrayidx8 = getelementptr inbounds i64, i64* %8, i64 0}-> N40]	(null pointer dereference)
	[./416_20.c 91] bad20 		[N40 -{%9 = load i64, i64* %arrayidx8, align 8}-> N41]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./416_20.c 91] bad20 		[N40 -{%9 = load i64, i64* %arrayidx8, align 8}-> N41]	(the memory is already freed)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good8, On N98 -> N57 (call good8)
> takes the true branch, At N67 of Function good8
> Leaving function: good8, On N56 -> N99 (Return edge from good8 to main)
> Entering function: bad8, On N99 -> N1 (call bad8)
> takes the false branch, At N11 of Function bad8
> takes the false branch, At N18 of Function bad8
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_8.c 81] bad8 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_17.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.184s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N119): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N40
On edge  : N40 -{%11 = load i64, i64* %arrayidx6, align 8}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N119 of Function main
> Entering function: good17, On N122 -> N68 (call good17)
> takes the true branch, At N75 of Function good17
> takes the true branch, At N81 of Function good17
> Leaving function: good17, On N67 -> N123 (Return edge from good17 to main)
> Entering function: bad17, On N123 -> N1 (call bad17)
> takes the false branch, At N8 of Function bad17
> takes the true branch, At N37 of Function bad17
<Defect> : N40 -> N41: [%11 = load i64, i64* %arrayidx6, align 8]
N40 -> N41: [%11 = load i64, i64* %arrayidx6, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N39
On edge  : N39 -{%arrayidx6 = getelementptr inbounds i64, i64* %10, i64 0}-> N40
Message  : null pointer dereference
> Start from entry function: main, At N119 of Function main
> Entering function: good17, On N122 -> N68 (call good17)
> takes the true branch, At N75 of Function good17
> takes the true branch, At N81 of Function good17
> Leaving function: good17, On N67 -> N123 (Return edge from good17 to main)
> Entering function: bad17, On N123 -> N1 (call bad17)
> takes the false branch, At N8 of Function bad17
> takes the true branch, At N37 of Function bad17
<Defect> : N39 -> N40: [%arrayidx6 = getelementptr inbounds i64, i64* %10, i64 0]
N39 -> N40: [%arrayidx6 = getelementptr inbounds i64, i64* %10, i64 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N40
On edge  : N40 -{%11 = load i64, i64* %arrayidx6, align 8}-> N41
Message  : null pointer dereference
> Start from entry function: main, At N119 of Function main
> Entering function: good17, On N122 -> N68 (call good17)
> takes the true branch, At N75 of Function good17
> takes the true branch, At N81 of Function good17
> Leaving function: good17, On N67 -> N123 (Return edge from good17 to main)
> Entering function: bad17, On N123 -> N1 (call bad17)
> takes the false branch, At N8 of Function bad17
> takes the true branch, At N37 of Function bad17
<Defect> : N40 -> N41: [%11 = load i64, i64* %arrayidx6, align 8]
N40 -> N41: [%11 = load i64, i64* %arrayidx6, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_17.c 84] bad17 		[N40 -{%11 = load i64, i64* %arrayidx6, align 8}-> N41]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 2
	[./416_17.c 84] bad17 		[N39 -{%arrayidx6 = getelementptr inbounds i64, i64* %10, i64 0}-> N40]	(null pointer dereference)
	[./416_17.c 84] bad17 		[N40 -{%11 = load i64, i64* %arrayidx6, align 8}-> N41]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_44.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.16s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N98): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N35
On edge  : N35 -{%9 = load i32, i32* %arrayidx2, align 4}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N98 of Function main
> Entering function: bad44, On N101 -> N1 (call bad44)
> takes the false branch, At N12 of Function bad44
> takes the false branch, At N19 of Function bad44
<Defect> : N35 -> N36: [%9 = load i32, i32* %arrayidx2, align 4]
N35 -> N36: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_44.c 80] bad44 		[N35 -{%9 = load i32, i32* %arrayidx2, align 4}-> N36]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_49.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.189s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N11
On edge  : N11 -{call printLine}-> N218
Message  : the memory is already freed
> Start from entry function: main, At N191 of Function main
> Entering function: good49, On N194 -> N32 (call good49)
> Entering function: helperGood, On N35 -> N122 (call helperGood)
> takes the true branch, At N137 of Function helperGood
> takes the true branch, At N147 of Function helperGood
> Leaving function: helperGood, On N121 -> N36 (Return edge from helperGood to good49)
> takes the true branch, At N39 of Function good49
> Leaving function: good49, On N31 -> N195 (Return edge from good49 to main)
> Entering function: bad49, On N195 -> N1 (call bad49)
> Entering function: helperBad, On N4 -> N51 (call helperBad)
> takes the true branch, At N66 of Function helperBad
> takes the true branch, At N76 of Function helperBad
> Leaving function: helperBad, On N50 -> N5 (Return edge from helperBad to bad49)
> takes the false branch, At N8 of Function bad49
<Defect> : N11 -> N218: [call printLine]
N11 -> N218: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_49.c 117] bad49 		[N11 -{call printLine}-> N218]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.143s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N119): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N40
On edge  : N40 -{%11 = load i32, i32* %arrayidx6, align 4}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N119 of Function main
> Entering function: good11, On N122 -> N68 (call good11)
> takes the true branch, At N75 of Function good11
> takes the true branch, At N81 of Function good11
> Leaving function: good11, On N67 -> N123 (Return edge from good11 to main)
> Entering function: bad11, On N123 -> N1 (call bad11)
> takes the false branch, At N8 of Function bad11
> takes the true branch, At N37 of Function bad11
<Defect> : N40 -> N41: [%11 = load i32, i32* %arrayidx6, align 4]
N40 -> N41: [%11 = load i32, i32* %arrayidx6, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N39
On edge  : N39 -{%arrayidx6 = getelementptr inbounds i32, i32* %10, i64 0}-> N40
Message  : null pointer dereference
> Start from entry function: main, At N119 of Function main
> Entering function: good11, On N122 -> N68 (call good11)
> takes the true branch, At N75 of Function good11
> takes the true branch, At N81 of Function good11
> Leaving function: good11, On N67 -> N123 (Return edge from good11 to main)
> Entering function: bad11, On N123 -> N1 (call bad11)
> takes the false branch, At N8 of Function bad11
> takes the true branch, At N37 of Function bad11
<Defect> : N39 -> N40: [%arrayidx6 = getelementptr inbounds i32, i32* %10, i64 0]
N39 -> N40: [%arrayidx6 = getelementptr inbounds i32, i32* %10, i64 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N40
On edge  : N40 -{%11 = load i32, i32* %arrayidx6, align 4}-> N41
Message  : null pointer dereference
> Start from entry function: main, At N119 of Function main
> Entering function: good11, On N122 -> N68 (call good11)
> takes the true branch, At N75 of Function good11
> takes the true branch, At N81 of Function good11
> Leaving function: good11, On N67 -> N123 (Return edge from good11 to main)
> Entering function: bad11, On N123 -> N1 (call bad11)
> takes the false branch, At N8 of Function bad11
> takes the true branch, At N37 of Function bad11
<Defect> : N40 -> N41: [%11 = load i32, i32* %arrayidx6, align 4]
N40 -> N41: [%11 = load i32, i32* %arrayidx6, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_11.c 84] bad11 		[N40 -{%11 = load i32, i32* %arrayidx6, align 4}-> N41]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 2
	[./416_11.c 84] bad11 		[N39 -{%arrayidx6 = getelementptr inbounds i32, i32* %10, i64 0}-> N40]	(null pointer dereference)
	[./416_11.c 84] bad11 		[N40 -{%11 = load i32, i32* %arrayidx6, align 4}-> N41]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_18.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good18, On N98 -> N57 (call good18)
> takes the true branch, At N67 of Function good18
> Leaving function: good18, On N56 -> N99 (Return edge from good18 to main)
> Entering function: bad18, On N99 -> N1 (call bad18)
> takes the false branch, At N11 of Function bad18
> takes the false branch, At N18 of Function bad18
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_18.c 83] bad18 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_45.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.134s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good45, On N98 -> N57 (call good45)
> takes the true branch, At N67 of Function good45
> Leaving function: good45, On N56 -> N99 (Return edge from good45 to main)
> Entering function: bad45, On N99 -> N1 (call bad45)
> takes the false branch, At N11 of Function bad45
> takes the false branch, At N18 of Function bad45
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_45.c 88] bad45 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_43.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.171s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N124): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N44
On edge  : N44 -{%arrayidx9 = getelementptr inbounds i32, i32* %10, i64 0}-> N45
Message  : null pointer dereference
> Start from entry function: main, At N124 of Function main
> Entering function: good43, On N127 -> N71 (call good43)
> takes the false branch, At N84 of Function good43
> Leaving function: good43, On N70 -> N128 (Return edge from good43 to main)
> Entering function: bad43, On N128 -> N1 (call bad43)
> takes the false branch, At N12 of Function bad43
<Defect> : N44 -> N45: [%arrayidx9 = getelementptr inbounds i32, i32* %10, i64 0]
N44 -> N45: [%arrayidx9 = getelementptr inbounds i32, i32* %10, i64 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N45
On edge  : N45 -{%11 = load i32, i32* %arrayidx9, align 4}-> N46
Message  : null pointer dereference
> Start from entry function: main, At N124 of Function main
> Entering function: good43, On N127 -> N71 (call good43)
> takes the false branch, At N84 of Function good43
> Leaving function: good43, On N70 -> N128 (Return edge from good43 to main)
> Entering function: bad43, On N128 -> N1 (call bad43)
> takes the false branch, At N12 of Function bad43
<Defect> : N45 -> N46: [%11 = load i32, i32* %arrayidx9, align 4]
N45 -> N46: [%11 = load i32, i32* %arrayidx9, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N45
On edge  : N45 -{%11 = load i32, i32* %arrayidx9, align 4}-> N46
Message  : the memory is already freed
> Start from entry function: main, At N124 of Function main
> Entering function: good43, On N127 -> N71 (call good43)
> takes the false branch, At N84 of Function good43
> Leaving function: good43, On N70 -> N128 (Return edge from good43 to main)
> Entering function: bad43, On N128 -> N1 (call bad43)
> takes the false branch, At N12 of Function bad43
<Defect> : N45 -> N46: [%11 = load i32, i32* %arrayidx9, align 4]
N45 -> N46: [%11 = load i32, i32* %arrayidx9, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 2
	[./416_43.c 81] bad43 		[N44 -{%arrayidx9 = getelementptr inbounds i32, i32* %10, i64 0}-> N45]	(null pointer dereference)
	[./416_43.c 81] bad43 		[N45 -{%11 = load i32, i32* %arrayidx9, align 4}-> N46]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./416_43.c 81] bad43 		[N45 -{%11 = load i32, i32* %arrayidx9, align 4}-> N46]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_38.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
14 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.157s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N203): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call printLine}-> N230
Message  : the memory is already freed
> Start from entry function: main, At N203 of Function main
> Entering function: good38, On N206 -> N37 (call good38)
> Entering function: staticReturnsFalse, On N39 -> N254 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N253 -> N40 (Return edge from staticReturnsFalse to good38)
> takes the false branch, At N41 of Function good38
> Entering function: helperGood, On N59 -> N134 (call helperGood)
> takes the true branch, At N149 of Function helperGood
> takes the true branch, At N159 of Function helperGood
> Leaving function: helperGood, On N133 -> N46 (Return edge from helperGood to good38)
> takes the true branch, At N49 of Function good38
> Leaving function: good38, On N36 -> N207 (Return edge from good38 to main)
> Entering function: bad38, On N207 -> N1 (call bad38)
> Entering function: staticReturnsTrue, On N3 -> N258 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N257 -> N4 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N5 of Function bad38
> Entering function: helperBad, On N18 -> N63 (call helperBad)
> takes the true branch, At N78 of Function helperBad
> takes the true branch, At N88 of Function helperBad
> Leaving function: helperBad, On N62 -> N8 (Return edge from helperBad to bad38)
> takes the false branch, At N11 of Function bad38
<Defect> : N14 -> N230: [call printLine]
N14 -> N230: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_38.c 129] bad38 		[N14 -{call printLine}-> N230]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.128s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good10, On N98 -> N57 (call good10)
> takes the true branch, At N67 of Function good10
> Leaving function: good10, On N56 -> N99 (Return edge from good10 to main)
> Entering function: bad10, On N99 -> N1 (call bad10)
> takes the false branch, At N11 of Function bad10
> takes the false branch, At N18 of Function bad10
<Defect> : N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4]
N33 -> N34: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_10.c 84] bad10 		[N33 -{%9 = load i32, i32* %arrayidx2, align 4}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good4, On N66 -> N40 (call good4)
> takes the true branch, At N48 of Function good4
> Leaving function: good4, On N39 -> N67 (Return edge from good4 to main)
> Entering function: bad4, On N67 -> N1 (call bad4)
> takes the false branch, At N9 of Function bad4
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_4.c 79] bad4 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.155s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N95): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N33
On edge  : N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34
Message  : the memory is already freed
> Start from entry function: main, At N95 of Function main
> Entering function: good14, On N98 -> N57 (call good14)
> takes the true branch, At N67 of Function good14
> Leaving function: good14, On N56 -> N99 (Return edge from good14 to main)
> Entering function: bad14, On N99 -> N1 (call bad14)
> takes the false branch, At N11 of Function bad14
> takes the false branch, At N18 of Function bad14
<Defect> : N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8]
N33 -> N34: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_14.c 81] bad14 		[N33 -{%9 = load i64, i64* %arrayidx2, align 8}-> N34]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 0 entries: []
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_30.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.16s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N106): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call printStructLine}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N106 of Function main
> Entering function: good30, On N109 -> N62 (call good30)
> takes the true branch, At N72 of Function good30
> Leaving function: good30, On N61 -> N110 (Return edge from good30 to main)
> Entering function: bad30, On N110 -> N1 (call bad30)
> takes the false branch, At N11 of Function bad30
> takes the false branch, At N18 of Function bad30
<Defect> : N39 -> N157: [call printStructLine]
N39 -> N157: [call printStructLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_30.c 86] bad30 		[N39 -{call printStructLine}-> N157]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/Juliet_Test_Suite/416/416_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.106s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N90
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good3, On N66 -> N40 (call good3)
> takes the true branch, At N48 of Function good3
> Leaving function: good3, On N39 -> N67 (Return edge from good3 to main)
> Entering function: bad3, On N67 -> N1 (call bad3)
> takes the false branch, At N9 of Function bad3
<Defect> : N19 -> N90: [call printLine]
N19 -> N90: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_3.c 76] bad3 		[N19 -{call printLine}-> N90]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0012_good]
 +memory_leak_0012_good
SCC(1): [memory_leak_0012_bad]
 +memory_leak_0012_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.111s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0012_bad to main}-> N6
Message  : the heap object @H(memory_leak_0012_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0012_good, On N4 -> N39 (call memory_leak_0012_good)
> takes the false branch, At N52 of Function memory_leak_0012_good
> Leaving function: memory_leak_0012_good, On N38 -> N5 (Return edge from memory_leak_0012_good to main)
> Entering function: memory_leak_0012_bad, On N5 -> N9 (call memory_leak_0012_bad)
> takes the false branch, At N18 of Function memory_leak_0012_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0012_bad to main]
N8 -> N6: [Return edge from memory_leak_0012_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_12.c 77] memory_leak_0012_bad 		[N8 -{Return edge from memory_leak_0012_bad to main}-> N6]	(the heap object @H(memory_leak_0012_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_005_good]
 +memory_leak_005_good
SCC(1): [memory_leak_005_bad]
 +memory_leak_005_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.104s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N34
On edge  : N34 -{call void @free(i8* %6, i8* @free)}-> N36
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_005_good, On N4 -> N45 (call memory_leak_005_good)
> takes the false branch, At N53 of Function memory_leak_005_good
> Leaving function: memory_leak_005_good, On N44 -> N5 (Return edge from memory_leak_005_good to main)
> Entering function: memory_leak_005_bad, On N5 -> N9 (call memory_leak_005_bad)
> takes the false branch, At N17 of Function memory_leak_005_bad
> takes the true branch, At N31 of Function memory_leak_005_bad
<Defect> : N34 -> N36: [call void @free(i8* %6, i8* @free)]
N34 -> N36: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_005_bad to main}-> N6
Message  : the heap object @H(memory_leak_005_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_005_good, On N4 -> N45 (call memory_leak_005_good)
> takes the false branch, At N53 of Function memory_leak_005_good
> Leaving function: memory_leak_005_good, On N44 -> N5 (Return edge from memory_leak_005_good to main)
> Entering function: memory_leak_005_bad, On N5 -> N9 (call memory_leak_005_bad)
> takes the true branch, At N17 of Function memory_leak_005_bad
> takes the true branch, At N23 of Function memory_leak_005_bad
> takes the false branch, At N31 of Function memory_leak_005_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_005_bad to main]
N8 -> N6: [Return edge from memory_leak_005_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_5.c 31] memory_leak_005_bad 		[N34 -{call void @free(i8* %6, i8* @free)}-> N36]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_5.c 62] memory_leak_005_bad 		[N8 -{Return edge from memory_leak_005_bad to main}-> N6]	(the heap object @H(memory_leak_005_bad::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_003_func_001_good]
 +memory_leak_003_func_001_good
SCC(1): [memory_leak_003_good]
 +memory_leak_003_good
SCC(1): [memory_leak_003_func_001_bad]
 +memory_leak_003_func_001_bad
SCC(1): [memory_leak_003_bad]
 +memory_leak_003_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N91
On edge  : N91 -{%1 = load i8*, i8** %str1, align 8}-> N92
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_003_good, On N4 -> N81 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N90 -> N53 (call memory_leak_003_func_001_good)
> takes the true branch, At N70 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N52 -> N91 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
<Defect> : N91 -> N92: [%1 = load i8*, i8** %str1, align 8]
N91 -> N92: [%1 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N94
On edge  : N94 -{%3 = load i8*, i8** %str1, align 8}-> N95
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_003_good, On N4 -> N81 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N90 -> N53 (call memory_leak_003_func_001_good)
> takes the true branch, At N70 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N52 -> N91 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
<Defect> : N94 -> N95: [%3 = load i8*, i8** %str1, align 8]
N94 -> N95: [%3 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N19
On edge  : N19 -{%1 = load i8*, i8** %str1, align 8}-> N20
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_003_good, On N4 -> N81 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N90 -> N53 (call memory_leak_003_func_001_good)
> takes the true branch, At N70 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N52 -> N91 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
> Leaving function: memory_leak_003_good, On N80 -> N5 (Return edge from memory_leak_003_good to main)
> Entering function: memory_leak_003_bad, On N5 -> N9 (call memory_leak_003_bad)
> Entering function: memory_leak_003_func_001_bad, On N18 -> N25 (call memory_leak_003_func_001_bad)
> takes the true branch, At N42 of Function memory_leak_003_func_001_bad
> Leaving function: memory_leak_003_func_001_bad, On N24 -> N19 (Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad)
<Defect> : N19 -> N20: [%1 = load i8*, i8** %str1, align 8]
N19 -> N20: [%1 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_003_bad to main}-> N6
Message  : the heap object @H(memory_leak_003_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_003_good, On N4 -> N81 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N90 -> N53 (call memory_leak_003_func_001_good)
> takes the true branch, At N70 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N52 -> N91 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
> Leaving function: memory_leak_003_good, On N80 -> N5 (Return edge from memory_leak_003_good to main)
> Entering function: memory_leak_003_bad, On N5 -> N9 (call memory_leak_003_bad)
> Entering function: memory_leak_003_func_001_bad, On N18 -> N25 (call memory_leak_003_func_001_bad)
> takes the false branch, At N42 of Function memory_leak_003_func_001_bad
> Leaving function: memory_leak_003_func_001_bad, On N24 -> N19 (Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad)
<Defect> : N8 -> N6: [Return edge from memory_leak_003_bad to main]
N8 -> N6: [Return edge from memory_leak_003_bad to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 3
	[./401_memory_leak_3.c 55] memory_leak_003_good 		[N91 -{%1 = load i8*, i8** %str1, align 8}-> N92]	(use of uninitialized variable)
	[./401_memory_leak_3.c 56] memory_leak_003_good 		[N94 -{%3 = load i8*, i8** %str1, align 8}-> N95]	(use of uninitialized variable)
	[./401_memory_leak_3.c 33] memory_leak_003_bad 		[N19 -{%1 = load i8*, i8** %str1, align 8}-> N20]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_memory_leak_3.c 67] memory_leak_003_bad 		[N8 -{Return edge from memory_leak_003_bad to main}-> N6]	(the heap object @H(memory_leak_003_func_001_bad::call) is not referenced any more)

Found 4 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_14.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0014_bad]
 +memory_leak_0014_bad
SCC(1): [memory_leak_0014_good]
 +memory_leak_0014_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.095s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N82
On edge  : N82 -{call void @free(i8* %10, i8* @free)}-> N83
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0014_good, On N4 -> N47 (call memory_leak_0014_good)
> takes the false branch, At N68 of Function memory_leak_0014_good
<Defect> : N82 -> N83: [call void @free(i8* %10, i8* @free)]
N82 -> N83: [call void @free(i8* %10, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0014_bad to main}-> N6
Message  : the heap object @H(memory_leak_0014_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0014_good, On N4 -> N47 (call memory_leak_0014_good)
> takes the false branch, At N68 of Function memory_leak_0014_good
> Leaving function: memory_leak_0014_good, On N46 -> N5 (Return edge from memory_leak_0014_good to main)
> Entering function: memory_leak_0014_bad, On N5 -> N9 (call memory_leak_0014_bad)
> takes the true branch, At N30 of Function memory_leak_0014_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0014_bad to main]
N8 -> N6: [Return edge from memory_leak_0014_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_14.c 59] memory_leak_0014_good 		[N82 -{call void @free(i8* %10, i8* @free)}-> N83]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_14.c 71] memory_leak_0014_bad 		[N8 -{Return edge from memory_leak_0014_bad to main}-> N6]	(the heap object @H(memory_leak_0014_bad::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_002_good]
 +memory_leak_002_good
SCC(1): [memory_leak_002_bad]
 +memory_leak_002_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.23s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N204
On edge  : N204 -{call void @free(i8* %31, i8* @free)}-> N206
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
<Defect> : N204 -> N206: [call void @free(i8* %31, i8* @free)]
N204 -> N206: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N155
On edge  : N155 -{call void @free(i8* %14, i8* @free)}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N148 of Function memory_leak_002_good
<Defect> : N155 -> N157: [call void @free(i8* %14, i8* @free)]
N155 -> N157: [call void @free(i8* %14, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_002_bad to main}-> N6
Message  : the heap object @H(memory_leak_002_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the false branch, At N20 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the true branch, At N42 of Function memory_leak_002_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_002_bad to main]
N8 -> N6: [Return edge from memory_leak_002_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_002_good::call2) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the false branch, At N20 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the true branch, At N42 of Function memory_leak_002_bad
> Leaving function: memory_leak_002_bad, On N8 -> N6 (Return edge from memory_leak_002_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_002_bad::call2) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the false branch, At N20 of Function memory_leak_002_bad
> takes the true branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N42 of Function memory_leak_002_bad
> takes the false branch, At N28 of Function memory_leak_002_bad
> takes the false branch, At N56 of Function memory_leak_002_bad
> Leaving function: memory_leak_002_bad, On N8 -> N6 (Return edge from memory_leak_002_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N192
On edge  : N192 -{store i32 %22, i32* %add.ptr23, align 4}-> N194
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the true branch, At N182 of Function memory_leak_002_good
<Defect> : N192 -> N194: [store i32 %22, i32* %add.ptr23, align 4]
N192 -> N194: [store i32 %22, i32* %add.ptr23, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N204
On edge  : N204 -{call void @free(i8* %31, i8* @free)}-> N206
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N177 of Function memory_leak_002_good
> takes the false branch, At N182 of Function memory_leak_002_good
<Defect> : N204 -> N206: [call void @free(i8* %31, i8* @free)]
N204 -> N206: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N155
On edge  : N155 -{call void @free(i8* %14, i8* @free)}-> N157
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N148 of Function memory_leak_002_good
<Defect> : N155 -> N157: [call void @free(i8* %14, i8* @free)]
N155 -> N157: [call void @free(i8* %14, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N79
On edge  : N79 -{store i32 %16, i32* %add.ptr20, align 4}-> N81
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N142 of Function memory_leak_002_good
> takes the false branch, At N128 of Function memory_leak_002_good
> takes the false branch, At N177 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N108 -> N5 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N5 -> N9 (call memory_leak_002_bad)
> takes the false branch, At N20 of Function memory_leak_002_bad
> takes the false branch, At N28 of Function memory_leak_002_bad
> takes the true branch, At N56 of Function memory_leak_002_bad
> takes the false branch, At N63 of Function memory_leak_002_bad
> takes the true branch, At N69 of Function memory_leak_002_bad
<Defect> : N79 -> N81: [store i32 %16, i32* %add.ptr20, align 4]
N79 -> N81: [store i32 %16, i32* %add.ptr20, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N155
On edge  : N155 -{call void @free(i8* %14, i8* @free)}-> N157
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_002_good, On N4 -> N109 (call memory_leak_002_good)
> takes the false branch, At N120 of Function memory_leak_002_good
> takes the true branch, At N128 of Function memory_leak_002_good
> takes the true branch, At N142 of Function memory_leak_002_good
> takes the true branch, At N148 of Function memory_leak_002_good
<Defect> : N155 -> N157: [call void @free(i8* %14, i8* @free)]
N155 -> N157: [call void @free(i8* %14, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 2
	[./401_memory_leak_2.c 70] memory_leak_002_good 		[N204 -{call void @free(i8* %31, i8* @free)}-> N206]	(the memory is already freed)
	[./401_memory_leak_2.c 57] memory_leak_002_good 		[N155 -{call void @free(i8* %14, i8* @free)}-> N157]	(the memory is already freed)

CWE_401(Memory Leak): 3
	[./401_memory_leak_2.c 83] memory_leak_002_bad 		[N8 -{Return edge from memory_leak_002_bad to main}-> N6]	(the heap object @H(memory_leak_002_bad::call) is not referenced any more)
	[./401_memory_leak_2.c 84] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_002_good::call2) is not referenced any more)
	[./401_memory_leak_2.c 84] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_002_bad::call2) is not referenced any more)

CWE_416(Use After Free): 4
	[./401_memory_leak_2.c 68] memory_leak_002_good 		[N192 -{store i32 %22, i32* %add.ptr23, align 4}-> N194]	(the memory is already freed)
	[./401_memory_leak_2.c 70] memory_leak_002_good 		[N204 -{call void @free(i8* %31, i8* @free)}-> N206]	(the memory is already freed)
	[./401_memory_leak_2.c 57] memory_leak_002_good 		[N155 -{call void @free(i8* %14, i8* @free)}-> N157]	(the memory is already freed)
	[./401_memory_leak_2.c 36] memory_leak_002_bad 		[N79 -{store i32 %16, i32* %add.ptr20, align 4}-> N81]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_2.c 57] memory_leak_002_good 		[N155 -{call void @free(i8* %14, i8* @free)}-> N157]	(null pointer dereference)

Found 10 defects in all (405 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_004_bad]
 +memory_leak_004_bad
SCC(1): [memory_leak_004_good]
 +memory_leak_004_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.157s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N172
On edge  : N172 -{call void @free(i8* %24, i8* @free)}-> N174
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
<Defect> : N172 -> N174: [call void @free(i8* %24, i8* @free)]
N172 -> N174: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N139
On edge  : N139 -{call void @free(i8* %13, i8* @free)}-> N141
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N132 of Function memory_leak_004_good
<Defect> : N139 -> N141: [call void @free(i8* %13, i8* @free)]
N139 -> N141: [call void @free(i8* %13, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N158
On edge  : N158 -{%19 = load i8*, i8** %buf22, align 8}-> N159
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
<Defect> : N158 -> N159: [%19 = load i8*, i8** %buf22, align 8]
N158 -> N159: [%19 = load i8*, i8** %buf22, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N57
On edge  : N57 -{%11 = load i8*, i8** %buf13, align 8}-> N58
Message  : use of uninitialized variable
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N165 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N86 -> N5 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N5 -> N9 (call memory_leak_004_bad)
> takes the false branch, At N19 of Function memory_leak_004_bad
> takes the true branch, At N26 of Function memory_leak_004_bad
> takes the false branch, At N31 of Function memory_leak_004_bad
<Defect> : N57 -> N58: [%11 = load i8*, i8** %buf13, align 8]
N57 -> N58: [%11 = load i8*, i8** %buf13, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N172
On edge  : N172 -{call void @free(i8* %24, i8* @free)}-> N174
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
<Defect> : N172 -> N174: [call void @free(i8* %24, i8* @free)]
N172 -> N174: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N139
On edge  : N139 -{call void @free(i8* %13, i8* @free)}-> N141
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N132 of Function memory_leak_004_good
<Defect> : N139 -> N141: [call void @free(i8* %13, i8* @free)]
N139 -> N141: [call void @free(i8* %13, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N172
On edge  : N172 -{call void @free(i8* %24, i8* @free)}-> N174
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N165 of Function memory_leak_004_good
<Defect> : N172 -> N174: [call void @free(i8* %24, i8* @free)]
N172 -> N174: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N139
On edge  : N139 -{call void @free(i8* %13, i8* @free)}-> N141
Message  : the memory is already freed
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the true branch, At N125 of Function memory_leak_004_good
> takes the true branch, At N132 of Function memory_leak_004_good
<Defect> : N139 -> N141: [call void @free(i8* %13, i8* @free)]
N139 -> N141: [call void @free(i8* %13, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_004_bad to main}-> N6
Message  : the heap object @H(memory_leak_004_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N165 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N86 -> N5 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N5 -> N9 (call memory_leak_004_bad)
> takes the false branch, At N19 of Function memory_leak_004_bad
> takes the true branch, At N26 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the true branch, At N46 of Function memory_leak_004_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_004_bad to main]
N8 -> N6: [Return edge from memory_leak_004_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_004_good::call4) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N165 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N86 -> N5 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N5 -> N9 (call memory_leak_004_bad)
> takes the false branch, At N19 of Function memory_leak_004_bad
> takes the true branch, At N26 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the true branch, At N46 of Function memory_leak_004_bad
> Leaving function: memory_leak_004_bad, On N8 -> N6 (Return edge from memory_leak_004_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_004_bad::call4) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_004_good, On N4 -> N87 (call memory_leak_004_good)
> takes the false branch, At N98 of Function memory_leak_004_good
> takes the true branch, At N105 of Function memory_leak_004_good
> takes the true branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N125 of Function memory_leak_004_good
> takes the false branch, At N110 of Function memory_leak_004_good
> takes the false branch, At N165 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N86 -> N5 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N5 -> N9 (call memory_leak_004_bad)
> takes the false branch, At N19 of Function memory_leak_004_bad
> takes the true branch, At N26 of Function memory_leak_004_bad
> takes the true branch, At N31 of Function memory_leak_004_bad
> takes the false branch, At N46 of Function memory_leak_004_bad
> takes the false branch, At N31 of Function memory_leak_004_bad
> takes the false branch, At N64 of Function memory_leak_004_bad
> Leaving function: memory_leak_004_bad, On N8 -> N6 (Return edge from memory_leak_004_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 2
	[./401_memory_leak_4.c 78] memory_leak_004_good 		[N172 -{call void @free(i8* %24, i8* @free)}-> N174]	(the memory is already freed)
	[./401_memory_leak_4.c 70] memory_leak_004_good 		[N139 -{call void @free(i8* %13, i8* @free)}-> N141]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./401_memory_leak_4.c 76] memory_leak_004_good 		[N158 -{%19 = load i8*, i8** %buf22, align 8}-> N159]	(use of uninitialized variable)
	[./401_memory_leak_4.c 44] memory_leak_004_bad 		[N57 -{%11 = load i8*, i8** %buf13, align 8}-> N58]	(use of uninitialized variable)

CWE_476(Null Pointer Dereference): 2
	[./401_memory_leak_4.c 78] memory_leak_004_good 		[N172 -{call void @free(i8* %24, i8* @free)}-> N174]	(null pointer dereference)
	[./401_memory_leak_4.c 70] memory_leak_004_good 		[N139 -{call void @free(i8* %13, i8* @free)}-> N141]	(null pointer dereference)

CWE_416(Use After Free): 2
	[./401_memory_leak_4.c 78] memory_leak_004_good 		[N172 -{call void @free(i8* %24, i8* @free)}-> N174]	(the memory is already freed)
	[./401_memory_leak_4.c 70] memory_leak_004_good 		[N139 -{call void @free(i8* %13, i8* @free)}-> N141]	(the memory is already freed)

CWE_401(Memory Leak): 3
	[./401_memory_leak_4.c 90] memory_leak_004_bad 		[N8 -{Return edge from memory_leak_004_bad to main}-> N6]	(the heap object @H(memory_leak_004_bad::call) is not referenced any more)
	[./401_memory_leak_4.c 91] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_004_good::call4) is not referenced any more)
	[./401_memory_leak_4.c 91] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_004_bad::call4) is not referenced any more)

Found 11 defects in all (128 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_009_good]
 +memory_leak_009_good
SCC(1): [memory_leak_009_bad]
 +memory_leak_009_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.097s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_009_bad to main}-> N6
Message  : the heap object @H(memory_leak_009_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_009_good, On N4 -> N38 (call memory_leak_009_good)
> takes the false branch, At N49 of Function memory_leak_009_good
> Leaving function: memory_leak_009_good, On N37 -> N5 (Return edge from memory_leak_009_good to main)
> Entering function: memory_leak_009_bad, On N5 -> N9 (call memory_leak_009_bad)
> takes the false branch, At N22 of Function memory_leak_009_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_009_bad to main]
N8 -> N6: [Return edge from memory_leak_009_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_9.c 55] memory_leak_009_bad 		[N8 -{Return edge from memory_leak_009_bad to main}-> N6]	(the heap object @H(memory_leak_009_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_001_good]
 +memory_leak_001_good
SCC(1): [memory_leak_001_bad]
 +memory_leak_001_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.113s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_001_bad to main}-> N6
Message  : the heap object @H(memory_leak_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_001_good, On N4 -> N40 (call memory_leak_001_good)
> takes the false branch, At N49 of Function memory_leak_001_good
> Leaving function: memory_leak_001_good, On N39 -> N5 (Return edge from memory_leak_001_good to main)
> Entering function: memory_leak_001_bad, On N5 -> N9 (call memory_leak_001_bad)
> takes the true branch, At N18 of Function memory_leak_001_bad
> takes the true branch, At N23 of Function memory_leak_001_bad
> takes the false branch, At N18 of Function memory_leak_001_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_001_bad to main]
N8 -> N6: [Return edge from memory_leak_001_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N25
On edge  : N25 -{%arrayidx = getelementptr inbounds i8, i8* %2, i64 0}-> N26
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_001_good, On N4 -> N40 (call memory_leak_001_good)
> takes the false branch, At N49 of Function memory_leak_001_good
> Leaving function: memory_leak_001_good, On N39 -> N5 (Return edge from memory_leak_001_good to main)
> Entering function: memory_leak_001_bad, On N5 -> N9 (call memory_leak_001_bad)
> takes the true branch, At N18 of Function memory_leak_001_bad
> takes the false branch, At N23 of Function memory_leak_001_bad
> takes the true branch, At N18 of Function memory_leak_001_bad
> takes the true branch, At N23 of Function memory_leak_001_bad
<Defect> : N25 -> N26: [%arrayidx = getelementptr inbounds i8, i8* %2, i64 0]
N25 -> N26: [%arrayidx = getelementptr inbounds i8, i8* %2, i64 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N26
On edge  : N26 -{store i8 1, i8* %arrayidx, align 1}-> N29
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_001_good, On N4 -> N40 (call memory_leak_001_good)
> takes the false branch, At N49 of Function memory_leak_001_good
> Leaving function: memory_leak_001_good, On N39 -> N5 (Return edge from memory_leak_001_good to main)
> Entering function: memory_leak_001_bad, On N5 -> N9 (call memory_leak_001_bad)
> takes the true branch, At N18 of Function memory_leak_001_bad
> takes the false branch, At N23 of Function memory_leak_001_bad
> takes the true branch, At N18 of Function memory_leak_001_bad
> takes the true branch, At N23 of Function memory_leak_001_bad
<Defect> : N26 -> N29: [store i8 1, i8* %arrayidx, align 1]
N26 -> N29: [store i8 1, i8* %arrayidx, align 1] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_1.c 58] memory_leak_001_bad 		[N8 -{Return edge from memory_leak_001_bad to main}-> N6]	(the heap object @H(memory_leak_001_bad::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 2
	[./401_memory_leak_1.c 26] memory_leak_001_bad 		[N25 -{%arrayidx = getelementptr inbounds i8, i8* %2, i64 0}-> N26]	(null pointer dereference)
	[./401_memory_leak_1.c 26] memory_leak_001_bad 		[N26 -{store i8 1, i8* %arrayidx, align 1}-> N29]	(null pointer dereference)

Found 3 defects in all (38 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_007_func_001_bad]
 +memory_leak_007_func_001_bad
SCC(1): [memory_leak_007_bad]
 +memory_leak_007_bad
SCC(1): [memory_leak_007_func_001_good]
 +memory_leak_007_func_001_good
SCC(1): [memory_leak_007_good]
 +memory_leak_007_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_007_func_001_bad::call2) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_007_good, On N4 -> N160 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N164 -> N96 (call memory_leak_007_func_001_good)
> matches the value of 1, At N102 of Function memory_leak_007_func_001_good
> matches the value of 2, At N148 of Function memory_leak_007_func_001_good
> takes the true branch, At N121 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N95 -> N165 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the false branch, At N168 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N159 -> N5 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N5 -> N9 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N13 -> N32 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N38 of Function memory_leak_007_func_001_bad
> matches the value of 2, At N84 of Function memory_leak_007_func_001_bad
> takes the true branch, At N57 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N31 -> N14 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N17 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N8 -> N6 (Return edge from memory_leak_007_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_007_func_001_good::call2) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_007_good, On N4 -> N160 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N164 -> N96 (call memory_leak_007_func_001_good)
> matches the value of 1, At N102 of Function memory_leak_007_func_001_good
> matches the value of 2, At N148 of Function memory_leak_007_func_001_good
> takes the true branch, At N121 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N95 -> N165 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the false branch, At N168 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N159 -> N5 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N5 -> N9 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N13 -> N32 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N38 of Function memory_leak_007_func_001_bad
> matches the value of 2, At N84 of Function memory_leak_007_func_001_bad
> takes the true branch, At N57 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N31 -> N14 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N17 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N8 -> N6 (Return edge from memory_leak_007_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_007_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_007_good, On N4 -> N160 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N164 -> N96 (call memory_leak_007_func_001_good)
> matches the value of 1, At N102 of Function memory_leak_007_func_001_good
> matches the value of 2, At N148 of Function memory_leak_007_func_001_good
> takes the true branch, At N121 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N95 -> N165 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the false branch, At N168 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N159 -> N5 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N5 -> N9 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N13 -> N32 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N38 of Function memory_leak_007_func_001_bad
> takes the true branch, At N45 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N31 -> N14 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N17 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N8 -> N6 (Return edge from memory_leak_007_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N6
On edge  : N6 -{ret i32 0}-> N0
Message  : the heap object @H(memory_leak_007_func_001_good::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_007_good, On N4 -> N160 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N164 -> N96 (call memory_leak_007_func_001_good)
> matches the value of 1, At N102 of Function memory_leak_007_func_001_good
> takes the true branch, At N109 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N95 -> N165 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the false branch, At N168 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N159 -> N5 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N5 -> N9 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N13 -> N32 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N38 of Function memory_leak_007_func_001_bad
> matches the value of 2, At N84 of Function memory_leak_007_func_001_bad
> takes the true branch, At N57 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N31 -> N14 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N17 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N8 -> N6 (Return edge from memory_leak_007_bad to main)
<Defect> : N6 -> N0: [ret i32 0]
N6 -> N0: [ret i32 0] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 4
	[./401_memory_leak_7.c 129] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_007_func_001_bad::call2) is not referenced any more)
	[./401_memory_leak_7.c 129] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_007_func_001_good::call2) is not referenced any more)
	[./401_memory_leak_7.c 129] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_007_func_001_bad::call) is not referenced any more)
	[./401_memory_leak_7.c 129] main 		[N6 -{ret i32 0}-> N0]	(the heap object @H(memory_leak_007_func_001_good::call) is not referenced any more)

Found 4 defects in all (8 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_006_func_001_good]
 +memory_leak_006_func_001_good
SCC(1): [memory_leak_006_good]
 +memory_leak_006_good
SCC(1): [memory_leak_006_func_001_bad]
 +memory_leak_006_func_001_bad
SCC(1): [memory_leak_006_bad]
 +memory_leak_006_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.121s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N36
On edge  : N36 -{call void @free(i8* %6, i8* @free)}-> N38
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_006_good, On N4 -> N85 (call memory_leak_006_good)
> Entering function: memory_leak_006_func_001_good, On N92 -> N66 (call memory_leak_006_func_001_good)
> takes the false branch, At N74 of Function memory_leak_006_func_001_good
> Leaving function: memory_leak_006_func_001_good, On N65 -> N93 (Return edge from memory_leak_006_func_001_good to memory_leak_006_good)
> takes the false branch, At N94 of Function memory_leak_006_good
> Leaving function: memory_leak_006_good, On N84 -> N5 (Return edge from memory_leak_006_good to main)
> Entering function: memory_leak_006_bad, On N5 -> N9 (call memory_leak_006_bad)
> Entering function: memory_leak_006_func_001_bad, On N16 -> N47 (call memory_leak_006_func_001_bad)
> takes the false branch, At N55 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N46 -> N17 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the false branch, At N18 of Function memory_leak_006_bad
> Entering function: memory_leak_006_func_001_bad, On N31 -> N47 (call memory_leak_006_func_001_bad)
> takes the false branch, At N55 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N46 -> N32 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the true branch, At N33 of Function memory_leak_006_bad
<Defect> : N36 -> N38: [call void @free(i8* %6, i8* @free)]
N36 -> N38: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_006_bad to main}-> N6
Message  : the heap object @H(memory_leak_006_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_006_good, On N4 -> N85 (call memory_leak_006_good)
> Entering function: memory_leak_006_func_001_good, On N92 -> N66 (call memory_leak_006_func_001_good)
> takes the false branch, At N74 of Function memory_leak_006_func_001_good
> Leaving function: memory_leak_006_func_001_good, On N65 -> N93 (Return edge from memory_leak_006_func_001_good to memory_leak_006_good)
> takes the false branch, At N94 of Function memory_leak_006_good
> Leaving function: memory_leak_006_good, On N84 -> N5 (Return edge from memory_leak_006_good to main)
> Entering function: memory_leak_006_bad, On N5 -> N9 (call memory_leak_006_bad)
> Entering function: memory_leak_006_func_001_bad, On N16 -> N47 (call memory_leak_006_func_001_bad)
> takes the false branch, At N55 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N46 -> N17 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the true branch, At N18 of Function memory_leak_006_bad
> takes the true branch, At N24 of Function memory_leak_006_bad
> Entering function: memory_leak_006_func_001_bad, On N31 -> N47 (call memory_leak_006_func_001_bad)
> takes the false branch, At N55 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N46 -> N32 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the false branch, At N33 of Function memory_leak_006_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_006_bad to main]
N8 -> N6: [Return edge from memory_leak_006_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_6.c 41] memory_leak_006_bad 		[N36 -{call void @free(i8* %6, i8* @free)}-> N38]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_6.c 82] memory_leak_006_bad 		[N8 -{Return edge from memory_leak_006_bad to main}-> N6]	(the heap object @H(memory_leak_006_bad::call1) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0013_good]
 +memory_leak_0013_good
SCC(1): [memory_leak_0013_bad]
 +memory_leak_0013_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.118s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0013_bad to main}-> N6
Message  : the heap object @H(memory_leak_0013_bad::call2) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0013_good, On N4 -> N55 (call memory_leak_0013_good)
> takes the false branch, At N64 of Function memory_leak_0013_good
> takes the false branch, At N75 of Function memory_leak_0013_good
> Leaving function: memory_leak_0013_good, On N54 -> N5 (Return edge from memory_leak_0013_good to main)
> Entering function: memory_leak_0013_bad, On N5 -> N9 (call memory_leak_0013_bad)
> takes the false branch, At N18 of Function memory_leak_0013_bad
> takes the false branch, At N31 of Function memory_leak_0013_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0013_bad to main]
N8 -> N6: [Return edge from memory_leak_0013_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N81
On edge  : N81 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N82
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0013_good, On N4 -> N55 (call memory_leak_0013_good)
> takes the true branch, At N64 of Function memory_leak_0013_good
> takes the true branch, At N75 of Function memory_leak_0013_good
<Defect> : N81 -> N82: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0]
N81 -> N82: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N37
On edge  : N37 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N38
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0013_good, On N4 -> N55 (call memory_leak_0013_good)
> takes the false branch, At N64 of Function memory_leak_0013_good
> takes the false branch, At N75 of Function memory_leak_0013_good
> Leaving function: memory_leak_0013_good, On N54 -> N5 (Return edge from memory_leak_0013_good to main)
> Entering function: memory_leak_0013_bad, On N5 -> N9 (call memory_leak_0013_bad)
> takes the true branch, At N18 of Function memory_leak_0013_bad
> takes the true branch, At N31 of Function memory_leak_0013_bad
<Defect> : N37 -> N38: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0]
N37 -> N38: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_13.c 89] memory_leak_0013_bad 		[N8 -{Return edge from memory_leak_0013_bad to main}-> N6]	(the heap object @H(memory_leak_0013_bad::call2) is not referenced any more)

CWE_476(Null Pointer Dereference): 2
	[./401_memory_leak_13.c 74] memory_leak_0013_good 		[N81 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N82]	(null pointer dereference)
	[./401_memory_leak_13.c 51] memory_leak_0013_bad 		[N37 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N38]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0010_bad]
 +memory_leak_0010_bad
SCC(1): [memory_leak_0010_good]
 +memory_leak_0010_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0010_bad to main}-> N6
Message  : the heap object @H(memory_leak_0010_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0010_good, On N4 -> N43 (call memory_leak_0010_good)
> takes the false branch, At N57 of Function memory_leak_0010_good
> Leaving function: memory_leak_0010_good, On N42 -> N5 (Return edge from memory_leak_0010_good to main)
> Entering function: memory_leak_0010_bad, On N5 -> N9 (call memory_leak_0010_bad)
> takes the false branch, At N19 of Function memory_leak_0010_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0010_bad to main]
N8 -> N6: [Return edge from memory_leak_0010_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_10.c 58] memory_leak_0010_bad 		[N8 -{Return edge from memory_leak_0010_bad to main}-> N6]	(the heap object @H(memory_leak_0010_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_008_good]
 +memory_leak_008_good
SCC(1): [memory_leak_008_bad]
 +memory_leak_008_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.102s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_008_bad to main}-> N6
Message  : the heap object @H(memory_leak_008_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_008_good, On N4 -> N37 (call memory_leak_008_good)
> takes the false branch, At N48 of Function memory_leak_008_good
> Leaving function: memory_leak_008_good, On N36 -> N5 (Return edge from memory_leak_008_good to main)
> Entering function: memory_leak_008_bad, On N5 -> N9 (call memory_leak_008_bad)
> takes the false branch, At N22 of Function memory_leak_008_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_008_bad to main]
N8 -> N6: [Return edge from memory_leak_008_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_8.c 54] memory_leak_008_bad 		[N8 -{Return edge from memory_leak_008_bad to main}-> N6]	(the heap object @H(memory_leak_008_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0011_good]
 +memory_leak_0011_good
SCC(1): [memory_leak_0011_bad]
 +memory_leak_0011_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.09s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0011_bad to main}-> N6
Message  : the heap object @H(memory_leak_0011_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0011_good, On N4 -> N31 (call memory_leak_0011_good)
> takes the false branch, At N42 of Function memory_leak_0011_good
> Leaving function: memory_leak_0011_good, On N30 -> N5 (Return edge from memory_leak_0011_good to main)
> Entering function: memory_leak_0011_bad, On N5 -> N9 (call memory_leak_0011_bad)
> takes the true branch, At N19 of Function memory_leak_0011_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0011_bad to main]
N8 -> N6: [Return edge from memory_leak_0011_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_11.c 64] memory_leak_0011_bad 		[N8 -{Return edge from memory_leak_0011_bad to main}-> N6]	(the heap object @H(memory_leak_0011_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/401/401_memory_leak_15.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_0015_func_001_good]
 +memory_leak_0015_func_001_good
SCC(1): [memory_leak_0015_good]
 +memory_leak_0015_good
SCC(1): [memory_leak_0015_func_001_bad]
 +memory_leak_0015_func_001_bad
SCC(1): [memory_leak_0015_bad]
 +memory_leak_0015_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.099s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0015_bad to main}-> N6
Message  : the heap object @H(memory_leak_0015_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0015_good, On N4 -> N64 (call memory_leak_0015_good)
> Entering function: memory_leak_0015_func_001_good, On N73 -> N48 (call memory_leak_0015_func_001_good)
> Leaving function: memory_leak_0015_func_001_good, On N47 -> N74 (Return edge from memory_leak_0015_func_001_good to memory_leak_0015_good)
> takes the false branch, At N77 of Function memory_leak_0015_good
> Leaving function: memory_leak_0015_good, On N63 -> N5 (Return edge from memory_leak_0015_good to main)
> Entering function: memory_leak_0015_bad, On N5 -> N9 (call memory_leak_0015_bad)
> Entering function: memory_leak_0015_func_001_bad, On N18 -> N32 (call memory_leak_0015_func_001_bad)
> Leaving function: memory_leak_0015_func_001_bad, On N31 -> N19 (Return edge from memory_leak_0015_func_001_bad to memory_leak_0015_bad)
> takes the true branch, At N22 of Function memory_leak_0015_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0015_bad to main]
N8 -> N6: [Return edge from memory_leak_0015_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_15.c 63] memory_leak_0015_bad 		[N8 -{Return edge from memory_leak_0015_bad to main}-> N6]	(the heap object @H(memory_leak_0015_func_001_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_13.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [null_pointer_013_func_001_bad]
 +null_pointer_013_func_001_bad
SCC(1): [null_pointer_013_bad]
 +null_pointer_013_bad
SCC(1): [null_pointer_013_func_001_good]
 +null_pointer_013_func_001_good
SCC(1): [null_pointer_013_good]
 +null_pointer_013_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.103s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N21
On edge  : N21 -{store i32 2, i32* %2, align 4}-> N22
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_013_good, On N4 -> N35 (call null_pointer_013_good)
> Entering function: null_pointer_013_func_001_good, On N38 -> N31 (call null_pointer_013_func_001_good)
> Leaving function: null_pointer_013_func_001_good, On N30 -> N39 (Return edge from null_pointer_013_func_001_good to null_pointer_013_good)
> takes the true branch, At N42 of Function null_pointer_013_good
> Leaving function: null_pointer_013_good, On N34 -> N5 (Return edge from null_pointer_013_good to main)
> Entering function: null_pointer_013_bad, On N5 -> N9 (call null_pointer_013_bad)
> Entering function: null_pointer_013_func_001_bad, On N12 -> N27 (call null_pointer_013_func_001_bad)
> Leaving function: null_pointer_013_func_001_bad, On N26 -> N13 (Return edge from null_pointer_013_func_001_bad to null_pointer_013_bad)
> takes the false branch, At N16 of Function null_pointer_013_bad
<Defect> : N21 -> N22: [store i32 2, i32* %2, align 4]
N21 -> N22: [store i32 2, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_13.c 30] null_pointer_013_bad 		[N21 -{store i32 2, i32* %2, align 4}-> N22]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_011_good]
 +null_pointer_011_good
SCC(1): [null_pointer_011_bad]
 +null_pointer_011_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.075s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N22
On edge  : N22 -{store i32 1, i32* %2, align 4}-> N23
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_011_good, On N4 -> N26 (call null_pointer_011_good)
> Leaving function: null_pointer_011_good, On N25 -> N5 (Return edge from null_pointer_011_good to main)
> Entering function: null_pointer_011_bad, On N5 -> N9 (call null_pointer_011_bad)
<Defect> : N22 -> N23: [store i32 1, i32* %2, align 4]
N22 -> N23: [store i32 1, i32* %2, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_11.c 24] null_pointer_011_bad 		[N22 -{store i32 1, i32* %2, align 4}-> N23]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_002_bad]
 +null_pointer_002_bad
SCC(1): [null_pointer_002_good]
 +null_pointer_002_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.095s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N16
On edge  : N16 -{%1 = load i32, i32* %0, align 4}-> N17
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_002_good, On N4 -> N21 (call null_pointer_002_good)
> Leaving function: null_pointer_002_good, On N20 -> N5 (Return edge from null_pointer_002_good to main)
> Entering function: null_pointer_002_bad, On N5 -> N9 (call null_pointer_002_bad)
<Defect> : N16 -> N17: [%1 = load i32, i32* %0, align 4]
N16 -> N17: [%1 = load i32, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_2.c 21] null_pointer_002_bad 		[N16 -{%1 = load i32, i32* %0, align 4}-> N17]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_012_good]
 +null_pointer_012_good
SCC(1): [null_pointer_012_bad]
 +null_pointer_012_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.082s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N14
On edge  : N14 -{%arrayidx = getelementptr inbounds i32, i32* %0, i64 3}-> N15
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_012_good, On N4 -> N19 (call null_pointer_012_good)
> Leaving function: null_pointer_012_good, On N18 -> N5 (Return edge from null_pointer_012_good to main)
> Entering function: null_pointer_012_bad, On N5 -> N9 (call null_pointer_012_bad)
<Defect> : N14 -> N15: [%arrayidx = getelementptr inbounds i32, i32* %0, i64 3]
N14 -> N15: [%arrayidx = getelementptr inbounds i32, i32* %0, i64 3] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_12.c 20] null_pointer_012_bad 		[N14 -{%arrayidx = getelementptr inbounds i32, i32* %0, i64 3}-> N15]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_006_bad]
 +null_pointer_006_bad
SCC(1): [null_pointer_006_good]
 +null_pointer_006_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.084s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_005_good]
 +null_pointer_005_good
SCC(1): [null_pointer_005_bad]
 +null_pointer_005_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.074s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N15
On edge  : N15 -{%a = getelementptr inbounds %struct.null_pointer_005_s_001, %struct.null_pointer_005_s_001* %s1, i32 0, i32 0}-> N16
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_005_good, On N4 -> N20 (call null_pointer_005_good)
> Leaving function: null_pointer_005_good, On N19 -> N5 (Return edge from null_pointer_005_good to main)
> Entering function: null_pointer_005_bad, On N5 -> N9 (call null_pointer_005_bad)
<Defect> : N15 -> N16: [%a = getelementptr inbounds %struct.null_pointer_005_s_001, %struct.null_pointer_005_s_001* %s1, i32 0, i32 0]
N15 -> N16: [%a = getelementptr inbounds %struct.null_pointer_005_s_001, %struct.null_pointer_005_s_001* %s1, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_5.c 41] null_pointer_005_bad 		[N15 -{%a = getelementptr inbounds %struct.null_pointer_005_s_001, %struct.null_pointer_005_s_001* %s1, i32 0, i32 0}-> N16]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_004_good]
 +null_pointer_004_good
SCC(1): [null_pointer_004_bad]
 +null_pointer_004_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.085s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N14
On edge  : N14 -{%a = getelementptr inbounds %struct.null_pointer_004_s_001, %struct.null_pointer_004_s_001* %0, i32 0, i32 0}-> N15
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_004_good, On N4 -> N19 (call null_pointer_004_good)
> Leaving function: null_pointer_004_good, On N18 -> N5 (Return edge from null_pointer_004_good to main)
> Entering function: null_pointer_004_bad, On N5 -> N9 (call null_pointer_004_bad)
<Defect> : N14 -> N15: [%a = getelementptr inbounds %struct.null_pointer_004_s_001, %struct.null_pointer_004_s_001* %0, i32 0, i32 0]
N14 -> N15: [%a = getelementptr inbounds %struct.null_pointer_004_s_001, %struct.null_pointer_004_s_001* %0, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_4.c 26] null_pointer_004_bad 		[N14 -{%a = getelementptr inbounds %struct.null_pointer_004_s_001, %struct.null_pointer_004_s_001* %0, i32 0, i32 0}-> N15]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_007_good]
 +null_pointer_007_good
SCC(1): [null_pointer_007_bad]
 +null_pointer_007_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.076s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
=====================================================
Found 0 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_003_bad]
 +null_pointer_003_bad
SCC(1): [null_pointer_003_good]
 +null_pointer_003_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.078s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N18
On edge  : N18 -{store i32 1, i32* %1, align 4}-> N19
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_003_good, On N4 -> N22 (call null_pointer_003_good)
> Leaving function: null_pointer_003_good, On N21 -> N5 (Return edge from null_pointer_003_good to main)
> Entering function: null_pointer_003_bad, On N5 -> N9 (call null_pointer_003_bad)
<Defect> : N18 -> N19: [store i32 1, i32* %1, align 4]
N18 -> N19: [store i32 1, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_3.c 22] null_pointer_003_bad 		[N18 -{store i32 1, i32* %1, align 4}-> N19]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_001_bad]
 +null_pointer_001_bad
SCC(1): [null_pointer_001_good]
 +null_pointer_001_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.079s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N14
On edge  : N14 -{store i32 1, i32* %0, align 4}-> N15
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_001_good, On N4 -> N18 (call null_pointer_001_good)
> Leaving function: null_pointer_001_good, On N17 -> N5 (Return edge from null_pointer_001_good to main)
> Entering function: null_pointer_001_bad, On N5 -> N9 (call null_pointer_001_bad)
<Defect> : N14 -> N15: [store i32 1, i32* %0, align 4]
N14 -> N15: [store i32 1, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_1.c 20] null_pointer_001_bad 		[N14 -{store i32 1, i32* %0, align 4}-> N15]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [null_pointer_010_good]
 +null_pointer_010_good
SCC(1): [null_pointer_010_bad]
 +null_pointer_010_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.081s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N18
On edge  : N18 -{store i32 1, i32* %1, align 4}-> N19
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_010_good, On N4 -> N22 (call null_pointer_010_good)
> Leaving function: null_pointer_010_good, On N21 -> N5 (Return edge from null_pointer_010_good to main)
> Entering function: null_pointer_010_bad, On N5 -> N9 (call null_pointer_010_bad)
<Defect> : N18 -> N19: [store i32 1, i32* %1, align 4]
N18 -> N19: [store i32 1, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_10.c 24] null_pointer_010_bad 		[N18 -{store i32 1, i32* %1, align 4}-> N19]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [null_pointer_008_func_001_bad]
 +null_pointer_008_func_001_bad
SCC(1): [null_pointer_008_bad]
 +null_pointer_008_bad
SCC(1): [null_pointer_008_func_001_good]
 +null_pointer_008_func_001_good
SCC(1): [null_pointer_008_good]
 +null_pointer_008_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.085s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N15
On edge  : N15 -{store i32 1, i32* %0, align 4}-> N16
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_008_good, On N4 -> N27 (call null_pointer_008_good)
> Entering function: null_pointer_008_func_001_good, On N30 -> N23 (call null_pointer_008_func_001_good)
> Leaving function: null_pointer_008_func_001_good, On N22 -> N31 (Return edge from null_pointer_008_func_001_good to null_pointer_008_good)
> Leaving function: null_pointer_008_good, On N26 -> N5 (Return edge from null_pointer_008_good to main)
> Entering function: null_pointer_008_bad, On N5 -> N9 (call null_pointer_008_bad)
> Entering function: null_pointer_008_func_001_bad, On N12 -> N19 (call null_pointer_008_func_001_bad)
> Leaving function: null_pointer_008_func_001_bad, On N18 -> N13 (Return edge from null_pointer_008_func_001_bad to null_pointer_008_bad)
<Defect> : N15 -> N16: [store i32 1, i32* %0, align 4]
N15 -> N16: [store i32 1, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_8.c 26] null_pointer_008_bad 		[N15 -{store i32 1, i32* %0, align 4}-> N16]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/476/476_null_pointer_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [null_pointer_009_func_001_good]
 +null_pointer_009_func_001_good
SCC(1): [null_pointer_009_good]
 +null_pointer_009_good
SCC(1): [null_pointer_009_func_001_bad]
 +null_pointer_009_func_001_bad
SCC(1): [null_pointer_009_bad]
 +null_pointer_009_bad
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.088s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N19
On edge  : N19 -{store i32 1, i32* %0, align 4}-> N20
Message  : null pointer dereference
> Start from entry function: main, At N1 of Function main
> Entering function: null_pointer_009_good, On N4 -> N32 (call null_pointer_009_good)
> Entering function: null_pointer_009_func_001_good, On N36 -> N23 (call null_pointer_009_func_001_good)
> Leaving function: null_pointer_009_func_001_good, On N22 -> N37 (Return edge from null_pointer_009_func_001_good to null_pointer_009_good)
> Leaving function: null_pointer_009_good, On N31 -> N5 (Return edge from null_pointer_009_good to main)
> Entering function: null_pointer_009_bad, On N5 -> N9 (call null_pointer_009_bad)
> Entering function: null_pointer_009_func_001_bad, On N9 -> N14 (call null_pointer_009_func_001_bad)
<Defect> : N19 -> N20: [store i32 1, i32* %0, align 4]
N19 -> N20: [store i32 1, i32* %0, align 4] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./476_null_pointer_9.c 19] null_pointer_009_func_001_bad 		[N19 -{store i32 1, i32* %0, align 4}-> N20]	(null pointer dereference)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_9.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_009_bad]
 +double_free_009_bad
SCC(1): [double_free_009_good]
 +double_free_009_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.108s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N65): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N50
On edge  : N50 -{call void @free(i8* %2, i8* @free)}-> N51
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the false branch, At N41 of Function double_free_009_good
> takes the true branch, At N48 of Function double_free_009_good
> takes the true branch, At N48 of Function double_free_009_good
<Defect> : N50 -> N51: [call void @free(i8* %2, i8* @free)]
N50 -> N51: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N56
On edge  : N56 -{call void @free(i8* %4, i8* @free)}-> N58
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the false branch, At N41 of Function double_free_009_good
> takes the true branch, At N48 of Function double_free_009_good
> takes the false branch, At N48 of Function double_free_009_good
<Defect> : N56 -> N58: [call void @free(i8* %4, i8* @free)]
N56 -> N58: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N18
On edge  : N18 -{call void @free(i8* %2, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the true branch, At N41 of Function double_free_009_good
> Leaving function: double_free_009_good, On N32 -> N69 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N69 -> N1 (call double_free_009_bad)
> takes the false branch, At N9 of Function double_free_009_bad
> takes the true branch, At N16 of Function double_free_009_bad
> takes the true branch, At N16 of Function double_free_009_bad
<Defect> : N18 -> N19: [call void @free(i8* %2, i8* @free)]
N18 -> N19: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the true branch, At N41 of Function double_free_009_good
> Leaving function: double_free_009_good, On N32 -> N69 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N69 -> N1 (call double_free_009_bad)
> takes the false branch, At N9 of Function double_free_009_bad
> takes the true branch, At N16 of Function double_free_009_bad
> takes the false branch, At N16 of Function double_free_009_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N50
On edge  : N50 -{call void @free(i8* %2, i8* @free)}-> N51
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the false branch, At N41 of Function double_free_009_good
> takes the true branch, At N48 of Function double_free_009_good
> takes the true branch, At N48 of Function double_free_009_good
<Defect> : N50 -> N51: [call void @free(i8* %2, i8* @free)]
N50 -> N51: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N56
On edge  : N56 -{call void @free(i8* %4, i8* @free)}-> N58
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the false branch, At N41 of Function double_free_009_good
> takes the true branch, At N48 of Function double_free_009_good
> takes the false branch, At N48 of Function double_free_009_good
<Defect> : N56 -> N58: [call void @free(i8* %4, i8* @free)]
N56 -> N58: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N18
On edge  : N18 -{call void @free(i8* %2, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the true branch, At N41 of Function double_free_009_good
> Leaving function: double_free_009_good, On N32 -> N69 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N69 -> N1 (call double_free_009_bad)
> takes the false branch, At N9 of Function double_free_009_bad
> takes the true branch, At N16 of Function double_free_009_bad
> takes the true branch, At N16 of Function double_free_009_bad
<Defect> : N18 -> N19: [call void @free(i8* %2, i8* @free)]
N18 -> N19: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N65 of Function main
> Entering function: double_free_009_good, On N68 -> N33 (call double_free_009_good)
> takes the true branch, At N41 of Function double_free_009_good
> Leaving function: double_free_009_good, On N32 -> N69 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N69 -> N1 (call double_free_009_bad)
> takes the false branch, At N9 of Function double_free_009_bad
> takes the true branch, At N16 of Function double_free_009_bad
> takes the false branch, At N16 of Function double_free_009_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 4
	[./415_double_free_9.c 45] double_free_009_good 		[N50 -{call void @free(i8* %2, i8* @free)}-> N51]	(the memory is already freed)
	[./415_double_free_9.c 48] double_free_009_good 		[N56 -{call void @free(i8* %4, i8* @free)}-> N58]	(the memory is already freed)
	[./415_double_free_9.c 26] double_free_009_bad 		[N18 -{call void @free(i8* %2, i8* @free)}-> N19]	(the memory is already freed)
	[./415_double_free_9.c 29] double_free_009_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 4
	[./415_double_free_9.c 45] double_free_009_good 		[N50 -{call void @free(i8* %2, i8* @free)}-> N51]	(the memory is already freed)
	[./415_double_free_9.c 48] double_free_009_good 		[N56 -{call void @free(i8* %4, i8* @free)}-> N58]	(the memory is already freed)
	[./415_double_free_9.c 26] double_free_009_bad 		[N18 -{call void @free(i8* %2, i8* @free)}-> N19]	(the memory is already freed)
	[./415_double_free_9.c 29] double_free_009_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

Found 8 defects in all (72 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_2.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_002_bad]
 +double_free_002_bad
SCC(1): [double_free_002_good]
 +double_free_002_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.131s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N89): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N65
On edge  : N65 -{store i8 97, i8* %arrayidx, align 1}-> N66
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the false branch, At N53 of Function double_free_002_good
> takes the true branch, At N60 of Function double_free_002_good
> takes the true branch, At N68 of Function double_free_002_good
> takes the true branch, At N60 of Function double_free_002_good
<Defect> : N65 -> N66: [store i8 97, i8* %arrayidx, align 1]
N65 -> N66: [store i8 97, i8* %arrayidx, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N73
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the false branch, At N53 of Function double_free_002_good
> takes the true branch, At N60 of Function double_free_002_good
> takes the true branch, At N68 of Function double_free_002_good
> takes the true branch, At N60 of Function double_free_002_good
> takes the true branch, At N68 of Function double_free_002_good
<Defect> : N70 -> N73: [call void @free(i8* %5, i8* @free)]
N70 -> N73: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N78
On edge  : N78 -{call void @free(i8* %7, i8* @free)}-> N80
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the false branch, At N53 of Function double_free_002_good
> takes the true branch, At N60 of Function double_free_002_good
> takes the true branch, At N68 of Function double_free_002_good
> takes the false branch, At N60 of Function double_free_002_good
<Defect> : N78 -> N80: [call void @free(i8* %7, i8* @free)]
N78 -> N80: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{store i8 97, i8* %arrayidx, align 1}-> N22
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the true branch, At N53 of Function double_free_002_good
> Leaving function: double_free_002_good, On N44 -> N93 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N93 -> N1 (call double_free_002_bad)
> takes the false branch, At N9 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
<Defect> : N21 -> N22: [store i8 97, i8* %arrayidx, align 1]
N21 -> N22: [store i8 97, i8* %arrayidx, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N26
On edge  : N26 -{call void @free(i8* %5, i8* @free)}-> N29
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the true branch, At N53 of Function double_free_002_good
> Leaving function: double_free_002_good, On N44 -> N93 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N93 -> N1 (call double_free_002_bad)
> takes the false branch, At N9 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
<Defect> : N26 -> N29: [call void @free(i8* %5, i8* @free)]
N26 -> N29: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N34
On edge  : N34 -{call void @free(i8* %7, i8* @free)}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the true branch, At N53 of Function double_free_002_good
> Leaving function: double_free_002_good, On N44 -> N93 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N93 -> N1 (call double_free_002_bad)
> takes the false branch, At N9 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
> takes the false branch, At N16 of Function double_free_002_bad
<Defect> : N34 -> N36: [call void @free(i8* %7, i8* @free)]
N34 -> N36: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N70
On edge  : N70 -{call void @free(i8* %5, i8* @free)}-> N73
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the false branch, At N53 of Function double_free_002_good
> takes the true branch, At N60 of Function double_free_002_good
> takes the true branch, At N68 of Function double_free_002_good
> takes the true branch, At N60 of Function double_free_002_good
> takes the true branch, At N68 of Function double_free_002_good
<Defect> : N70 -> N73: [call void @free(i8* %5, i8* @free)]
N70 -> N73: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N78
On edge  : N78 -{call void @free(i8* %7, i8* @free)}-> N80
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the false branch, At N53 of Function double_free_002_good
> takes the true branch, At N60 of Function double_free_002_good
> takes the true branch, At N68 of Function double_free_002_good
> takes the false branch, At N60 of Function double_free_002_good
<Defect> : N78 -> N80: [call void @free(i8* %7, i8* @free)]
N78 -> N80: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N26
On edge  : N26 -{call void @free(i8* %5, i8* @free)}-> N29
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the true branch, At N53 of Function double_free_002_good
> Leaving function: double_free_002_good, On N44 -> N93 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N93 -> N1 (call double_free_002_bad)
> takes the false branch, At N9 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
<Defect> : N26 -> N29: [call void @free(i8* %5, i8* @free)]
N26 -> N29: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N34
On edge  : N34 -{call void @free(i8* %7, i8* @free)}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N89 of Function main
> Entering function: double_free_002_good, On N92 -> N45 (call double_free_002_good)
> takes the true branch, At N53 of Function double_free_002_good
> Leaving function: double_free_002_good, On N44 -> N93 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N93 -> N1 (call double_free_002_bad)
> takes the false branch, At N9 of Function double_free_002_bad
> takes the true branch, At N16 of Function double_free_002_bad
> takes the true branch, At N24 of Function double_free_002_bad
> takes the false branch, At N16 of Function double_free_002_bad
<Defect> : N34 -> N36: [call void @free(i8* %7, i8* @free)]
N34 -> N36: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 6
	[./415_double_free_2.c 48] double_free_002_good 		[N65 -{store i8 97, i8* %arrayidx, align 1}-> N66]	(the memory is already freed)
	[./415_double_free_2.c 50] double_free_002_good 		[N70 -{call void @free(i8* %5, i8* @free)}-> N73]	(the memory is already freed)
	[./415_double_free_2.c 52] double_free_002_good 		[N78 -{call void @free(i8* %7, i8* @free)}-> N80]	(the memory is already freed)
	[./415_double_free_2.c 26] double_free_002_bad 		[N21 -{store i8 97, i8* %arrayidx, align 1}-> N22]	(the memory is already freed)
	[./415_double_free_2.c 29] double_free_002_bad 		[N26 -{call void @free(i8* %5, i8* @free)}-> N29]	(the memory is already freed)
	[./415_double_free_2.c 32] double_free_002_bad 		[N34 -{call void @free(i8* %7, i8* @free)}-> N36]	(the memory is already freed)

CWE_415(Double Free): 4
	[./415_double_free_2.c 50] double_free_002_good 		[N70 -{call void @free(i8* %5, i8* @free)}-> N73]	(the memory is already freed)
	[./415_double_free_2.c 52] double_free_002_good 		[N78 -{call void @free(i8* %7, i8* @free)}-> N80]	(the memory is already freed)
	[./415_double_free_2.c 29] double_free_002_bad 		[N26 -{call void @free(i8* %5, i8* @free)}-> N29]	(the memory is already freed)
	[./415_double_free_2.c 32] double_free_002_bad 		[N34 -{call void @free(i8* %7, i8* @free)}-> N36]	(the memory is already freed)

Found 10 defects in all (108 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_7.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_007_bad]
 +double_free_007_bad
SCC(1): [double_free_007_good]
 +double_free_007_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.093s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N57): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N48
On edge  : N48 -{call void @free(i8* %3, i8* @free)}-> N50
Message  : the memory is already freed
> Start from entry function: main, At N57 of Function main
> Entering function: double_free_007_good, On N60 -> N29 (call double_free_007_good)
> takes the false branch, At N37 of Function double_free_007_good
> takes the true branch, At N43 of Function double_free_007_good
<Defect> : N48 -> N50: [call void @free(i8* %3, i8* @free)]
N48 -> N50: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N20
On edge  : N20 -{call void @free(i8* %3, i8* @free)}-> N22
Message  : the memory is already freed
> Start from entry function: main, At N57 of Function main
> Entering function: double_free_007_good, On N60 -> N29 (call double_free_007_good)
> takes the true branch, At N37 of Function double_free_007_good
> Leaving function: double_free_007_good, On N28 -> N61 (Return edge from double_free_007_good to main)
> Entering function: double_free_007_bad, On N61 -> N1 (call double_free_007_bad)
> takes the false branch, At N9 of Function double_free_007_bad
> takes the true branch, At N15 of Function double_free_007_bad
<Defect> : N20 -> N22: [call void @free(i8* %3, i8* @free)]
N20 -> N22: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N48
On edge  : N48 -{call void @free(i8* %3, i8* @free)}-> N50
Message  : the memory is already freed
> Start from entry function: main, At N57 of Function main
> Entering function: double_free_007_good, On N60 -> N29 (call double_free_007_good)
> takes the false branch, At N37 of Function double_free_007_good
> takes the true branch, At N43 of Function double_free_007_good
<Defect> : N48 -> N50: [call void @free(i8* %3, i8* @free)]
N48 -> N50: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N20
On edge  : N20 -{call void @free(i8* %3, i8* @free)}-> N22
Message  : the memory is already freed
> Start from entry function: main, At N57 of Function main
> Entering function: double_free_007_good, On N60 -> N29 (call double_free_007_good)
> takes the true branch, At N37 of Function double_free_007_good
> Leaving function: double_free_007_good, On N28 -> N61 (Return edge from double_free_007_good to main)
> Entering function: double_free_007_bad, On N61 -> N1 (call double_free_007_bad)
> takes the false branch, At N9 of Function double_free_007_bad
> takes the true branch, At N15 of Function double_free_007_bad
<Defect> : N20 -> N22: [call void @free(i8* %3, i8* @free)]
N20 -> N22: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 2
	[./415_double_free_7.c 44] double_free_007_good 		[N48 -{call void @free(i8* %3, i8* @free)}-> N50]	(the memory is already freed)
	[./415_double_free_7.c 27] double_free_007_bad 		[N20 -{call void @free(i8* %3, i8* @free)}-> N22]	(the memory is already freed)

CWE_415(Double Free): 2
	[./415_double_free_7.c 44] double_free_007_good 		[N48 -{call void @free(i8* %3, i8* @free)}-> N50]	(the memory is already freed)
	[./415_double_free_7.c 27] double_free_007_bad 		[N20 -{call void @free(i8* %3, i8* @free)}-> N22]	(the memory is already freed)

Found 4 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_6.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_006_bad]
 +double_free_006_bad
SCC(1): [double_free_006_good]
 +double_free_006_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.083s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N37): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N13
On edge  : N13 -{call void @free(i8* %2, i8* @free)}-> N15
Message  : the memory is already freed
> Start from entry function: main, At N37 of Function main
> Entering function: double_free_006_good, On N40 -> N20 (call double_free_006_good)
> takes the true branch, At N27 of Function double_free_006_good
> Leaving function: double_free_006_good, On N19 -> N41 (Return edge from double_free_006_good to main)
> Entering function: double_free_006_bad, On N41 -> N1 (call double_free_006_bad)
> takes the false branch, At N8 of Function double_free_006_bad
<Defect> : N13 -> N15: [call void @free(i8* %2, i8* @free)]
N13 -> N15: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N13
On edge  : N13 -{call void @free(i8* %2, i8* @free)}-> N15
Message  : the memory is already freed
> Start from entry function: main, At N37 of Function main
> Entering function: double_free_006_good, On N40 -> N20 (call double_free_006_good)
> takes the true branch, At N27 of Function double_free_006_good
> Leaving function: double_free_006_good, On N19 -> N41 (Return edge from double_free_006_good to main)
> Entering function: double_free_006_bad, On N41 -> N1 (call double_free_006_bad)
> takes the false branch, At N8 of Function double_free_006_bad
<Defect> : N13 -> N15: [call void @free(i8* %2, i8* @free)]
N13 -> N15: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_6.c 25] double_free_006_bad 		[N13 -{call void @free(i8* %2, i8* @free)}-> N15]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_6.c 25] double_free_006_bad 		[N13 -{call void @free(i8* %2, i8* @free)}-> N15]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_8.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [double_free_function_008_bad]
 +double_free_function_008_bad
SCC(1): [double_free_008_bad]
 +double_free_008_bad
SCC(1): [double_free_function_008_good]
 +double_free_function_008_good
SCC(1): [double_free_008_good]
 +double_free_008_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.092s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N43): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N10
On edge  : N10 -{call void @free(i8* %1, i8* @free)}-> N12
Message  : the memory is already freed
> Start from entry function: main, At N43 of Function main
> Entering function: double_free_008_good, On N46 -> N17 (call double_free_008_good)
> takes the true branch, At N22 of Function double_free_008_good
> Leaving function: double_free_008_good, On N16 -> N47 (Return edge from double_free_008_good to main)
> Entering function: double_free_008_bad, On N47 -> N1 (call double_free_008_bad)
> takes the false branch, At N6 of Function double_free_008_bad
> Entering function: double_free_function_008_bad, On N15 -> N31 (call double_free_function_008_bad)
> Leaving function: double_free_function_008_bad, On N30 -> N9 (Return edge from double_free_function_008_bad to double_free_008_bad)
<Defect> : N10 -> N12: [call void @free(i8* %1, i8* @free)]
N10 -> N12: [call void @free(i8* %1, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N10
On edge  : N10 -{call void @free(i8* %1, i8* @free)}-> N12
Message  : the memory is already freed
> Start from entry function: main, At N43 of Function main
> Entering function: double_free_008_good, On N46 -> N17 (call double_free_008_good)
> takes the true branch, At N22 of Function double_free_008_good
> Leaving function: double_free_008_good, On N16 -> N47 (Return edge from double_free_008_good to main)
> Entering function: double_free_008_bad, On N47 -> N1 (call double_free_008_bad)
> takes the false branch, At N6 of Function double_free_008_bad
> Entering function: double_free_function_008_bad, On N15 -> N31 (call double_free_function_008_bad)
> Leaving function: double_free_function_008_bad, On N30 -> N9 (Return edge from double_free_function_008_bad to double_free_008_bad)
<Defect> : N10 -> N12: [call void @free(i8* %1, i8* @free)]
N10 -> N12: [call void @free(i8* %1, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_double_free_8.c 28] double_free_008_bad 		[N10 -{call void @free(i8* %1, i8* @free)}-> N12]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_double_free_8.c 28] double_free_008_bad 		[N10 -{call void @free(i8* %1, i8* @free)}-> N12]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_3.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_003_bad]
 +double_free_003_bad
SCC(1): [double_free_003_good]
 +double_free_003_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.119s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N81): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N21
On edge  : N21 -{store i8 97, i8* %add.ptr, align 1}-> N22
Message  : the memory is already freed
> Start from entry function: main, At N81 of Function main
> Entering function: double_free_003_good, On N84 -> N45 (call double_free_003_good)
> takes the true branch, At N53 of Function double_free_003_good
> Leaving function: double_free_003_good, On N44 -> N85 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N85 -> N1 (call double_free_003_bad)
> takes the false branch, At N9 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
<Defect> : N21 -> N22: [store i8 97, i8* %add.ptr, align 1]
N21 -> N22: [store i8 97, i8* %add.ptr, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N26
On edge  : N26 -{call void @free(i8* %5, i8* @free)}-> N29
Message  : the memory is already freed
> Start from entry function: main, At N81 of Function main
> Entering function: double_free_003_good, On N84 -> N45 (call double_free_003_good)
> takes the true branch, At N53 of Function double_free_003_good
> Leaving function: double_free_003_good, On N44 -> N85 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N85 -> N1 (call double_free_003_bad)
> takes the false branch, At N9 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
<Defect> : N26 -> N29: [call void @free(i8* %5, i8* @free)]
N26 -> N29: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N34
On edge  : N34 -{call void @free(i8* %7, i8* @free)}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N81 of Function main
> Entering function: double_free_003_good, On N84 -> N45 (call double_free_003_good)
> takes the true branch, At N53 of Function double_free_003_good
> Leaving function: double_free_003_good, On N44 -> N85 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N85 -> N1 (call double_free_003_bad)
> takes the false branch, At N9 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
> takes the false branch, At N16 of Function double_free_003_bad
<Defect> : N34 -> N36: [call void @free(i8* %7, i8* @free)]
N34 -> N36: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N26
On edge  : N26 -{call void @free(i8* %5, i8* @free)}-> N29
Message  : the memory is already freed
> Start from entry function: main, At N81 of Function main
> Entering function: double_free_003_good, On N84 -> N45 (call double_free_003_good)
> takes the true branch, At N53 of Function double_free_003_good
> Leaving function: double_free_003_good, On N44 -> N85 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N85 -> N1 (call double_free_003_bad)
> takes the false branch, At N9 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
<Defect> : N26 -> N29: [call void @free(i8* %5, i8* @free)]
N26 -> N29: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N34
On edge  : N34 -{call void @free(i8* %7, i8* @free)}-> N36
Message  : the memory is already freed
> Start from entry function: main, At N81 of Function main
> Entering function: double_free_003_good, On N84 -> N45 (call double_free_003_good)
> takes the true branch, At N53 of Function double_free_003_good
> Leaving function: double_free_003_good, On N44 -> N85 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N85 -> N1 (call double_free_003_bad)
> takes the false branch, At N9 of Function double_free_003_bad
> takes the true branch, At N16 of Function double_free_003_bad
> takes the true branch, At N24 of Function double_free_003_bad
> takes the false branch, At N16 of Function double_free_003_bad
<Defect> : N34 -> N36: [call void @free(i8* %7, i8* @free)]
N34 -> N36: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 3
	[./415_double_free_3.c 26] double_free_003_bad 		[N21 -{store i8 97, i8* %add.ptr, align 1}-> N22]	(the memory is already freed)
	[./415_double_free_3.c 29] double_free_003_bad 		[N26 -{call void @free(i8* %5, i8* @free)}-> N29]	(the memory is already freed)
	[./415_double_free_3.c 32] double_free_003_bad 		[N34 -{call void @free(i8* %7, i8* @free)}-> N36]	(the memory is already freed)

CWE_415(Double Free): 2
	[./415_double_free_3.c 29] double_free_003_bad 		[N26 -{call void @free(i8* %5, i8* @free)}-> N29]	(the memory is already freed)
	[./415_double_free_3.c 32] double_free_003_bad 		[N34 -{call void @free(i8* %7, i8* @free)}-> N36]	(the memory is already freed)

Found 5 defects in all (54 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_11.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_011_bad]
 +double_free_011_bad
SCC(1): [double_free_011_good]
 +double_free_011_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.135s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N85): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N70
On edge  : N70 -{call void @free(i8* %4, i8* @free)}-> N72
Message  : the memory is already freed
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the false branch, At N53 of Function double_free_011_good
> takes the true branch, At N65 of Function double_free_011_good
> takes the true branch, At N68 of Function double_free_011_good
> takes the true branch, At N65 of Function double_free_011_good
> takes the true branch, At N68 of Function double_free_011_good
<Defect> : N70 -> N72: [call void @free(i8* %4, i8* @free)]
N70 -> N72: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N28
On edge  : N28 -{call void @free(i8* %4, i8* @free)}-> N30
Message  : the memory is already freed
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the true branch, At N53 of Function double_free_011_good
> Leaving function: double_free_011_good, On N42 -> N89 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N89 -> N1 (call double_free_011_bad)
> takes the false branch, At N11 of Function double_free_011_bad
> takes the true branch, At N23 of Function double_free_011_bad
> takes the true branch, At N26 of Function double_free_011_bad
> takes the true branch, At N23 of Function double_free_011_bad
> takes the true branch, At N26 of Function double_free_011_bad
<Defect> : N28 -> N30: [call void @free(i8* %4, i8* @free)]
N28 -> N30: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N70
On edge  : N70 -{call void @free(i8* %4, i8* @free)}-> N72
Message  : the memory is already freed
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the false branch, At N53 of Function double_free_011_good
> takes the true branch, At N65 of Function double_free_011_good
> takes the true branch, At N68 of Function double_free_011_good
> takes the true branch, At N65 of Function double_free_011_good
> takes the true branch, At N68 of Function double_free_011_good
<Defect> : N70 -> N72: [call void @free(i8* %4, i8* @free)]
N70 -> N72: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N28
On edge  : N28 -{call void @free(i8* %4, i8* @free)}-> N30
Message  : the memory is already freed
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the true branch, At N53 of Function double_free_011_good
> Leaving function: double_free_011_good, On N42 -> N89 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N89 -> N1 (call double_free_011_bad)
> takes the false branch, At N11 of Function double_free_011_bad
> takes the true branch, At N23 of Function double_free_011_bad
> takes the true branch, At N26 of Function double_free_011_bad
> takes the true branch, At N23 of Function double_free_011_bad
> takes the true branch, At N26 of Function double_free_011_bad
<Defect> : N28 -> N30: [call void @free(i8* %4, i8* @free)]
N28 -> N30: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N42
On edge  : N42 -{Return edge from double_free_011_good to main}-> N89
Message  : the heap object @H(double_free_011_good::call) is not referenced any more
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the false branch, At N53 of Function double_free_011_good
> takes the false branch, At N65 of Function double_free_011_good
<Defect> : N42 -> N89: [Return edge from double_free_011_good to main]
N42 -> N89: [Return edge from double_free_011_good to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from double_free_011_bad to main}-> N90
Message  : the heap object @H(double_free_011_bad::call) is not referenced any more
> Start from entry function: main, At N85 of Function main
> Entering function: double_free_011_good, On N88 -> N43 (call double_free_011_good)
> takes the true branch, At N53 of Function double_free_011_good
> Leaving function: double_free_011_good, On N42 -> N89 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N89 -> N1 (call double_free_011_bad)
> takes the false branch, At N11 of Function double_free_011_bad
> takes the false branch, At N23 of Function double_free_011_bad
<Defect> : N0 -> N90: [Return edge from double_free_011_bad to main]
N0 -> N90: [Return edge from double_free_011_bad to main] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 2
	[./415_double_free_11.c 46] double_free_011_good 		[N70 -{call void @free(i8* %4, i8* @free)}-> N72]	(the memory is already freed)
	[./415_double_free_11.c 27] double_free_011_bad 		[N28 -{call void @free(i8* %4, i8* @free)}-> N30]	(the memory is already freed)

CWE_416(Use After Free): 2
	[./415_double_free_11.c 46] double_free_011_good 		[N70 -{call void @free(i8* %4, i8* @free)}-> N72]	(the memory is already freed)
	[./415_double_free_11.c 27] double_free_011_bad 		[N28 -{call void @free(i8* %4, i8* @free)}-> N30]	(the memory is already freed)

CWE_401(Memory Leak): 2
	[./415_double_free_11.c 58] double_free_011_good 		[N42 -{Return edge from double_free_011_good to main}-> N89]	(the heap object @H(double_free_011_good::call) is not referenced any more)
	[./415_double_free_11.c 59] double_free_011_bad 		[N0 -{Return edge from double_free_011_bad to main}-> N90]	(the heap object @H(double_free_011_bad::call) is not referenced any more)

Found 6 defects in all (121 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_5.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_005_bad]
 +double_free_005_bad
SCC(1): [double_free_005_good]
 +double_free_005_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.114s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N47): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N16
On edge  : N16 -{call void @free(i8* %3, i8* @free)}-> N18
Message  : the memory is already freed
> Start from entry function: main, At N47 of Function main
> Entering function: double_free_005_good, On N50 -> N25 (call double_free_005_good)
> takes the true branch, At N32 of Function double_free_005_good
> Leaving function: double_free_005_good, On N24 -> N51 (Return edge from double_free_005_good to main)
> Entering function: double_free_005_bad, On N51 -> N1 (call double_free_005_bad)
> takes the false branch, At N8 of Function double_free_005_bad
> takes the true branch, At N14 of Function double_free_005_bad
<Defect> : N16 -> N18: [call void @free(i8* %3, i8* @free)]
N16 -> N18: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N16
On edge  : N16 -{call void @free(i8* %3, i8* @free)}-> N18
Message  : the memory is already freed
> Start from entry function: main, At N47 of Function main
> Entering function: double_free_005_good, On N50 -> N25 (call double_free_005_good)
> takes the true branch, At N32 of Function double_free_005_good
> Leaving function: double_free_005_good, On N24 -> N51 (Return edge from double_free_005_good to main)
> Entering function: double_free_005_bad, On N51 -> N1 (call double_free_005_bad)
> takes the false branch, At N8 of Function double_free_005_bad
> takes the true branch, At N14 of Function double_free_005_bad
<Defect> : N16 -> N18: [call void @free(i8* %3, i8* @free)]
N16 -> N18: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_5.c 25] double_free_005_bad 		[N16 -{call void @free(i8* %3, i8* @free)}-> N18]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_5.c 25] double_free_005_bad 		[N16 -{call void @free(i8* %3, i8* @free)}-> N18]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_10.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_010_bad]
 +double_free_010_bad
SCC(1): [double_free_010_good]
 +double_free_010_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.12s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N50
On edge  : N50 -{call void @free(i8* %2, i8* @free)}-> N51
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the true branch, At N48 of Function double_free_010_good
> takes the true branch, At N48 of Function double_free_010_good
<Defect> : N50 -> N51: [call void @free(i8* %2, i8* @free)]
N50 -> N51: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N18
On edge  : N18 -{call void @free(i8* %2, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
<Defect> : N18 -> N19: [call void @free(i8* %2, i8* @free)]
N18 -> N19: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the false branch, At N16 of Function double_free_010_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N50
On edge  : N50 -{call void @free(i8* %2, i8* @free)}-> N51
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the true branch, At N48 of Function double_free_010_good
> takes the true branch, At N48 of Function double_free_010_good
<Defect> : N50 -> N51: [call void @free(i8* %2, i8* @free)]
N50 -> N51: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N18
On edge  : N18 -{call void @free(i8* %2, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
<Defect> : N18 -> N19: [call void @free(i8* %2, i8* @free)]
N18 -> N19: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the false branch, At N16 of Function double_free_010_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N32
On edge  : N32 -{Return edge from double_free_010_good to main}-> N66
Message  : the heap object @H(double_free_010_good::call) is not referenced any more
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
<Defect> : N32 -> N66: [Return edge from double_free_010_good to main]
N32 -> N66: [Return edge from double_free_010_good to main] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 3
	[./415_double_free_10.c 45] double_free_010_good 		[N50 -{call void @free(i8* %2, i8* @free)}-> N51]	(the memory is already freed)
	[./415_double_free_10.c 26] double_free_010_bad 		[N18 -{call void @free(i8* %2, i8* @free)}-> N19]	(the memory is already freed)
	[./415_double_free_10.c 29] double_free_010_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 3
	[./415_double_free_10.c 45] double_free_010_good 		[N50 -{call void @free(i8* %2, i8* @free)}-> N51]	(the memory is already freed)
	[./415_double_free_10.c 26] double_free_010_bad 		[N18 -{call void @free(i8* %2, i8* @free)}-> N19]	(the memory is already freed)
	[./415_double_free_10.c 29] double_free_010_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

CWE_401(Memory Leak): 1
	[./415_double_free_10.c 52] double_free_010_good 		[N32 -{Return edge from double_free_010_good to main}-> N66]	(the heap object @H(double_free_010_good::call) is not referenced any more)

Found 7 defects in all (115 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_4.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_004_bad]
 +double_free_004_bad
SCC(1): [double_free_004_good]
 +double_free_004_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.126s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N88): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N39
On edge  : N39 -{call void @free(i8* %6, i8* @free)}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N88 of Function main
> Entering function: double_free_004_good, On N91 -> N52 (call double_free_004_good)
> takes the true branch, At N60 of Function double_free_004_good
> Leaving function: double_free_004_good, On N51 -> N92 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N92 -> N1 (call double_free_004_bad)
> takes the false branch, At N9 of Function double_free_004_bad
> takes the false branch, At N16 of Function double_free_004_bad
> takes the true branch, At N30 of Function double_free_004_bad
> takes the true branch, At N37 of Function double_free_004_bad
<Defect> : N39 -> N41: [call void @free(i8* %6, i8* @free)]
N39 -> N41: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N39
On edge  : N39 -{call void @free(i8* %6, i8* @free)}-> N41
Message  : the memory is already freed
> Start from entry function: main, At N88 of Function main
> Entering function: double_free_004_good, On N91 -> N52 (call double_free_004_good)
> takes the true branch, At N60 of Function double_free_004_good
> Leaving function: double_free_004_good, On N51 -> N92 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N92 -> N1 (call double_free_004_bad)
> takes the false branch, At N9 of Function double_free_004_bad
> takes the false branch, At N16 of Function double_free_004_bad
> takes the true branch, At N30 of Function double_free_004_bad
> takes the true branch, At N37 of Function double_free_004_bad
<Defect> : N39 -> N41: [call void @free(i8* %6, i8* @free)]
N39 -> N41: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from double_free_004_bad to main}-> N93
Message  : the heap object @H(double_free_004_bad::call) is not referenced any more
> Start from entry function: main, At N88 of Function main
> Entering function: double_free_004_good, On N91 -> N52 (call double_free_004_good)
> takes the true branch, At N60 of Function double_free_004_good
> Leaving function: double_free_004_good, On N51 -> N92 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N92 -> N1 (call double_free_004_bad)
> takes the false branch, At N9 of Function double_free_004_bad
> takes the false branch, At N16 of Function double_free_004_bad
> takes the false branch, At N30 of Function double_free_004_bad
> takes the false branch, At N37 of Function double_free_004_bad
<Defect> : N0 -> N93: [Return edge from double_free_004_bad to main]
N0 -> N93: [Return edge from double_free_004_bad to main] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_4.c 37] double_free_004_bad 		[N39 -{call void @free(i8* %6, i8* @free)}-> N41]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_4.c 37] double_free_004_bad 		[N39 -{call void @free(i8* %6, i8* @free)}-> N41]	(the memory is already freed)

CWE_401(Memory Leak): 1
	[./415_double_free_4.c 66] double_free_004_bad 		[N0 -{Return edge from double_free_004_bad to main}-> N93]	(the heap object @H(double_free_004_bad::call) is not referenced any more)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_1.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_001_bad]
 +double_free_001_bad
SCC(1): [double_free_001_good]
 +double_free_001_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.082s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N37): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N13
On edge  : N13 -{call void @free(i8* %2, i8* @free)}-> N15
Message  : the memory is already freed
> Start from entry function: main, At N37 of Function main
> Entering function: double_free_001_good, On N40 -> N20 (call double_free_001_good)
> takes the true branch, At N27 of Function double_free_001_good
> Leaving function: double_free_001_good, On N19 -> N41 (Return edge from double_free_001_good to main)
> Entering function: double_free_001_bad, On N41 -> N1 (call double_free_001_bad)
> takes the false branch, At N8 of Function double_free_001_bad
<Defect> : N13 -> N15: [call void @free(i8* %2, i8* @free)]
N13 -> N15: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N13
On edge  : N13 -{call void @free(i8* %2, i8* @free)}-> N15
Message  : the memory is already freed
> Start from entry function: main, At N37 of Function main
> Entering function: double_free_001_good, On N40 -> N20 (call double_free_001_good)
> takes the true branch, At N27 of Function double_free_001_good
> Leaving function: double_free_001_good, On N19 -> N41 (Return edge from double_free_001_good to main)
> Entering function: double_free_001_bad, On N41 -> N1 (call double_free_001_bad)
> takes the false branch, At N8 of Function double_free_001_bad
<Defect> : N13 -> N15: [call void @free(i8* %2, i8* @free)]
N13 -> N15: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_1.c 25] double_free_001_bad 		[N13 -{call void @free(i8* %2, i8* @free)}-> N15]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_1.c 25] double_free_001_bad 		[N13 -{call void @free(i8* %2, i8* @free)}-> N15]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

Using Tsmart-VBSAC Static Analyzer:...
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/VBSAC/VBSAC_tool/engine-3.0/../../benchmark_ptr/itc/415/415_double_free_12.ll]
Start merging IR files...done
Start parsing IR files...done
Start creating CFA...done
Start inserting global variables...done
Start removing unreachable CFA nodes...done
Start simplifying CFA...done
Start labeling reverse post order id...done
Start labeling exploration priority...done
Start inserting function call/return edges...done
Start post process...done
CFA exported to: output/phase-cfa/cfa-merged/cfa.dot
Function CFA exported to: output/phase-cfa/cfa-separate/
Call graph exported to: output/phase-cfa/cfa-merged/call-graph.dot
Used instruction types are exported to: output/phase-cfa/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_012_bad]
 +double_free_012_bad
SCC(1): [double_free_012_good]
 +double_free_012_good
SCC(1): [main]
 +main
AP summary saved to: output/phase-summary/ap/summary.txt
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.129s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N31
On edge  : N31 -{Return edge from double_free_012_good to main}-> N67
Message  : the heap object @H(double_free_012_good::call) is not referenced any more
> Start from entry function: main, At N63 of Function main
> Entering function: double_free_012_good, On N66 -> N32 (call double_free_012_good)
> takes the false branch, At N40 of Function double_free_012_good
> takes the false branch, At N48 of Function double_free_012_good
<Defect> : N31 -> N67: [Return edge from double_free_012_good to main]
N31 -> N67: [Return edge from double_free_012_good to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N0
On edge  : N0 -{Return edge from double_free_012_bad to main}-> N68
Message  : the heap object @H(double_free_012_bad::call) is not referenced any more
> Start from entry function: main, At N63 of Function main
> Entering function: double_free_012_good, On N66 -> N32 (call double_free_012_good)
> takes the false branch, At N40 of Function double_free_012_good
> takes the false branch, At N48 of Function double_free_012_good
> Leaving function: double_free_012_good, On N31 -> N67 (Return edge from double_free_012_good to main)
> Entering function: double_free_012_bad, On N67 -> N1 (call double_free_012_bad)
> takes the false branch, At N9 of Function double_free_012_bad
> takes the false branch, At N17 of Function double_free_012_bad
<Defect> : N0 -> N68: [Return edge from double_free_012_bad to main]
N0 -> N68: [Return edge from double_free_012_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N50
On edge  : N50 -{call void @free(i8* %2, i8* @free)}-> N52
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: double_free_012_good, On N66 -> N32 (call double_free_012_good)
> takes the false branch, At N40 of Function double_free_012_good
> takes the true branch, At N48 of Function double_free_012_good
> takes the true branch, At N48 of Function double_free_012_good
<Defect> : N50 -> N52: [call void @free(i8* %2, i8* @free)]
N50 -> N52: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N19
On edge  : N19 -{call void @free(i8* %2, i8* @free)}-> N21
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: double_free_012_good, On N66 -> N32 (call double_free_012_good)
> takes the false branch, At N40 of Function double_free_012_good
> takes the false branch, At N48 of Function double_free_012_good
> Leaving function: double_free_012_good, On N31 -> N67 (Return edge from double_free_012_good to main)
> Entering function: double_free_012_bad, On N67 -> N1 (call double_free_012_bad)
> takes the false branch, At N9 of Function double_free_012_bad
> takes the true branch, At N17 of Function double_free_012_bad
> takes the true branch, At N17 of Function double_free_012_bad
<Defect> : N19 -> N21: [call void @free(i8* %2, i8* @free)]
N19 -> N21: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N50
On edge  : N50 -{call void @free(i8* %2, i8* @free)}-> N52
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: double_free_012_good, On N66 -> N32 (call double_free_012_good)
> takes the false branch, At N40 of Function double_free_012_good
> takes the true branch, At N48 of Function double_free_012_good
> takes the true branch, At N48 of Function double_free_012_good
<Defect> : N50 -> N52: [call void @free(i8* %2, i8* @free)]
N50 -> N52: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call void @free(i8* %2, i8* @free)}-> N21
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: double_free_012_good, On N66 -> N32 (call double_free_012_good)
> takes the false branch, At N40 of Function double_free_012_good
> takes the false branch, At N48 of Function double_free_012_good
> Leaving function: double_free_012_good, On N31 -> N67 (Return edge from double_free_012_good to main)
> Entering function: double_free_012_bad, On N67 -> N1 (call double_free_012_bad)
> takes the false branch, At N9 of Function double_free_012_bad
> takes the true branch, At N17 of Function double_free_012_bad
> takes the true branch, At N17 of Function double_free_012_bad
<Defect> : N19 -> N21: [call void @free(i8* %2, i8* @free)]
N19 -> N21: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./415_double_free_12.c 54] double_free_012_good 		[N31 -{Return edge from double_free_012_good to main}-> N67]	(the heap object @H(double_free_012_good::call) is not referenced any more)
	[./415_double_free_12.c 55] double_free_012_bad 		[N0 -{Return edge from double_free_012_bad to main}-> N68]	(the heap object @H(double_free_012_bad::call) is not referenced any more)

CWE_415(Double Free): 2
	[./415_double_free_12.c 43] double_free_012_good 		[N50 -{call void @free(i8* %2, i8* @free)}-> N52]	(the memory is already freed)
	[./415_double_free_12.c 26] double_free_012_bad 		[N19 -{call void @free(i8* %2, i8* @free)}-> N21]	(the memory is already freed)

CWE_416(Use After Free): 2
	[./415_double_free_12.c 43] double_free_012_good 		[N50 -{call void @free(i8* %2, i8* @free)}-> N52]	(the memory is already freed)
	[./415_double_free_12.c 26] double_free_012_bad 		[N19 -{call void @free(i8* %2, i8* @free)}-> N21]	(the memory is already freed)

Found 6 defects in all (121 duplicates ignored).
=====================================================
Phase status: SUCCESS

